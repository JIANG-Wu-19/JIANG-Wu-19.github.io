<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="算法实验, J&amp;Ocean BLOG">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>算法实验 | J&amp;Ocean BLOG</title>
    <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>



   <style>
    body{
       background-image: url(https://github.com/JIANG-Wu-19/JIANG-Wu-19/blob/master/99759389_p0.png?raw=true);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.ico" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">J&amp;Ocean BLOG</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.ico" class="logo-img circle responsive-img">
        
        <div class="logo-name">J&amp;Ocean BLOG</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">算法实验</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%AE%97%E6%B3%95/">
                                <span class="chip bg-color">算法</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AF%BE%E5%86%85%E5%AE%9E%E9%AA%8C/" class="post-category">
                                课内实验
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-07-22
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    11.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    53 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>项目GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/JIANG-Wu-19/Algorithms_experiments">Algorithms_experiments</a></p>
<h1 id="实验一：递归与分治"><a href="#实验一：递归与分治" class="headerlink" title="实验一：递归与分治"></a>实验一：递归与分治</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>理解递归算法的思想和递归程序的执行过程，并能熟练编写递归程序。</p>
<p>掌握分治算法的思想，对给定的问题能设计出分治算法予以解决。</p>
<h2 id="实验预习内容"><a href="#实验预习内容" class="headerlink" title="实验预习内容"></a>实验预习内容</h2><p>编程实现讲过的例题：二分搜索、合并排序、快速排序。</p>
<p>对本实验中的问题，设计出算法并编程实现。</p>
<h2 id="实验内容和步骤"><a href="#实验内容和步骤" class="headerlink" title="实验内容和步骤"></a>实验内容和步骤</h2><h3 id="快速排序及第k小数"><a href="#快速排序及第k小数" class="headerlink" title="快速排序及第k小数"></a>快速排序及第k小数</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="问题分析及算法思路"><a href="#问题分析及算法思路" class="headerlink" title="问题分析及算法思路"></a>问题分析及算法思路</h5><p>快速排序的基本思想：</p>
<ul>
<li>通过一趟排序将待排序列分割成<strong>独立的两部分</strong>，其中一部分的值比另一部分的小，则分别对两部分序列继续进行排序，达到整个序列有序</li>
</ul>
<p>实现逻辑：</p>
<p>使用分治法将序列分成两个子序列</p>
<blockquote>
<ol>
<li>从序列中选出一个元素，称为基准值（pivot），即<strong>确定分界点</strong>，可以选取$q[1]$,$q[(1+r)&#x2F;2]$,$q[r]$或者随机</li>
<li>重新排序序列，所有元素小于基准值的放在基准值前面，所有元素比基准值大的摆在基准的后面（相同的数规定放到确定的某一边）。分区推出之后，基准处于中间位置，这一步称为<strong>调整区间</strong></li>
<li>对于分出的两个子序列继续进行上述操作，<strong>递归处理左右两段</strong></li>
</ol>
</blockquote>
<p>对于<strong>调整区间</strong>可实现的方法有：</p>
<blockquote>
<blockquote>
<ul>
<li>开辟额外的数组a[]、b[]</li>
<li>扫描$q[1:r]$<ul>
<li>当$q[i] \le x$时，将x插入到a[]</li>
<li>当$q[i] \ge x$时，将x插入到b[]</li>
</ul>
</li>
<li>分别将a[],b[]中的数放在q中</li>
</ul>
</blockquote>
<blockquote>
<p>双指针法，设置i、j指针分别指向第一个和末尾一个，分别向左向右移动，知道重合</p>
</blockquote>
</blockquote>
<p>在本实验中，使用双指针法进行快排</p>
<h5 id="算法设计与代码实现"><a href="#算法设计与代码实现" class="headerlink" title="算法设计与代码实现"></a>算法设计与代码实现</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quicksort(int q[], int l, int r)
&#123;
    if (l &gt;&#x3D; r) return;						&#x2F;&#x2F;判边界
    int x &#x3D; q[l], i &#x3D; l - 1, j &#x3D; r + 1;	
    while (i &lt; j)
    &#123;
        do i ++ ; while (q[i] &lt; x);
        do j -- ; while (q[j] &gt; x);
        if (i &lt; j) swap(q[i], q[j]);
    &#125;
    quicksort(q, l, j), quicksort(q, j + 1, r);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h5><p><img src="/imgs/suanfashiyan/1.png" alt="image-20230604152213930"></p>
<p>经过多次测试，算法的运行结果均正确，符合题意。</p>
<p>快速排序的算法时间复杂度是$O(N*logN)$</p>
<h4 id="第k小数"><a href="#第k小数" class="headerlink" title="第k小数"></a>第k小数</h4><p>这道题目是课外思考题<code>top_k</code>的一个变式，找到序列中第k小的数</p>
<h5 id="问题分析及算法思路-1"><a href="#问题分析及算法思路-1" class="headerlink" title="问题分析及算法思路"></a>问题分析及算法思路</h5><h6 id="基于快速排序的减治法"><a href="#基于快速排序的减治法" class="headerlink" title="基于快速排序的减治法"></a>基于快速排序的减治法</h6><p>借用“快速排序”的思想，对整个序列进行<strong>划分</strong>(取序列第一个元素作为枢轴，也可采用随机法、三数取中法等方法)，并返回<strong>划分后的位置</strong>，若等于<code>k</code>则得到答案；若大于<code>k</code>，则说明该元素左边的元素都小于<code>k</code>，递归求解该位置前面序列第<code>k</code>小的元素即可；若小于<code>k</code>，则递归求解该位置后面序列第<code>k - count</code>(<code>count</code>为该序列中<code>[l,j]</code>的元素数量，其中<code>j</code>为划分后的元素位置)小的元素即可。由此，每次仅需求解大问题的一个子问题，最后即可得到第<code>k</code>小的数。</p>
<h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><p>使用冒泡排序的思想，每次冒泡都是找到了序列中的第i小的数（i为冒泡次数），i&#x3D;k时找到第k小数</p>
<h6 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h6><p>堆排序中，每次弹出一个最小的值，只需要执行k次弹数操作就可以得到第k小数</p>
<p>堆</p>
<blockquote>
<p>是一个完全二叉树</p>
<p>每个节点的值都大于或等于其叶子的值，为最大堆；反之为最小堆</p>
</blockquote>
<p>堆排序</p>
<blockquote>
<ol>
<li>将待排序的序列构造成一个最大堆，此时序列的最大值为根节点</li>
<li>依次将根节点与待排序序列的最后一个元素交换</li>
<li>再维护从根节点到该元素的前一个节点为最大堆，如此往复，得到一个递增序列</li>
</ol>
</blockquote>
<h5 id="算法设计与代码实现-1"><a href="#算法设计与代码实现-1" class="headerlink" title="算法设计与代码实现"></a>算法设计与代码实现</h5><h6 id="减治法"><a href="#减治法" class="headerlink" title="减治法"></a>减治法</h6><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int quicksort(int a[], int l, int r)
&#123;
	int pivot &#x3D; a[l];						
	int i &#x3D; l - 1, j &#x3D; r + 1;
	do
	&#123;
		do &#123; i++; &#125; while (a[i] &lt; pivot);
		do &#123; j--; &#125; while (a[j] &gt; pivot);
		if (i &lt; j)  swap(a[i], a[j]);
	&#125; while (i &lt; j);

	return j;
&#125;

void Top_k(int a[], int l, int r, int k)
&#123;
	if (l &gt;&#x3D; r) return;
	int j &#x3D; quicksort(a, l, r);
	int count &#x3D; j - l + 1;					
	if (count &#x3D;&#x3D; k)
	&#123;
		return;
	&#125;
	else if(count &gt; k)
	&#123;
		Top_k(a, l, j, k);					
	&#125;
	else
	&#123;
		Top_k(a, j + 1, r, k - count);		
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/imgs/suanfashiyan/2.png" alt="image-20230604163142845"></p>
<h6 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bubblesort(int a[], int k, int n)
&#123;
	for (int i &#x3D; 0; i &lt; k; i++)
	&#123;
		for (int j &#x3D; n - 2; j &gt;&#x3D; i; j--)		 
		&#123;
			if (a[j + 1] &lt; a[j])			
			&#123;
				int temp &#x3D; a[j];
				a[j] &#x3D; a[j + 1];
				a[j + 1] &#x3D; temp;
			&#125;
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/imgs/suanfashiyan/3.png" alt="image-20230604164023408"></p>
<h6 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h6><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void down(int u)
&#123;
    int t &#x3D; u;			&#x2F;&#x2F; t为点、左孩子、右孩子三个点中最小的一个点
    if (u * 2 &lt;&#x3D; cnt &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2;
    if (u * 2 + 1 &lt;&#x3D; cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1;
    if (u !&#x3D; t)			&#x2F;&#x2F; 根节点不是最小的
    &#123;
        &#x2F;&#x2F; 与最小的点交换
        swap(h[u], h[t]);
        down(t);		&#x2F;&#x2F; 递归处理
    &#125;
&#125;

void up(int u)
&#123;
    while (u &#x2F; 2 &amp;&amp; h[u] &lt; h[u &#x2F; 2])
    &#123;
        swap(h[u &#x2F; 2], h[u]);
        u &gt;&gt;&#x3D; 1;		&#x2F;&#x2F; u &#x2F;&#x3D; 2换上去
    &#125;
&#125;

void HeapSort(int h[], int k, int n)
&#123;
    for (int i &#x3D; n &#x2F; 2; i; i--) down(i);	&#x2F;&#x2F; O(n)的时间复杂度建堆

    while (m--)
    &#123;
        if(m &#x3D;&#x3D; 0)&#123;
        	cout&lt;&lt;h[1]&lt;&lt;endl;
		&#125;
        h[1] &#x3D; h[cnt--];
        down(1);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/imgs/suanfashiyan/4.png" alt="image-20230604165037548"></p>
<p>经过测试，上述方法均能实现查找第k小数的功能</p>
<h5 id="关于上述方法的时间复杂度分析"><a href="#关于上述方法的时间复杂度分析" class="headerlink" title="关于上述方法的时间复杂度分析"></a>关于上述方法的时间复杂度分析</h5><ul>
<li>对于减治法，时间复杂度是$O(n)$</li>
<li>对于冒泡排序，时间复杂度是$O(kn)$</li>
<li>对于堆排序，由于需要构建完整堆，时间复杂度是$O(n*logn)$</li>
</ul>
<blockquote>
<p>对于减治法，设每次划分的pivot恰好是序列的中值，可以保证每一次减治去掉一半的区间，由于一次划分耗费$O(n)$的时间，因此只需要处理剩下的一半大小的子序列，得到递推公式<br>$$<br>T(n)&#x3D;T(n&#x2F;2)+O(n)\<br>T(n)&#x3D;O(n)<br>$$</p>
</blockquote>
<h3 id="棋盘覆盖问题"><a href="#棋盘覆盖问题" class="headerlink" title="棋盘覆盖问题"></a>棋盘覆盖问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在一个$2^k*2^k$方格组成的棋盘中，恰有一个方格与其它方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖；</p>
<p><img src="/imgs/suanfashiyan/5.png" alt="image-20221126115310770"></p>
<h4 id="问题分析与算法思路"><a href="#问题分析与算法思路" class="headerlink" title="问题分析与算法思路"></a>问题分析与算法思路</h4><p>采用<strong>分治</strong>的思想，首先将棋盘进行划分：</p>
<blockquote>
<ol>
<li>当k&#x3D;0时，是一个**$1*1$的棋盘**，棋盘中的骨牌数是0</li>
<li>当k&gt;0时，将$2^k*2^k$分割成4个$2^{k-1}*2^{k-1}$的子棋盘，特殊方格必定位于4个子棋盘注意，其余3个子棋盘中没有特殊方格</li>
</ol>
</blockquote>
<p>对于划分出来的四个子棋盘，用一个L型骨牌覆盖3个没有特殊方格的子棋盘的连接处</p>
<p><img src="/imgs/suanfashiyan/6.png" alt="6"></p>
<p>至此，对每个棋盘按照左上、右上、右下、左下的顺时针顺序铺满棋盘；每次都对分割后的四个小方块进行特殊方格判断：</p>
<blockquote>
<ul>
<li>如果特殊方块在里面，递归</li>
<li>不在，根据分割的不同位置，把三个角落的方格标记为特殊方块，递归、</li>
</ul>
</blockquote>
<h4 id="算法设计与代码实现-2"><a href="#算法设计与代码实现-2" class="headerlink" title="算法设计与代码实现"></a>算法设计与代码实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 函数：棋盘覆盖
void chessboardCover(int tr, int tc, int dr, int dc, int size) &#123;
    if (size &#x3D;&#x3D; 1)
        return;

    int t &#x3D; tileID++;
    int s &#x3D; size &#x2F; 2;

    &#x2F;&#x2F; 左上角子棋盘
    if (dr &lt; tr + s &amp;&amp; dc &lt; tc + s)
        chessboardCover(tr, tc, dr, dc, s);
    else &#123;
        &#x2F;&#x2F; 不在左上角，用t号骨牌覆盖右下角
        board[tr + s - 1][tc + s - 1] &#x3D; t;
        &#x2F;&#x2F; 覆盖其他方格
        chessboardCover(tr, tc, tr + s - 1, tc + s - 1, s);
    &#125;

    &#x2F;&#x2F; 右上角子棋盘
    if (dr &lt; tr + s &amp;&amp; dc &gt;&#x3D; tc + s)
        chessboardCover(tr, tc + s, dr, dc, s);
    else &#123;
        &#x2F;&#x2F; 不在右上角，用t号骨牌覆盖左下角
        board[tr + s - 1][tc + s] &#x3D; t;
        &#x2F;&#x2F; 覆盖其他方格
        chessboardCover(tr, tc + s, tr + s - 1, tc + s, s);
    &#125;

    &#x2F;&#x2F; 左下角子棋盘
    if (dr &gt;&#x3D; tr + s &amp;&amp; dc &lt; tc + s)
        chessboardCover(tr + s, tc, dr, dc, s);
    else &#123;
        &#x2F;&#x2F; 不在左下角，用t号骨牌覆盖右上角
        board[tr + s][tc + s - 1] &#x3D; t;
        &#x2F;&#x2F; 覆盖其他方格
        chessboardCover(tr + s, tc, tr + s, tc + s - 1, s);
    &#125;

    &#x2F;&#x2F; 右下角子棋盘
    if (dr &gt;&#x3D; tr + s &amp;&amp; dc &gt;&#x3D; tc + s)
        chessboardCover(tr + s, tc + s, dr, dc, s);
    else &#123;
        &#x2F;&#x2F; 不在右下角，用t号骨牌覆盖左上角
        board[tr + s][tc + s] &#x3D; t;
        &#x2F;&#x2F; 覆盖其他方格
        chessboardCover(tr + s, tc + s, tr + s, tc + s, s);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="算法演示-1"><a href="#算法演示-1" class="headerlink" title="算法演示"></a>算法演示</h4><p><img src="/imgs/suanfashiyan/7.png" alt="image-20230604174723961"></p>
<p>经过多组测试，算法运行正确</p>
<h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>分析时间复杂度：</p>
<p>递推式<br>$$<br>T(k)&#x3D;\left{\begin{array}{cc}<br>O(1) &amp; k&#x3D;0 \<br>4 T(k-1)+O(1) &amp; k&gt;0<br>\end{array}\right.<br>$$<br>解得<br>$$<br>T(k)&#x3D;O(4^k)<br>$$<br>设$n&#x3D;2^k$，得到时间复杂度是$O(n^2)$</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>分治即“<strong>分而治之</strong>”，一个规模很大的问题若要直接求解起来是非常困难的，将一个复杂的问题分解为若干个规模较小但是类似于原问题的子问题，子问题可以再分为更小的子问题，最终达到子问题可以简单的直接求解的目的，那么原问题的解即子问题的解的并集。分治算法可以缩小问题的规模，使得问题的求解变得十分容易。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="快速排序源代码"><a href="#快速排序源代码" class="headerlink" title="快速排序源代码"></a>快速排序源代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define N 20

using namespace std;

void quicksort(int q[], int l, int r)
&#123;
    if (l &gt;&#x3D; r) return;						&#x2F;&#x2F;判边界
    int x &#x3D; q[l], i &#x3D; l - 1, j &#x3D; r + 1;	
    while (i &lt; j)
    &#123;
        do i ++ ; while (q[i] &lt; x);
        do j -- ; while (q[j] &gt; x);
        if (i &lt; j) swap(q[i], q[j]);
    &#125;
    quicksort(q, l, j), quicksort(q, j + 1, r);
&#125;

int main()&#123; 
	int n,q[N];
	cout&lt;&lt;&quot;请输入元素个数与序列：&quot;&lt;&lt;endl;
	cin&gt;&gt;n;
	for(int i&#x3D;0;i&lt;n;i++)&#123;
		cin&gt;&gt;q[i];
	&#125;
	
	quicksort(q,0,n-1);
	
	for(int i&#x3D;0;i&lt;n;i++)&#123;
		cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;
	&#125;
	
	cout&lt;&lt;endl;
	system(&quot;pause&quot;);
	return 0;	
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="第k小数源代码"><a href="#第k小数源代码" class="headerlink" title="第k小数源代码"></a>第k小数源代码</h3><h4 id="减治法-1"><a href="#减治法-1" class="headerlink" title="减治法"></a>减治法</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N &#x3D; 20;

int quicksort(int a[], int l, int r)
&#123;
	int pivot &#x3D; a[l];						
	int i &#x3D; l - 1, j &#x3D; r + 1;
	do
	&#123;
		do &#123; i++; &#125; while (a[i] &lt; pivot);
		do &#123; j--; &#125; while (a[j] &gt; pivot);
		if (i &lt; j)  swap(a[i], a[j]);
	&#125; while (i &lt; j);

	return j;
&#125;

void Top_k(int a[], int l, int r, int k)
&#123;
	if (l &gt;&#x3D; r) return;
	int j &#x3D; quicksort(a, l, r);
	int count &#x3D; j - l + 1;					
	if (count &#x3D;&#x3D; k)
	&#123;
		return;
	&#125;
	else if(count &gt; k)
	&#123;
		Top_k(a, l, j, k);					
	&#125;
	else
	&#123;
		Top_k(a, j + 1, r, k - count);		
	&#125;
&#125;

int main()
&#123;
	int a[N], k, n;
	cout &lt;&lt; &quot;请输入元素个数与序列:&quot; &lt;&lt; endl;
	cin &gt;&gt; n;
	for (int i &#x3D; 0; i &lt; n; i++)
	&#123;
		cin &gt;&gt; a[i];
	&#125;
	cout &lt;&lt; &quot;请输入要获得的第k小数&quot; &lt;&lt; endl;
	cin &gt;&gt; k;
	
	Top_k(a, 0, n - 1, k);
    
	cout &lt;&lt; &quot;第&quot; &lt;&lt; k &lt;&lt; &quot;小数是&quot; &lt;&lt; a[k - 1] &lt;&lt; endl;
	cout &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="冒泡排序-2"><a href="#冒泡排序-2" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
const int N &#x3D; 20;

void bubblesort(int a[], int k, int n)
&#123;
	for (int i &#x3D; 0; i &lt; k; i++)
	&#123;
		for (int j &#x3D; n - 2; j &gt;&#x3D; i; j--)		 
		&#123;
			if (a[j + 1] &lt; a[j])			
			&#123;
				int temp &#x3D; a[j];
				a[j] &#x3D; a[j + 1];
				a[j + 1] &#x3D; temp;
			&#125;
		&#125;
	&#125;
&#125;

int main()
&#123;
	int a[N], k, n;
	cout &lt;&lt; &quot;请输入元素个数与序列:&quot; &lt;&lt; endl;
	cin &gt;&gt; n;
	for (int i &#x3D; 0; i &lt; n; i++)
	&#123;
		cin &gt;&gt; a[i];
	&#125;
	cout &lt;&lt; &quot;请输入要获得的第k小数&quot; &lt;&lt; endl;
	cin &gt;&gt; k;
	bubblesort(a, k, n);
	cout &lt;&lt; a[k - 1] &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="堆排序-2"><a href="#堆排序-2" class="headerlink" title="堆排序"></a>堆排序</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

const int N &#x3D; 100010;

int n, m;
int h[N], cnt;

void down(int u)
&#123;
    int t &#x3D; u;			&#x2F;&#x2F; t为点、左孩子、右孩子三个点中最小的一个点
    if (u * 2 &lt;&#x3D; cnt &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2;
    if (u * 2 + 1 &lt;&#x3D; cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1;
    if (u !&#x3D; t)			&#x2F;&#x2F; 根节点不是最小的
    &#123;
        &#x2F;&#x2F; 与最小的点交换
        swap(h[u], h[t]);
        down(t);		&#x2F;&#x2F; 递归处理
    &#125;
&#125;

void up(int u)
&#123;
    while (u &#x2F; 2 &amp;&amp; h[u] &lt; h[u &#x2F; 2])
    &#123;
        swap(h[u &#x2F; 2], h[u]);
        u &gt;&gt;&#x3D; 1;		&#x2F;&#x2F; u &#x2F;&#x3D; 2换上去
    &#125;
&#125;

void HeapSort(int h[], int k, int n)
&#123;
    for (int i &#x3D; n &#x2F; 2; i; i--) down(i);	&#x2F;&#x2F; O(n)的时间复杂度建堆

    while (m--)
    &#123;
        if(m &#x3D;&#x3D; 0)&#123;
        	cout&lt;&lt;h[1]&lt;&lt;endl;
		&#125;
        h[1] &#x3D; h[cnt--];
        down(1);
    &#125;
&#125;

int main()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) cin&gt;&gt;h[i];
    cnt &#x3D; n;
    HeapSort(h, m, n);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="棋盘覆盖问题源代码"><a href="#棋盘覆盖问题源代码" class="headerlink" title="棋盘覆盖问题源代码"></a>棋盘覆盖问题源代码</h3> <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;iostream&gt;  
using namespace std;
int num &#x3D; 1;                   &#x2F;&#x2F;L型骨牌的编号(递增)  
int board[100][100];  &#x2F;&#x2F;棋盘  
&#x2F;*****************************************************
* tr--当前棋盘左上角的行号
* tc--当前棋盘左上角的列号
* dr--当前特殊方格所在的行号
* dc--当前特殊方格所在的列号
* size：当前棋盘的:2^k
*****************************************************&#x2F;
void chessboardCover(int tr, int tc, int dr, int dc, int size) &#123;
    if (size &#x3D;&#x3D; 1)
        return;

    int t &#x3D; num++;
    int s &#x3D; size &#x2F; 2;

    &#x2F;&#x2F; 左上角子棋盘
    if (dr &lt; tr + s &amp;&amp; dc &lt; tc + s)
        chessboardCover(tr, tc, dr, dc, s);
    else &#123;
        &#x2F;&#x2F; 不在左上角，用t号骨牌覆盖右下角
        board[tr + s - 1][tc + s - 1] &#x3D; t;
        &#x2F;&#x2F; 覆盖其他方格
        chessboardCover(tr, tc, tr + s - 1, tc + s - 1, s);
    &#125;

    &#x2F;&#x2F; 右上角子棋盘
    if (dr &lt; tr + s &amp;&amp; dc &gt;&#x3D; tc + s)
        chessboardCover(tr, tc + s, dr, dc, s);
    else &#123;
        &#x2F;&#x2F; 不在右上角，用t号骨牌覆盖左下角
        board[tr + s - 1][tc + s] &#x3D; t;
        &#x2F;&#x2F; 覆盖其他方格
        chessboardCover(tr, tc + s, tr + s - 1, tc + s, s);
    &#125;

    &#x2F;&#x2F; 左下角子棋盘
    if (dr &gt;&#x3D; tr + s &amp;&amp; dc &lt; tc + s)
        chessboardCover(tr + s, tc, dr, dc, s);
    else &#123;
        &#x2F;&#x2F; 不在左下角，用t号骨牌覆盖右上角
        board[tr + s][tc + s - 1] &#x3D; t;
        &#x2F;&#x2F; 覆盖其他方格
        chessboardCover(tr + s, tc, tr + s, tc + s - 1, s);
    &#125;

    &#x2F;&#x2F; 右下角子棋盘
    if (dr &gt;&#x3D; tr + s &amp;&amp; dc &gt;&#x3D; tc + s)
        chessboardCover(tr + s, tc + s, dr, dc, s);
    else &#123;
        &#x2F;&#x2F; 不在右下角，用t号骨牌覆盖左上角
        board[tr + s][tc + s] &#x3D; t;
        &#x2F;&#x2F; 覆盖其他方格
        chessboardCover(tr + s, tc + s, tr + s, tc + s, s);
    &#125;
&#125;

int main()
&#123;
    int size;
    cout &lt;&lt; &quot;输入棋盘的size(大小必须是2的n次幂): &quot;;
    cin &gt;&gt; size;
    int index_x, index_y;
    cout &lt;&lt; &quot;输入特殊方格位置的坐标: &quot;;
    getchar();
    cin&gt;&gt;index_x&gt;&gt;index_y;
    chessboardCover(0, 0, index_x - 1, index_y - 1, size);
    for (int i &#x3D; 0; i &lt; size; i++)
    &#123;
        for (int j &#x3D; 0; j &lt; size; j++)
            cout &lt;&lt; board[i][j] &lt;&lt; &quot;\t&quot;;
        cout &lt;&lt; endl;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="实验四：动态规划"><a href="#实验四：动态规划" class="headerlink" title="实验四：动态规划"></a>实验四：动态规划</h1><h2 id="计算矩阵连乘积"><a href="#计算矩阵连乘积" class="headerlink" title="计算矩阵连乘积"></a>计算矩阵连乘积</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>在科学计算中经常要计算矩阵的乘积。矩阵A和B可乘的条件是矩阵A的列数等于矩阵B的行数。若A是一个$p×q$的矩阵，B是一个$q×r$的矩阵，则其乘积C&#x3D;AB是一个$p×r$的矩阵。由该公式知计算C&#x3D;AB总共需要<strong>pqr</strong>次的数乘。其标准计算公式为：<br>$$<br>C_{ij}&#x3D;\sum_{k&#x3D;1}^qA_{ik}B_{kj}(1\le i\le p,1\le j \le r)<br>$$<br>现在问题是现在的问题是，给定n个矩阵$\lbrace A1,A2,…,An \rbrace$。其中Ai与Ai+1是可乘的，i&#x3D;1,2,…,n-1。要求计算出这n个矩阵的连乘积A1A2…An。</p>
<h3 id="问题分析与算法思想"><a href="#问题分析与算法思想" class="headerlink" title="问题分析与算法思想"></a>问题分析与算法思想</h3><p>设二维数组$m[N][N]$表示当前矩阵的连乘次数，一维数组$p[N]$表示各矩阵的维度（其中$p[0]$表示第一个矩阵的行数，$p[i]$表示第i个矩阵的列数），则得到以下递推公式：</p>
<p>$$<br>m[i][j]&#x3D;\left{\begin{array}{cc}<br>0 &amp; i&#x3D;j \<br>\min <em>{i \leq k&lt;j}\left{m[i][k]+m[k+1][j]+p</em>{i-1} p_k p_j\right} &amp; i&lt;j<br>\end{array}\right.<br>$$<br>将m数组的对角线初始化为0，然后依次计算第i个矩阵与第i+r-1个矩阵到最后一个矩阵连乘的最优解情况：依次在r-1个分隔位置中依次检测最优分隔点：对于每个分隔点，变换依次分隔位置，再进行逐一测试，如果有更有的分隔点，就替换掉当前的分隔点。</p>
<p>由此，输出$m[1][n]$，得到最少的连乘计算次数；记录间隔位置，可以输出计算连乘的顺序，即最佳添加括号的方式</p>
<h3 id="算法设计与代码实现-3"><a href="#算法设计与代码实现-3" class="headerlink" title="算法设计与代码实现"></a>算法设计与代码实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void MatrixChain(int n)
&#123;
	int r, i, j, k;
	for (i &#x3D; 0; i &lt;&#x3D; n; i++)				&#x2F;&#x2F; 初始化对角线
	&#123;
		m[i][i] &#x3D; 0;
	&#125;
	for (r &#x3D; 2; r &lt;&#x3D; n; r++)				&#x2F;&#x2F; r 个矩阵连乘
	&#123;
		for (i &#x3D; 1; i &lt;&#x3D; n - r + 1; i++)	&#x2F;&#x2F; 依次计算每r个矩阵相连乘的最优解情况
		&#123;
			j &#x3D; i + r - 1;
			m[i][j] &#x3D; m[i][i] + m[i + 1][j] + p[i - 1] * p[i] * p[j];
			s[i][j] &#x3D; i;					&#x2F;&#x2F; 分隔位置
			for (k &#x3D; i + 1; k &lt; j; k++)		 &#x2F;&#x2F; 变换分隔位置，逐一测试
			&#123;
				int t &#x3D; m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
				if (t &lt; m[i][j])			&#x2F;&#x2F; 如果变换后的位置更优，则替换原来的分隔方法
				&#123;
					m[i][j] &#x3D; t;
					s[i][j] &#x3D; k;
				&#125;
			&#125;
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>算法演示：</p>
<p><img src="/imgs/suanfashiyan/8.png" alt="image-20230605122639394"></p>
<p><img src="/imgs/suanfashiyan/9.png" alt="image-20230605122812755"></p>
<h3 id="算法讨论"><a href="#算法讨论" class="headerlink" title="算法讨论"></a>算法讨论</h3><p>通过动态规划来确定矩阵连乘顺序的时间复杂度是$O(n^3)$，在大规模矩阵连乘是，选择最优的连乘顺序，可以大幅度减少计算量，提高计算效率</p>
<h2 id="防卫导弹"><a href="#防卫导弹" class="headerlink" title="防卫导弹"></a>防卫导弹</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>一种新型的防卫导弹可截击多个攻击导弹。它可以向前飞行，也可以用很快的速度向下飞行，可以毫无损伤地截击进攻导弹，但不可以向后或向上飞行。但有一个缺点，尽管它发射时可以达到任意高度，但它只能截击比它上次截击导弹时所处高度低或者高度相同的导弹。现对这种新型防卫导弹进行测试，在每一次测试中，发射一系列的测试导弹（这些导弹发射的间隔时间固定，飞行速度相同），该防卫导弹所能获得的信息包括各进攻导弹的高度，以及它们发射次序。现要求编一程序，求在每次测试中，该防卫导弹最多能截击的进攻导弹数量，一个导弹能被截击应满足下列两个条件之一：</p>
<ol>
<li>它是该次测试中第一个被防卫导弹截击的导弹</li>
<li>它是在上一次被截击导弹的发射后发射，且高度不大于上一次被截击导弹的高度的导弹</li>
</ol>
<p>输入数据：第一行是一个整数n，以后的n各有一个整数表示导弹的高度</p>
<p>输出数据：截击导弹的最大数目</p>
<h3 id="问题分析与算法思想-1"><a href="#问题分析与算法思想-1" class="headerlink" title="问题分析与算法思想"></a>问题分析与算法思想</h3><p>对于本题的拦截导弹问题，因为一个导弹能被截击应满足高度不大于上一次被截击导弹的高度的导弹可以将其抽象成求一个最长不上升子序列的问题。</p>
<p>以下是最长不上升子序列的一个算法分析：</p>
<ol>
<li>定义状态：我们可以使用一个数组<code>dp</code>来表示最长不上升子序列的长度。dp[i]表示以第i个元素为结尾的最长不上升子序列的长度。</li>
<li>初始化：将<code>dp</code>数组的所有元素初始化为1，因为每个单独的元素都可以视为一个长度为1的非递增子序列。</li>
<li>状态转移：对于每个位置i（从1到n-1），我们需要考虑所有在i之前的位置j（从0到i-1）。如果$nums[i] \le nums[j]$，则可以将元素i添加到以j为结尾的非递增子序列中，从而得到以i为结尾的非递增子序列。因此，我们可以更新$dp[i] &#x3D; max(dp[i], dp[j] + 1)$。</li>
<li>找到最大值：遍历整个dp数组，找到其中的最大值，即为最长不上升子序列的长度。</li>
</ol>
<p>算法中的一些细节：</p>
<ul>
<li>状态表示$f[i]$：<ul>
<li>集合：所有以第$i$个数结尾的不升子序列；</li>
<li>属性：$Max$</li>
</ul>
</li>
<li>状态计算：集合划分——$f[i]$<ul>
<li>划分依据：最后一个不同的点</li>
<li>以上一个数的位置进行划分</li>
<li>若$a_i \le a_j$，则$f[i]&#x3D;max \lbrace f[j]+1 \rbrace(j&#x3D;0,1,2,···i-1)$</li>
</ul>
</li>
</ul>
<h3 id="算法设计与代码实现-4"><a href="#算法设计与代码实现-4" class="headerlink" title="算法设计与代码实现"></a>算法设计与代码实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void FindMissileNum(int n)
&#123;
    int res &#x3D; 0, cnt &#x3D; 0;
    for (int i &#x3D; 0; i &lt; n; i ++ )
    &#123;
        f[i] &#x3D; 1;
        for (int j &#x3D; 0; j &lt; i; j ++ )
            if (h[i] &lt;&#x3D; h[j])
                f[i] &#x3D; max(f[i], f[j] + 1);
        res &#x3D; max(res, f[i]);
    &#125;
    cout&lt;&lt;res&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>算法演示：</p>
<p><img src="/imgs/suanfashiyan/11" alt="image-20230606220038621"></p>
<h3 id="算法讨论-1"><a href="#算法讨论-1" class="headerlink" title="算法讨论"></a>算法讨论</h3><p>算法的时间复杂度是$O(n^2)$，可以对遍历进行优化，进行树状数组优化或者二分优化，可以将时间复杂度优化到$O(n logn)$。</p>
<h2 id="皇宫看守"><a href="#皇宫看守" class="headerlink" title="皇宫看守"></a>皇宫看守</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>太平王世子事件后，陆小凤成了皇上特聘的御前一品侍卫。皇宫以午门为起点，直到后宫嫔妃们的寝宫，呈一棵树的形状；某些宫殿间可以互相望见。大内保卫森严，三步一岗，五步一哨，每个宫殿都要有人全天候看守，在不同的宫殿安排看守所需的费用不同。可是陆小凤手上的经费不足，无论如何也没法在每个宫殿都安置留守侍卫。</p>
<p>请你编程计算帮助陆小凤布置侍卫，在看守全部宫殿的前提下，使得花费的经费最少。</p>
<p>输入数据：数据表示一棵树，描述如下：</p>
<p>第1行 n，表示树中结点的数目。</p>
<p>第2行至第n+1行，每行描述每个宫殿结点信息，依次为：该宫殿结点标号i（0&lt;i&lt;&#x3D;n），在该宫殿安置侍卫所需的经费k，该边的儿子数m，接下来m个数，分别是这个节点的m个儿子的标号r1，r2，…，rm。</p>
<p>对于一个n（0 &lt; n &lt;&#x3D; 1500）个结点的树，结点标号在1到n之间，且标号不重复。</p>
<p>输出数据：输出到output.txt文件中。输出文件仅包含一个数，为所求的最少的经费。</p>
<p>如下示例：</p>
<p><img src="/imgs/suanfashiyan/10.png" alt="image-20230605174537453"></p>
<blockquote>
<p>sample input</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;6 
&gt;1 30 3 2 3 4
&gt;2 16 2 5 6
&gt;3 5 0
&gt;4 4 0
&gt;5 11 0
&gt;6 5 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>sample output</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;25<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<h3 id="问题分析与算法思想-2"><a href="#问题分析与算法思想-2" class="headerlink" title="问题分析与算法思想"></a>问题分析与算法思想</h3><p>这道题目是求权值最小的点支配集，要求图中<strong>每个点都能被观察到</strong>，因此有下列情况：</p>
<ul>
<li>父节点<strong>放置</strong>哨兵，所有子节点的哨兵都<strong>可放可不放</strong></li>
<li>父节点<strong>不设置</strong>哨兵，<strong>至少有一个</strong>子节点需要放置哨兵</li>
<li>父结点<strong>不设置</strong>哨兵，但其<strong>父节点</strong>设置哨兵观察，则子节点哨兵<strong>可放可不放</strong></li>
</ul>
<p>总结上述情况可以得到每个节点总共有三种情况：</p>
<ul>
<li>被父节点看守</li>
<li>被子节点看守</li>
<li>被节点自身看守</li>
</ul>
<p>将上述三种情况分别编为0，1，2</p>
<p>建立<strong>状态转移函数</strong>$f[i][3]$，其中：</p>
<ol>
<li>$f[i][0]$表示第i个节点由父节点看守下的最小代价</li>
<li>$f[i][1]$表示第i个节点由子节点看守下的最小代价</li>
<li>$f[i][2]$表示第i个节点由自身看守下的最小代价</li>
</ol>
<p>转移关系：</p>
<ol>
<li>$f[i][0] +&#x3D;min \lbrace f[j][1],f[j][2] \rbrace$</li>
<li>$f[i][1]&#x3D;min \lbrace f[i][1],sum-min(f[j][1],f[j][2])+f[j][2] \rbrace$</li>
<li>$f[i][2]+&#x3D;min \lbrace min(f[j][0],f[j][1]),f[j][2] \rbrace$</li>
</ol>
<p>从根节点开始DFS，然后遍历所有当前节点的所有子节点，进行递归。</p>
<h3 id="算法设计与代码实现-5"><a href="#算法设计与代码实现-5" class="headerlink" title="算法设计与代码实现"></a>算法设计与代码实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void dfs(int u)
&#123;
    f[u][2] &#x3D; w[u];

    for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];		&#x2F;&#x2F; 遍历所有子节点
        dfs(j);
        f[u][0] +&#x3D; min(f[j][1], f[j][2]);
        f[u][2] +&#x3D; min(min(f[j][0], f[j][1]), f[j][2]);
    &#125;

    f[u][1] &#x3D; 1e9;
    for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];
        &#x2F;&#x2F; f[u][0]为所有子节点的摆放方案代价之和, 减去 min(f[j][1], f[j][2]) 即是除了j节点其余节点的代价之和
        f[u][1] &#x3D; min(f[u][1], f[j][2] + f[u][0]- min(f[j][1], f[j][2]));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>算法演示：</p>
<p><img src="/imgs/suanfashiyan/12.png" alt="image-20230607004451288"></p>
<h3 id="算法讨论-2"><a href="#算法讨论-2" class="headerlink" title="算法讨论"></a>算法讨论</h3><p>本题是树形DP的应用，涉及到了父节点、子节点的邻接关系。算法遍历了树中的所有节点，时间复杂度是$O(n)$</p>
<h2 id="附录-1"><a href="#附录-1" class="headerlink" title="附录"></a>附录</h2><h3 id="计算矩阵连乘积源代码"><a href="#计算矩阵连乘积源代码" class="headerlink" title="计算矩阵连乘积源代码"></a>计算矩阵连乘积源代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
const int N &#x3D; 100;
int p[N];		&#x2F;&#x2F; 矩阵规模
int m[N][N];	&#x2F;&#x2F; 最优解
int s[N][N];

void MatrixChain(int n)
&#123;
	int r, i, j, k;
	for (i &#x3D; 0; i &lt;&#x3D; n; i++)				&#x2F;&#x2F; 初始化对角线
	&#123;
		m[i][i] &#x3D; 0;
	&#125;
	for (r &#x3D; 2; r &lt;&#x3D; n; r++)				&#x2F;&#x2F; r 个矩阵连乘
	&#123;
		for (i &#x3D; 1; i &lt;&#x3D; n - r + 1; i++)	&#x2F;&#x2F; 依次计算每r个矩阵相连乘的最优解情况
		&#123;
			j &#x3D; i + r - 1;
			m[i][j] &#x3D; m[i][i] + m[i + 1][j] + p[i - 1] * p[i] * p[j];
			s[i][j] &#x3D; i;					&#x2F;&#x2F; 分隔位置
			for (k &#x3D; i + 1; k &lt; j; k++)		 &#x2F;&#x2F; 变换分隔位置，逐一测试
			&#123;
				int t &#x3D; m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
				if (t &lt; m[i][j])			&#x2F;&#x2F; 如果变换后的位置更优，则替换原来的分隔方法
				&#123;
					m[i][j] &#x3D; t;
					s[i][j] &#x3D; k;
				&#125;
			&#125;
		&#125;
	&#125;
&#125;

void print(int i, int j)		&#x2F;&#x2F; 输出连乘顺序
&#123;
	if (i &#x3D;&#x3D; j)
	&#123;
		cout &lt;&lt; &quot;p[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;
		return;
	&#125;
	cout &lt;&lt; &quot;(&quot;;
	print(i, s[i][j]);
	print(s[i][j] + 1, j);
	cout &lt;&lt; &quot;)&quot;;
&#125;

int main()
&#123;
	int n;			&#x2F;&#x2F; n个矩阵
	cout &lt;&lt; &quot;请输入矩阵的数目：&quot;;
	cin &gt;&gt; n;
	int i, j;
	cout &lt;&lt; &quot;请输入各个矩阵的维度(相邻维度只需输入一个即可):&quot;;
	for (i &#x3D; 0; i &lt;&#x3D; n; i++)
	&#123;
		cin &gt;&gt; p[i];
	&#125;
	MatrixChain(n);
	cout &lt;&lt; &quot;最佳添加括号的方式为：&quot;;
	print(1, n);
	cout &lt;&lt; &quot;\n最小计算量的值为：&quot; &lt;&lt; m[1][n] &lt;&lt; endl;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="防卫导弹源代码"><a href="#防卫导弹源代码" class="headerlink" title="防卫导弹源代码"></a>防卫导弹源代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N &#x3D; 1000;

int h[N], f[N], q[N];		&#x2F;&#x2F; q数组记录开好的子序列结尾的数

void FindMissileNum(int n)
&#123;
    int res &#x3D; 0;
    for (int i &#x3D; 0; i &lt; n; i ++ )
    &#123;
        f[i] &#x3D; 1;
        for (int j &#x3D; 0; j &lt; i; j ++ )
            if (h[i] &lt;&#x3D; h[j])
                f[i] &#x3D; max(f[i], f[j] + 1);
        res &#x3D; max(res, f[i]);
    &#125;
    cout&lt;&lt;res&lt;&lt;endl;
&#125;

int main()
&#123;
    int n&#x3D;0;
    while (cin &gt;&gt; h[n])  n ++ ;	
    FindMissileNum(n);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="皇宫看守源代码"><a href="#皇宫看守源代码" class="headerlink" title="皇宫看守源代码"></a>皇宫看守源代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N &#x3D; 1510;

int n;
int h[N], w[N], e[N], ne[N], idx;
int f[N][3];
bool st[N];

void add(int a, int b)
&#123;
    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;
&#125;

void dfs(int u)
&#123;
    f[u][2] &#x3D; w[u];

    for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];		&#x2F;&#x2F; 遍历所有子节点
        dfs(j);
        f[u][0] +&#x3D; min(f[j][1], f[j][2]);
        f[u][2] +&#x3D; min(min(f[j][0], f[j][1]), f[j][2]);
    &#125;

    f[u][1] &#x3D; 1e9;
    for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];
        &#x2F;&#x2F; f[u][0]为所有子节点的摆放方案代价之和, 减去 min(f[j][1], f[j][2]) 即是除了j节点其余节点的代价之和
        f[u][1] &#x3D; min(f[u][1], f[j][2] + f[u][0]- min(f[j][1], f[j][2]));
    &#125;
&#125;

int main()
&#123;
    cin &gt;&gt; n;

    memset(h, -1, sizeof h);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )
    &#123;
        int id, cost, cnt;
        cin &gt;&gt; id &gt;&gt; cost &gt;&gt; cnt;
        w[id] &#x3D; cost;           &#x2F;&#x2F; 在点上记录花费
        while (cnt -- )
        &#123;
            int ver;
            cin &gt;&gt; ver;
            add(id, ver);
            st[ver] &#x3D; true;     &#x2F;&#x2F; 标记不是根节点
        &#125;
    &#125;

    int root &#x3D; 1;
    while (st[root]) root ++ ;  &#x2F;&#x2F; 找到根节点

    dfs(root);

    cout &lt;&lt; min(f[root][1], f[root][2]) &lt;&lt; endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="实验五：贪心算法和随机算法"><a href="#实验五：贪心算法和随机算法" class="headerlink" title="实验五：贪心算法和随机算法"></a>实验五：贪心算法和随机算法</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>有一个背包，背包容量是M&#x3D;150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody><tr>
<td>重量</td>
<td>35</td>
<td>30</td>
<td>60</td>
<td>50</td>
<td>40</td>
<td>10</td>
<td>25</td>
</tr>
<tr>
<td>价值</td>
<td>10</td>
<td>40</td>
<td>30</td>
<td>50</td>
<td>35</td>
<td>40</td>
<td>30</td>
</tr>
</tbody></table>
<h3 id="问题分析及算法思路-2"><a href="#问题分析及算法思路-2" class="headerlink" title="问题分析及算法思路"></a>问题分析及算法思路</h3><p>首先计算每种物品单位重量的价值，然后依照贪心策略，将<strong>尽可能多的单位重量价值最高的物品</strong>装入背包。将某种物品全部装入背包，背包内的物品总重量未超过C，则选择单位重量价值次高的物品并尽可能地多装入背包</p>
<p>使用贪心算法解决背包问题的思路如下：</p>
<ol>
<li><p>计算每个物品的单位价值：对于每个物品，计算其单位重量的价值（即价值除以重量），并将其降序排序。</p>
</li>
<li><p>初始化结果变量：创建一个结果变量，用于记录当前已选择的物品的总重量和总价值，初始值为0。</p>
</li>
<li><p>遍历物品：按照单位价值降序的顺序，依次遍历每个物品。</p>
</li>
<li><p>判断是否可以放入背包：对于当前遍历到的物品，判断是否可以放入背包中。如果当前物品的重量小于等于背包剩余容量，则将该物品放入背包，并将其重量和价值加到结果变量中。否则，跳过该物品。</p>
</li>
<li><p>返回结果：遍历完所有物品后，返回结果变量中记录的总重量和总价值。</p>
</li>
</ol>
<p>贪心算法的核心思想是每次选择当前最优的解决方案，即单位价值最高的物品放入背包。若某次不按照最大单位重量价值的物品进行放置，所得到的总价值一定不是最大的，则可以确定<strong>贪心解就是最优解</strong>，保证了贪心策略的正确性。</p>
<h3 id="算法设计与代码实现-6"><a href="#算法设计与代码实现-6" class="headerlink" title="算法设计与代码实现"></a>算法设计与代码实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Obj
&#123;
	int id;			&#x2F;&#x2F; 物品序号
	int w;			&#x2F;&#x2F; w为各物品的重量
	int v;			&#x2F;&#x2F; v为各物品的价值
	float unit;		&#x2F;&#x2F; 单位重量的价值
	bool operator&lt; (const Obj&amp; W)const
	&#123;
		return unit &lt; W.unit;
	&#125;
&#125;obj[N];

void FindMaxValue(int n, int m)
&#123;
	float value &#x3D; 0;
	sort(obj, obj + n);			&#x2F;&#x2F; 按照单位重量的价值对物品进行升序排序
	for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--)
	&#123;
		if (m - obj[i].w &gt;&#x3D; 0)				&#x2F;&#x2F; 存在剩余容量
		&#123;
			m -&#x3D; obj[i].w;					&#x2F;&#x2F; 去掉这部分的背包容量
			value +&#x3D; obj[i].v;				&#x2F;&#x2F; 加入这部分的价值
			cout &lt;&lt; &quot;装入整个第&quot; &lt;&lt; l[obj[i].id] &lt;&lt; &quot;个物品&quot; &lt;&lt; endl;
			if (m &#x3D;&#x3D; 0) break;
		&#125;
		else
		&#123;
			float ratio &#x3D; (float) m &#x2F; obj[i].w;
			cout &lt;&lt; &quot;装入&quot; &lt;&lt; ratio * 100 &lt;&lt; &quot;%第&quot; &lt;&lt; l[obj[i].id] &lt;&lt; &quot;个物品&quot; &lt;&lt; endl;
			value +&#x3D; ratio * obj[i].v;
			break;
		&#125;
	&#125;
	cout &lt;&lt; &quot;装入背包中的物品的总价值最大为&quot; &lt;&lt; value &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>算法演示：</p>
<p><img src="E:/xiazai/img/13.png" alt="image-20230607101048438"></p>
<h3 id="算法讨论-3"><a href="#算法讨论-3" class="headerlink" title="算法讨论"></a>算法讨论</h3><p>背包问题有多个不同的变体，其中一些常见的种类包括：</p>
<ol>
<li><p>0&#x2F;1背包问题（0&#x2F;1 Knapsack Problem）：在这种问题中，每个物品要么完全放入背包，要么完全不放入背包，不能进行分割。即每个物品只有两种选择：放入背包或不放入背包。</p>
</li>
<li><p>分数背包问题（Fractional Knapsack Problem）：这个问题允许物品被分割放入背包，即可以选择物品的一部分放入背包。每个物品有一个对应的重量和价值，目标是找到使总价值最大化的物品组合。</p>
</li>
<li><p>多重背包问题（Multiple Knapsack Problem）：多重背包问题与0&#x2F;1背包问题类似，但是每个物品有多个可用的实例（数量不限），可以选择将多个相同的物品放入背包中。</p>
</li>
<li><p>无限背包问题（Unbounded Knapsack Problem）：在这个问题中，每个物品有无限个可用实例，可以无限次地选择物品放入背包。</p>
</li>
<li><p>有限背包问题（Bounded Knapsack Problem）：这个问题介于0&#x2F;1背包问题和无限背包问题之间，每个物品有一定数量的可用实例，可以选择将物品放入背包的次数受限。</p>
</li>
<li><p>值约束背包问题（Knapsack Problem with Value Constraints）：在这个问题中，除了背包的容量限制外，还有对总价值的限制。目标是找到在满足总重量不超过背包容量的前提下，使总价值最大化的物品组合。</p>
</li>
</ol>
<p>通常来说，背包问题使用动态规划来解决，但是在本题中，物品可以分割成任意大小，故可以通过贪心策略，从最大单位重量价值的物品开始装入背包，是背包的纵价值最大，算法的时间复杂度主要消耗在排序上，使用了C++自带的sort排序，时间复杂度是$O(nlogn)$</p>
<h2 id="照亮的山景"><a href="#照亮的山景" class="headerlink" title="照亮的山景"></a>照亮的山景</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>在一片山的上空，高度为T处有N个处于不同位置的灯泡，如图。如果山的边界上某一点于某灯i的连线不经过山的其它点，我们称灯i可以照亮该点。开尽量少的灯，使得整个山景都被照亮。山被表示成有m个转折点的折线。</p>
<p>提示：照亮整个山景相当于照亮每一个转折点。</p>
<p><img src="E:/xiazai/img/1.gif" alt="img"></p>
<h3 id="问题分析及算法思路-3"><a href="#问题分析及算法思路-3" class="headerlink" title="问题分析及算法思路"></a>问题分析及算法思路</h3><p>一座山想要能被照亮，那么把这座山的两侧分别延长，与灯所在的高度相交于两个点，在这个区间内如果有一盏灯，就可以照亮这座山，如果没有，就必须在区间两侧各有一盏灯。那么我们把每座山的区间放到一个集合中，遍历所有的灯，每次贪心的寻找覆盖区间最多的灯，同时将已经照亮的山移出集合，标记灯为已使用，直到集合为空，所求的灯的数量就是最小的灯的数量。</p>
<p>这是在笔算时的解决方案，在计算时应该将其数据化。</p>
<p>首先找到<strong>每个顶点能被灯照到的左端点和右端点</strong>，可以采用遍历每个灯的做法，计算灯到顶点的直线的斜率 $k$ 和截距 $b$，然后计算该灯到顶点这段距离区间内<strong>所有顶点的横坐标投影到该直线的纵坐标</strong>是否小于<strong>该顶点的纵坐标</strong>：</p>
<ul>
<li>若成立，则认为该灯是无法照射到该顶点的，转而判断下一个灯；</li>
<li>若这段距离区间中所有顶点都存在以上条件，则认为该灯可以照射到该顶点，由该灯在顶点处的左右关系对顶点能被灯照到的左、右端点进行更新，并判断下一个灯。</li>
</ul>
<p>若判断的灯已经在该顶点的右侧且该灯无法照到该顶点，则无需继续判断后续灯是否能照射到该顶点。</p>
<p>经过上述过程，我们得到了每个顶点被哪些灯照到, 记录到$l$和$r$中，接着根据<strong>贪心策略</strong>获得开灯最少的数量：</p>
<p>依次计算区间内每个数出现的次数，找出区间中出现次数最多的数，由贪心策略可知，其是我们要找的灯的序号。点亮该灯后，将能照射到的顶点删除，然后对剩余顶点重复上述过程，直到顶点被全部照亮。</p>
<p>若贪心策略不是最优解，我们可以通过换部分灯的开关情况使其变为最优解，且不增加要亮灯的数目，则该贪心策略是正确的。</p>
<h3 id="算法设计与代码实现-7"><a href="#算法设计与代码实现-7" class="headerlink" title="算法设计与代码实现"></a>算法设计与代码实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Mou
&#123;
	int x;
	int y;
	int l;				&#x2F;&#x2F; l 为顶点能被灯照到的左端点
	int r;				&#x2F;&#x2F; r 为顶点能被灯照到的右端点
&#125;;
vector&lt;Mou&gt; mou;

void FindLightRegion(int m, int n, int t)
&#123;
	for (int i &#x3D; 0; i &lt; m; i++)			&#x2F;&#x2F; 遍历每个顶点
	&#123;
		for (int j &#x3D; 0; j &lt; n; j++)		&#x2F;&#x2F; 遍历每个灯
		&#123;
			bool flag &#x3D; true;

			if (l[j] !&#x3D; mou[i].x)
			&#123;
				&#x2F;&#x2F; 计算直线的斜率k和截距b
				float k &#x3D; (float)(t - mou[i].y) &#x2F; (l[j] - mou[i].x);
				float b &#x3D; t - k * l[j];
				int s &#x3D; i;
				while ((l[j] &lt; mou[i].x &amp;&amp; --s &amp;&amp; l[j] &lt; mou[s].x)
					|| (l[j] &gt; mou[i].x &amp;&amp; ++s &amp;&amp; l[j] &gt; mou[s].x))		&#x2F;&#x2F; 遍历灯到该点区间内的所有点
				&#123;
					if (k * mou[s].x + b &lt; mou[s].y)
					&#123;
						flag &#x3D; false;
						break;
					&#125;
				&#125;
			&#125;

			if (flag)
			&#123;
				if (mou[i].l &#x3D;&#x3D; -1)
				&#123;
					mou[i].l &#x3D; mou[i].r &#x3D; j;
				&#125;
				else
				&#123;
					mou[i].r++;
				&#125;
			&#125;
			else
			&#123;
				if (l[j] &gt; mou[i].x)
					break;				&#x2F;&#x2F; 无需继续遍历
			&#125;
		&#125;
	&#125;
&#125;

int FindMinLight(int m, int n, int t)
&#123;
	int res &#x3D; 0;
	FindLightRegion(m, n, t);	&#x2F;&#x2F; 得到每个顶点被哪些灯照到, 记录到 l 和 r 中
	while (mou.size() !&#x3D; 0)
	&#123;
		&#x2F;&#x2F; 统计区间每个数出现的次数
		int max &#x3D; 0, cishu &#x3D; 0;
		for (auto t : mou)
		&#123;
			map&lt;int, int&gt; nums;
			for (int i &#x3D; t.l; i &lt;&#x3D; t.r; i++)
			&#123;
				nums[i]++;
			&#125;
			&#x2F;&#x2F; 找出区间中出现次数最多的数
			for (auto num : nums)
			&#123;
				if (num.second &gt; cishu)
				&#123;
					max &#x3D; num.first;
					cishu &#x3D; num.second;
				&#125;
			&#125;
		&#125;
		&#x2F;&#x2F; 将出现次数最多的数设为当前需要的灯, 然后删除所有有关的顶点
		res++;
		for (auto it &#x3D; mou.begin(); it !&#x3D; mou.end();)
		&#123;
			if (it[0].l &lt;&#x3D; max &amp;&amp; it[0].r &gt;&#x3D; max)
				it &#x3D; mou.erase(it);
			else
				++it;
		&#125;
	&#125;
	return res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>算法演示：</p>
<p><img src="E:/xiazai/img/14.png" alt="image-20230607105633359"></p>
<h3 id="算法讨论-4"><a href="#算法讨论-4" class="headerlink" title="算法讨论"></a>算法讨论</h3><p>在本题的求解中通过求解每个顶点能被灯照到的左端点和右端点，然后运用贪心策略依次计算区间内每个数出现的次数，找出区间中出现次数最多的数，开相应序号的灯，从而求解开灯最少的数量，算法的时间复杂度是$O(m*n^2)$。</p>
<h2 id="搬桌子问题"><a href="#搬桌子问题" class="headerlink" title="搬桌子问题"></a>搬桌子问题</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>某教学大楼一层有n个教室，从左到右依次编号为1、2、…、n。现在要把一些课桌从某些教室搬到另外一些教室，每张桌子都是从编号较小的教室搬到编号较大的教室，每一趟，都是从左到右走，搬完一张课桌后，可以继续从当前位置或往右走搬另一张桌子。</p>
<p>输入数据：先输入n、m，然后紧接着m行输入这m张要搬课桌的起始教室和目标教室。</p>
<p>输出数据：最少需要跑几趟。</p>
<blockquote>
<p><strong>sample input</strong></p>
<pre class="line-numbers language-none"><code class="language-none">10  5
1  3
3  9
4  6
6  10
7  8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>sample output</strong></p>
<pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<h3 id="问题分析及算法实现"><a href="#问题分析及算法实现" class="headerlink" title="问题分析及算法实现"></a>问题分析及算法实现</h3><p>使用贪心策略，尽可能在一趟从左向右的移动中移动尽可能多的桌子。</p>
<p>将每一次移动桌子的起始教室和目的教室作为一个区间，对剩余卓子的区间进行比较</p>
<ul>
<li>如果存在剩余桌子的左界限大于上一张桌子的右界限，则可以进行下一张桌子的移动，进行上一步操作</li>
<li>反之，则结束这一趟移动，返回下一张桌子的左界限，重复上一个操作</li>
</ul>
<h3 id="算法设计与代码实现-8"><a href="#算法设计与代码实现-8" class="headerlink" title="算法设计与代码实现"></a>算法设计与代码实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Move &#123;
	int start;
	int end;
	bool use;
	bool operator&lt; (const Move&amp; W)const
	&#123;
		return start &lt; W.start;
	&#125;
&#125;mov[N];

int runnum(int n, int m)
&#123;
	sort(mov, mov + m);					&#x2F;&#x2F; 按照任务起始教室的编号排序
	int res &#x3D; 0, num &#x3D; 0, work &#x3D; 0;		 &#x2F;&#x2F; res为趟数
	while (work &lt; m)
	&#123;
		int num &#x3D; 0;		&#x2F;&#x2F; num为当前到的教室编号
		for (int i &#x3D; 0; i &lt; m; i++)
		&#123;
			if (mov[i].use &#x3D;&#x3D; false &amp;&amp; mov[i].start &gt;&#x3D; num)
			&#123;
				mov[i].use &#x3D; true;
				work++;
				num &#x3D; mov[i].end;
				if (num &#x3D;&#x3D; n) break;
			&#125;
		&#125;
		res++;
	&#125;
	return res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>算法演示：</p>
<p><img src="E:/xiazai/img/15.png" alt="image-20230607111611389"></p>
<h3 id="算法讨论-5"><a href="#算法讨论-5" class="headerlink" title="算法讨论"></a>算法讨论</h3><p>本算法需要进行遍历m张桌子的移动区间，消耗的时间复杂度$O(m^2)$，贪心的策略可以让单趟遍历到的教室属于任务范围内的比例最大，从而使得整个算法性能达到最优。</p>
<h2 id="附录-2"><a href="#附录-2" class="headerlink" title="附录"></a>附录</h2><h3 id="背包问题源代码"><a href="#背包问题源代码" class="headerlink" title="背包问题源代码"></a>背包问题源代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N &#x3D; 20;
char l[35] &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
struct Obj
&#123;
	int id;			&#x2F;&#x2F; 物品序号
	int w;			&#x2F;&#x2F; w为各物品的重量
	int v;			&#x2F;&#x2F; v为各物品的价值
	float unit;		&#x2F;&#x2F; 单位重量的价值
	bool operator&lt; (const Obj&amp; W)const
	&#123;
		return unit &lt; W.unit;
	&#125;
&#125;obj[N];

void FindMaxValue(int n, int m)
&#123;
	float value &#x3D; 0;
	sort(obj, obj + n);			&#x2F;&#x2F; 按照单位重量的价值对物品进行升序排序
	for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--)
	&#123;
		if (m - obj[i].w &gt;&#x3D; 0)				&#x2F;&#x2F; 存在剩余容量
		&#123;
			m -&#x3D; obj[i].w;					&#x2F;&#x2F; 去掉这部分的背包容量
			value +&#x3D; obj[i].v;				&#x2F;&#x2F; 加入这部分的价值
			cout &lt;&lt; &quot;装入整个第&quot; &lt;&lt; l[obj[i].id] &lt;&lt; &quot;个物品&quot; &lt;&lt; endl;
			if (m &#x3D;&#x3D; 0) break;
		&#125;
		else
		&#123;
			float ratio &#x3D; (float) m &#x2F; obj[i].w;
			cout &lt;&lt; &quot;装入&quot; &lt;&lt; ratio * 100 &lt;&lt; &quot;%第&quot; &lt;&lt; l[obj[i].id] &lt;&lt; &quot;个物品&quot; &lt;&lt; endl;
			value +&#x3D; ratio * obj[i].v;
			break;
		&#125;
	&#125;
	cout &lt;&lt; &quot;装入背包中的物品的总价值最大为&quot; &lt;&lt; value &lt;&lt; endl;
&#125;

int main()
&#123;
	int n, m;		&#x2F;&#x2F; n为物品数, m为背包容量
	cout &lt;&lt; &quot;请输入物品数和背包容量:&quot;;
	cin &gt;&gt; n &gt;&gt; m;
	cout &lt;&lt; &quot;请输入各个物品的重量和价值:\n&quot;;
	for (int i &#x3D; 0; i &lt; n; i++)
	&#123;
		cin &gt;&gt; obj[i].w &gt;&gt; obj[i].v;
		obj[i].id &#x3D; i;
		obj[i].unit &#x3D; (float) obj[i].v &#x2F; obj[i].w;
	&#125;
	FindMaxValue(n, m);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="照亮的山景源代码"><a href="#照亮的山景源代码" class="headerlink" title="照亮的山景源代码"></a>照亮的山景源代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
const int N &#x3D; 20;
int l[N], top[N];		&#x2F;&#x2F; top[N] 表示山峰的编号
struct Mou
&#123;
	int x;
	int y;
	int l;				&#x2F;&#x2F; l 为顶点能被灯照到的左端点
	int r;				&#x2F;&#x2F; r 为顶点能被灯照到的右端点
&#125;;
vector&lt;Mou&gt; mou;

void FindLightRegion(int m, int n, int t)
&#123;
	for (int i &#x3D; 0; i &lt; m; i++)			&#x2F;&#x2F; 遍历每个顶点
	&#123;
		for (int j &#x3D; 0; j &lt; n; j++)		&#x2F;&#x2F; 遍历每个灯
		&#123;
			bool flag &#x3D; true;

			if (l[j] !&#x3D; mou[i].x)
			&#123;
				&#x2F;&#x2F; 计算直线的斜率k和截距b
				float k &#x3D; (float)(t - mou[i].y) &#x2F; (l[j] - mou[i].x);
				float b &#x3D; t - k * l[j];
				int s &#x3D; i;
				while ((l[j] &lt; mou[i].x &amp;&amp; --s &amp;&amp; l[j] &lt; mou[s].x)
					|| (l[j] &gt; mou[i].x &amp;&amp; ++s &amp;&amp; l[j] &gt; mou[s].x))		&#x2F;&#x2F; 遍历灯到该点区间内的所有点
				&#123;
					if (k * mou[s].x + b &lt; mou[s].y)
					&#123;
						flag &#x3D; false;
						break;
					&#125;
				&#125;
			&#125;

			if (flag)
			&#123;
				if (mou[i].l &#x3D;&#x3D; -1)
				&#123;
					mou[i].l &#x3D; mou[i].r &#x3D; j;
				&#125;
				else
				&#123;
					mou[i].r++;
				&#125;
			&#125;
			else
			&#123;
				if (l[j] &gt; mou[i].x)
					break;				&#x2F;&#x2F; 无需继续遍历
			&#125;
		&#125;
	&#125;
&#125;

int FindMinLight(int m, int n, int t)
&#123;
	int res &#x3D; 0;
	FindLightRegion(m, n, t);	&#x2F;&#x2F; 得到每个顶点被哪些灯照到, 记录到 l 和 r 中
	while (mou.size() !&#x3D; 0)
	&#123;
		&#x2F;&#x2F; 统计区间每个数出现的次数
		int max &#x3D; 0, cishu &#x3D; 0;
		for (auto t : mou)
		&#123;
			map&lt;int, int&gt; nums;
			for (int i &#x3D; t.l; i &lt;&#x3D; t.r; i++)
			&#123;
				nums[i]++;
			&#125;
			&#x2F;&#x2F; 找出区间中出现次数最多的数
			for (auto num : nums)
			&#123;
				if (num.second &gt; cishu)
				&#123;
					max &#x3D; num.first;
					cishu &#x3D; num.second;
				&#125;
			&#125;
		&#125;
		&#x2F;&#x2F; 将出现次数最多的数设为当前需要的灯, 然后删除所有有关的顶点
		res++;
		for (auto it &#x3D; mou.begin(); it !&#x3D; mou.end();)
		&#123;
			if (it[0].l &lt;&#x3D; max &amp;&amp; it[0].r &gt;&#x3D; max)
				it &#x3D; mou.erase(it);
			else
				++it;
		&#125;
	&#125;
	return res;
&#125;

int main()
&#123;
	int m, n, t;			&#x2F;&#x2F; m为山棱转折点的个数, n为灯泡个数, t为灯泡的高度	
	cin &gt;&gt; m;
	for (int i &#x3D; 0; i &lt; m; i++)
	&#123;
		int x, y;
		cin &gt;&gt; x &gt;&gt; y;
		mou.push_back(&#123; x,y,-1,-1 &#125;);	&#x2F;&#x2F; 转折点的水平坐标和垂直海拔高度, 并预初始化区间
	&#125;
	cin &gt;&gt; n &gt;&gt; t;
	for (int i &#x3D; 0; i &lt; n; i++)
	&#123;
		cin &gt;&gt; l[i];
	&#125;
	cout &lt;&lt; &quot;开灯最少的数量是&quot; &lt;&lt; FindMinLight(m, n, t);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="搬桌子问题源代码"><a href="#搬桌子问题源代码" class="headerlink" title="搬桌子问题源代码"></a>搬桌子问题源代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

const int N &#x3D; 20;
struct Move &#123;
	int start;
	int end;
	bool use;
	bool operator&lt; (const Move&amp; W)const
	&#123;
		return start &lt; W.start;
	&#125;
&#125;mov[N];

int runnum(int n, int m)
&#123;
	sort(mov, mov + m);					&#x2F;&#x2F; 按照任务起始教室的编号排序
	int res &#x3D; 0, num &#x3D; 0, work &#x3D; 0;		&#x2F;&#x2F; res为趟数
	while (work &lt; m)
	&#123;
		int num &#x3D; 0;		&#x2F;&#x2F; num为当前到的教室编号
		for (int i &#x3D; 0; i &lt; m; i++)
		&#123;
			if (mov[i].use &#x3D;&#x3D; false &amp;&amp; mov[i].start &gt;&#x3D; num)
			&#123;
				mov[i].use &#x3D; true;
				work++;
				num &#x3D; mov[i].end;
				if (num &#x3D;&#x3D; n) break;
			&#125;
		&#125;
		res++;
	&#125;
	return res;
&#125;

int main()
&#123;
	int n, m;	&#x2F;&#x2F; n为教室数, m为要搬运的工作数
	cin &gt;&gt; n &gt;&gt; m;
	for (int i &#x3D; 0; i &lt; m; i++)
	&#123;
		cin &gt;&gt; mov[i].start &gt;&gt; mov[i].end;
		mov[i].use &#x3D; false;
	&#125;
	cout &lt;&lt; runnum(n, m) &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">J&Ocean</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jiang-wu-19.github.io/2023/07/22/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/">https://jiang-wu-19.github.io/2023/07/22/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">J&Ocean</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%AE%97%E6%B3%95/">
                                    <span class="chip bg-color">算法</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">请我喝杯奶茶吧~</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'Nv6Wx6PAYH30bfcx7u0eDWHy-gzGzoHsz',
        appKey: 'IhPcpC3fDP8Ro7eaPakG2vSt',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/07/22/%E8%AF%BE%E5%86%85%E5%AE%9E%E9%AA%8C%E7%9A%84index/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="课内实验的index">
                        
                        <span class="card-title">课内实验的index</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            本文摘录了J&Ocean的课内实验项目地址
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-07-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/index/" class="post-category">
                                    index
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AF%BE%E5%86%85%E5%AE%9E%E9%AA%8C/">
                        <span class="chip bg-color">课内实验</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/07/10/%E7%AE%97%E6%B3%95%E8%AF%BE%E5%A4%96%E6%80%9D%E8%80%83%E9%A2%98%E4%B8%83/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="算法课外思考题七">
                        
                        <span class="card-title">算法课外思考题七</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Voronoi图调研和二维矩阵的查找
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-07-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%80%9D%E8%80%83%E9%A2%98/" class="post-category">
                                    思考题
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                    <a href="/tags/Voronoi%E5%9B%BE/">
                        <span class="chip bg-color">Voronoi图</span>
                    </a>
                    
                    <a href="/tags/%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE/">
                        <span class="chip bg-color">二维矩阵查找</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: J&amp;Ocean BLOG<br />'
            + '文章作者: J&amp;Ocean<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">J&Ocean</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">213k</span>&nbsp;字
            
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2023";
                    var startMonth = "7";
                    var startDate = "2";
                    var startHour = "12";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/JIANG-Wu-19" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:wujiang0319@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=870027163" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 870027163" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/bei-wei-xiao-wu-32" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/bei-wei-xiao-wu-32" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
