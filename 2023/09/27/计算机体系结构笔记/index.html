<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="计算机体系结构笔记, J&amp;Ocean BLOG">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>计算机体系结构笔记 | J&amp;Ocean BLOG</title>
    <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>



   <style>
    body{
       background-image: url(https://github.com/JIANG-Wu-19/JIANG-Wu-19/blob/master/99759389_p0.png?raw=true);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.ico" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">J&amp;Ocean BLOG</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.ico" class="logo-img circle responsive-img">
        
        <div class="logo-name">J&amp;Ocean BLOG</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/23.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">计算机体系结构笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">
                                <span class="chip bg-color">计算机体系结构</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-09-27
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    49.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    180 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><strong>key</strong></p>
<ul>
<li>IO原理</li>
<li>存储层次</li>
<li>流水线并行计算的原理</li>
</ul>
<h2 id="计算机系统结构概念"><a href="#计算机系统结构概念" class="headerlink" title="计算机系统结构概念"></a>计算机系统结构概念</h2><h3 id="计算机系统结构"><a href="#计算机系统结构" class="headerlink" title="计算机系统结构"></a>计算机系统结构</h3><p>$系统效率&#x3D;min(器件速度)*min(系统结构效率)$</p>
<p>计算机体系结构是软件设计者与硬件设备设计者（VLSI）之间的中间层，是软件与硬件的接口（Interface）</p>
<p>程序员可见的计算系统的属性。包括：概念性的结构和功能行为（外特性）。不包括：数据流和控制流的组织、逻辑设计以及物理实现</p>
<h4 id="结构特性"><a href="#结构特性" class="headerlink" title="结构特性"></a>结构特性</h4><h5 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h5><p><img src="/imgs/ca/1.png" alt="image-20230919141845531"></p>
<p>分层带来的透明性</p>
<h4 id="系统结构内容"><a href="#系统结构内容" class="headerlink" title="系统结构内容"></a>系统结构内容</h4><p>指令系统、数据表示、寻址方式、寄存器组织、存储系统、终端机构、IO结构、及其工作状态定义切换、信息保护</p>
<h4 id="计算机体系结构的分类"><a href="#计算机体系结构的分类" class="headerlink" title="计算机体系结构的分类"></a>计算机体系结构的分类</h4><ol>
<li><p>按处理机性能分类</p>
<ul>
<li><p>按大小划分</p>
<p>巨型、大型、中型、小型、微型机</p>
</li>
<li><p>按用途划分</p>
<p><strong>科学计算、事务处理、实时控制、工作站、服务器、家用计算机</strong></p>
</li>
<li><p>按数据类型划分</p>
<p>定点计算机、浮点计算机、向量计算机、堆栈计算机</p>
</li>
<li><p>按处理机个数和种类划分</p>
<p>单处理机</p>
<p>并行处理机、多处理机、分布处理机</p>
<p>关联处理机</p>
<p>超标量处理机, 超流水线处理机, VLIW处理机</p>
<p>SMP(对称多处理机)、MPP(大规模并行处理机)、机群(Cluster)系统</p>
</li>
<li><p>使用器件划分</p>
<p>第一代：电子管(Valve)计算机</p>
<p>第二代：晶体管(Transistor)计算机</p>
<p>第三代：集成电路(LSI)计算机</p>
<p>第四代：大规模集成电路(VLSI)计算机</p>
<p>第五代：智能计算机</p>
</li>
</ul>
</li>
<li><p>按“流”分类：Flynn分类法</p>
<ul>
<li><p>概念</p>
<p>指令流（Instruction Stream）：机器执行的<strong>指令序列</strong>；</p>
<p>数据流（Data stream）：由指令处理的<strong>数据序列</strong>；</p>
<p>多倍性（Multiplicity）：在系统最窄的部件上，处于<strong>同一执行阶段</strong>的指令和数据的最大可能个数。</p>
</li>
<li><p>基本模块</p>
<p>MM（Memory Module）：内存模块</p>
<p>PU（Process Unit）：处理单元</p>
<p>CU（Control Unit）：控制单元</p>
</li>
<li><p>指令流和数据流的个数</p>
<ul>
<li><p>单指令流单数据流SISD</p>
<p><img src="/imgs/ca/2.png" alt="image-20230919151309716"></p>
</li>
<li><p>单指令流多数据流SIMD</p>
<p><img src="/imgs/ca/3.png" alt="1695107777668"></p>
</li>
<li><p>多指令流单数据流MISD</p>
<p><img src="/imgs/ca/4.png" alt="1695107968627"></p>
<ul>
<li>没有MISD计算机的原因之一：通常PU用于处理简单数据，一般没有多个简单数据需要一组相同处理的需求，<strong>没有存在的需求基础</strong></li>
<li>没有MISD计算机的原因之二：如果把PU用于处理复杂数据（向量、矩阵等），一方面<strong>MISD已经变成了MIMD</strong>，另一方面，相对于<strong>SIMD性能价格比较低</strong></li>
<li>没有MISD计算机的原因之三：适合MISD实现的应用都可以使用其它结构实现，没有存在的必然性，<strong>因为任何复杂数据都可以分解为简单数据</strong>。</li>
</ul>
</li>
<li><p>多指令流多数据流MIMD</p>
<p><img src="/imgs/ca/5.png" alt="1695108484531"></p>
</li>
</ul>
</li>
<li><p>主要缺点</p>
<ul>
<li>分类太粗</li>
<li>把两个不同等级的功能并列对待</li>
<li>没有非冯计算机的分类</li>
</ul>
</li>
</ul>
</li>
<li><p>库克分类法</p>
<p>按控制流和执行流分类</p>
<ul>
<li><p>单指令流单执行流SISE</p>
</li>
<li><p>单指令流多执行流SIME</p>
<p>多功能部件处理机、相联处理机、向量处理机、流水线处理机、超流水线处理机、超标量处理机、SIMD并行处理机</p>
</li>
<li><p>多指令流单执行流MISE</p>
</li>
<li><p>多指令流多执行流MIME</p>
</li>
</ul>
<p>缺点：</p>
<p>有些系统如分布处理机等，没有总控制器</p>
<p>分类级别太低，没有处理机级和机器级</p>
<p>分类太粗，如SIME中包含了多种处理机</p>
</li>
<li><p>最大并行度分类：冯氏分类法</p>
<p>最大并行度$P_m$是指一个系统在单位时间内能够处理的最多的二进制位数，显然这是一个完全由计算机硬件结构决定的参数</p>
<p><strong>最大并行度的数值越大越好</strong></p>
<p><img src="/imgs/ca/6.png" alt="image-20230926143105299"></p>
<ul>
<li>字串位串WSBS：n&#x3D;1，m&#x3D;1 全串行</li>
<li>字并位串WPBS：n&gt;1，m&#x3D;1 并行单处理机</li>
<li>字串位并WSBP：n&#x3D;1，m&gt;1 每处理机只一位，但有多个字处理机并行运用</li>
<li>字并位并WPBP：n&gt;1，m&gt;1</li>
</ul>
<p>如果在一个时钟周期$\Delta t_i$内实际处理的二进制位数为$P_i$，那么在$T$个时钟周期内的平均并行度$P_a$ 就为：<br>$$<br>P_a&#x3D;(\sum_{i&#x3D;1}^T P_i)&#x2F;T<br>$$<br>把平均并行度与最大并行度之比称为平均利用率，用$\mu$表示为：<br>$$<br>\mu&#x3D;P_a&#x2F;P_m&#x3D; \frac{\sum_{i&#x3D;1}^TP_i}{T \cdot P_m}<br>$$</p>
</li>
<li><p>按“并行集”和“流水线”分类：$Handler$表示法</p>
<p>根据可并行和流水处理的程度，将硬件分成三个层次：</p>
<ul>
<li>程序控制部件（PCU）的个数$k$</li>
<li>算术逻辑部件（ALU）或处理部件（PE）的个数$k$</li>
<li>每个算逻部件包含基本逻辑线路（ECL）的套数$w$</li>
</ul>
<p>每一个计算机系统都可以用上述三个参数表示其结构特征，即：<br>$$<br>t(系统型号)&#x3D;(k,d,w)<br>$$<br>更细致的表达：<br>$$<br>t(系统型号)&#x3D;(k \times k’,d \times d’,w \times w’)<br>$$<br>$k’$表示宏流水线中程序控制部件的个数；</p>
<p>$d’$表示指令流水线中算术逻辑部件的个数；</p>
<p>$w’$表示操作流水线中基本逻辑线路的套数</p>
</li>
<li><p>按控制方式分类</p>
<p>控制流方式：顺序执行（冯·诺伊曼型）</p>
<p>数据流方式：操作数到位即可运算，无序执行</p>
<p>规约方式：驱动方式与数据流相反</p>
<p>匹配方式：非数值型应用，主要对象为符号</p>
</li>
<li><p>按系统结构风格分类</p>
<p>面向堆栈型、面向寄存器型、面向对象型</p>
</li>
</ol>
<h3 id="系统结构设计"><a href="#系统结构设计" class="headerlink" title="系统结构设计"></a>系统结构设计</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><ol>
<li><p>由上向下方法</p>
<p>适合于专用机的设计，从应用到实现级，周期几年。</p>
<p>缺点：当应用对象或范围变化时，效率急剧下降。</p>
<p>原因：软、硬件脱节，不能利用最新的软件技术。</p>
</li>
<li><p>由下向上方法</p>
<p>前提：硬件不能改变。</p>
<p>缺点：易形成软、硬脱节，软件不能获得最新硬件的支持，结果软件繁杂、效率低。</p>
</li>
<li><p>从中间开始</p>
<p>从软、硬件交界面开始设计。</p>
<p>要求首先进行软、硬件功能分配，同时考虑硬件能为软件提供什么支持。</p>
<p>优点：避免软、硬件脱节，设计周期短，有利于优化设计。</p>
<p> 缺点：对设计人员要求较高，要求具有有效的软件设计环境和开发工具，便于分析、评价和设计。</p>
</li>
</ol>
<h4 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h4><ol>
<li>需求分析</li>
<li>需求说明</li>
<li>概念性设计</li>
<li>具体设计</li>
<li>反复进行优化设计及评价</li>
</ol>
<h4 id="量化规则"><a href="#量化规则" class="headerlink" title="量化规则"></a>量化规则</h4><ul>
<li><p>抽象以简化设计</p>
</li>
<li><p>冗余redundancy以增强独立性</p>
</li>
<li><p>并行</p>
<ul>
<li><p>pipelining</p>
</li>
<li><p>powerful instructions</p>
<ul>
<li><p>MD-technique</p>
<p>multiple data operands per operation</p>
</li>
<li><p>MO-technique</p>
<p>multiple operations per instruction</p>
</li>
</ul>
</li>
<li><p>Multiple instruction issue</p>
<ul>
<li>single instruction-program stream</li>
<li>multiple streams</li>
</ul>
</li>
</ul>
</li>
<li><p>关注common case</p>
<ul>
<li><p>Favor the frequent case over the infrequent case</p>
</li>
<li><p>Frequent case is often simpler and can be done faster than the infrequent case</p>
</li>
<li><p>Amdahl’s Law</p>
<p>$Speedup(E)&#x3D;\frac{Execution_Time_Without_enhancement}{Execution_Time_With_enhancement}$</p>
<p>$Speedup_{overall}&#x3D;\frac{ExTime_{old}}{ExTime_{new}}&#x3D;\frac{1}{(1-Fraction_{enhanced})+\frac{Fraction_{enhanced}}{Speedup_{enhanced}}}$</p>
<ul>
<li>减小CPI×</li>
<li>将CPU的流水线条数增加为n条×</li>
<li>设计专门的多媒体指令及处理硬件</li>
</ul>
</li>
<li><p>Gustafson’s law</p>
<p>$Speedup&#x3D;P-f_{seq}(P-1)$</p>
</li>
</ul>
</li>
<li><p>局部性原理</p>
<ul>
<li>temporal locality</li>
<li>spatial locality</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cseweb.ucsd.edu/classes/sp14/cse141-a/Slides/02_performance_annotated-0417.pdf">Performance Equation</a></p>
<ul>
<li>$CPU\ Time&#x3D;\frac{CPU\ clock\ cycles\ for\ a\ program}{Clock\ rate}$</li>
<li>$CPI&#x3D;\frac{CPU\ clock\ cycles\ for\ a\ program}{IC}$</li>
<li>$Instruction\ Count:IC$</li>
<li>$CPU&#x3D;\frac{IC \times CPI}{Clockrate}$</li>
</ul>
</li>
</ul>
<p>存储层级结构</p>
<p><img src="/imgs/ca/7.png" alt="image-20231017144327723"></p>
<h4 id="软硬件取舍原则"><a href="#软硬件取舍原则" class="headerlink" title="软硬件取舍原则"></a>软硬件取舍原则</h4><ol>
<li>现有软、硬件条件下，选择能够提高系统性能&#x2F;价格的方法；</li>
<li>考虑到准备采用和可能采用的组成技术，所选方法能否尽量不限制组成和实现技术</li>
<li>不能仅从“硬”的角度去考虑如何便于应用组成技术的成果和发挥器件技术的进展，还应考虑所选方法能否从“软”的角度为编译和操作系统的实现，以至高级语言程序的设计提供更多更好的硬件支持</li>
</ol>
<h3 id="计算机性能标准"><a href="#计算机性能标准" class="headerlink" title="计算机性能标准"></a>计算机性能标准</h3><p>计算机性能：正确性、可靠性和工作能力</p>
<p>评价性能：仅指工作能力</p>
<p>工作能力指标：</p>
<ul>
<li>处理能力—单位时间内能处理的信息量(吞吐率)</li>
<li>响应能力—响应时间、周转时间、排队时间</li>
<li>利用率—T时间内，某部分被使用时间t与T的比值</li>
</ul>
<h4 id="CPU能力"><a href="#CPU能力" class="headerlink" title="CPU能力"></a>CPU能力</h4><h5 id="硬件连接能力"><a href="#硬件连接能力" class="headerlink" title="硬件连接能力"></a>硬件连接能力</h5><p>速度指标</p>
<p>CPU通过在引脚上设置数据、地址和控制总线实现与外部电路的连接，这种能力的强弱常用数据总线带宽，即单位时间内传输的数据量来表示。这是一个速度指标</p>
<p>地址总线的宽度可以衡量CPU支持的容量指标。<br>控制总线的数量、性质可以衡量CPU的功能、可靠性、可扩展性等指标，但表达可能比较复杂。</p>
<ol>
<li>数据带宽<ul>
<li>CPU引脚中数据总线的宽度乘以总线传输速率得到数据带宽。（注意，由CPU、系统总线共同决定）</li>
<li>例如，数据总线的传输速率为266 MHz，总线的宽度为32位（4字节），那么该数据总线的带宽就达到2.1GB&#x2F;s（266MHz×4B）。显然，数据总线带宽越宽，表明该处理机对其他部件的读写速度越快。    </li>
<li>体系结构改善：提高总线传输速率、增加总线宽度，相应的增加成本。</li>
</ul>
</li>
<li>CPU与Cache连接方式<ul>
<li>随着处理机工作速率的提高，采用Cache（高速缓冲存储器）是提高CPU工作效率的必备措施，而与Cache的连接方式也成为考察处理机连接能力的又一个重要方面</li>
<li>CPU在片内连接Cache比在片外连接Cache具有更高的速度指标</li>
<li>CPU与Cache之间的数据通道越多，则速度越快。</li>
<li>一级CACHE集成在CPU同一芯片内</li>
<li>二级一般也在CPU同一芯片内(全速CACHE),有的在芯片外,但与CPU 在同一专用板上且有专门通道与CPU相连。</li>
<li>有的CPU还提供专门通道连结第三级CACHE</li>
<li>体系结构改善：为CACHE设计足够宽的通道、尽量把Cache设计在CPU芯片内，但是这会相应增加制造难度和成本</li>
</ul>
</li>
</ol>
<h5 id="管理能力"><a href="#管理能力" class="headerlink" title="管理能力"></a>管理能力</h5><p>可靠性、速度、容量、可扩展性、性能价格比</p>
<ul>
<li>可靠性：多道作业管理</li>
<li>速度：Cache寻址，中断管理</li>
<li>容量：虚拟存储器寻址</li>
<li>可扩展性：中断管理</li>
<li>性能价格比：操作系统中某些软件功能放在硬件中实现，提高系统整体的性能价格比。</li>
</ul>
<p><strong>CPU PE</strong></p>
<p>假定通过许多程序的统计，得知第$i$类指令的使用概率为$P_i$，而执行该类指令所需的时钟周期数为$CPI_i$，而全部指令的类别数为$n$，该处理机的统计平均$CPI$就为<br>$$<br>CPI&#x3D;\sum_{i&#x3D;1}^n(CPI_i \times P_i)<br>$$<br>减小平均CPI,减小频繁使用指令的CPI,大概率事件优先原则的应用</p>
<p>系统响应能力能反映计算机系统的软、硬件性能</p>
<p>不能仅用计算机主频衡量系统性能</p>
<h4 id="系统运行速度-x2F-处理能力"><a href="#系统运行速度-x2F-处理能力" class="headerlink" title="系统运行速度&#x2F;处理能力"></a>系统运行速度&#x2F;处理能力</h4><h5 id="MIPS-MFLOPS"><a href="#MIPS-MFLOPS" class="headerlink" title="MIPS\MFLOPS"></a>MIPS\MFLOPS</h5><p>以计算机系统整体作为一个被评估的模块，CPI显然是不合适的</p>
<p>用MIPS和MFLOPS反映系统（CPU）吞吐率。<br>$$<br>MIPS&#x3D;\frac{IC}{Time<em>10^6}&#x3D;\frac{Frequency}{CPI</em>10^6}<br>$$</p>
<p>$$<br>MFLOPS&#x3D;\frac{FP\ Operations}{Time*10^6}<br>$$</p>
<p>$$<br>1MFLOPS \approx3MIPS<br>$$</p>
<h5 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h5><p>基准测试程序通常用高级语言编写，由各系统自带的编译程序编译成适合在本机中运行的机器码，记下各程序运行所花费的时间，然后按一定的规则计算其执行时间。</p>
<ol>
<li><p>spec<br>$$<br>SPEC&#x3D;\sqrt[n]{\prod_{i&#x3D;1}^n SPEC_i}<br>$$</p>
</li>
<li><p>icomp</p>
</li>
</ol>
<h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>虽不直接表示系统性能指标，但与前两种指标有密切关系。对系统性能或结构改进与优化起着至关重要的作用</p>
<p>利用阿姆达尔定律和程序局部性原理改进来提高部件利用率</p>
<h4 id="性能评价技术"><a href="#性能评价技术" class="headerlink" title="性能评价技术"></a>性能评价技术</h4><ol>
<li><p>分析技术</p>
<p>近似求解算法：聚合法、均值分析法、扩散法</p>
</li>
<li><p>模拟技术</p>
<p>设计模拟实验，依照评价目标，选择与目标有关因素，得出实验值，再进行统计、分析</p>
</li>
<li><p>测量技术</p>
</li>
</ol>
<h4 id="多机系统性能评价"><a href="#多机系统性能评价" class="headerlink" title="多机系统性能评价"></a>多机系统性能评价</h4><p>除采用单机的评价方法外，还需测试系统的性能加速比和性能可伸缩性值</p>
<ol>
<li><p>性能加速比</p>
<p>$S(p,n)&#x3D;\frac{T(p,1)}{T(p,n)+h(p,n)}$</p>
</li>
<li><p>性能可伸缩性</p>
</li>
</ol>
<h4 id="计算机成本与价格"><a href="#计算机成本与价格" class="headerlink" title="计算机成本与价格"></a>计算机成本与价格</h4><h3 id="计算机系统结构发展"><a href="#计算机系统结构发展" class="headerlink" title="计算机系统结构发展"></a>计算机系统结构发展</h3><h4 id="冯诺依曼机系统结构演变"><a href="#冯诺依曼机系统结构演变" class="headerlink" title="冯诺依曼机系统结构演变"></a>冯诺依曼机系统结构演变</h4><p>运算器、控制器、存储器、IO设备</p>
<p><img src="/imgs/ca/8.png" alt="image-20231017165717270"></p>
<p><img src="/imgs/ca/9.png" alt="image-20231017170105396"></p>
<h4 id="软件、应用和器件对系统结构的影响"><a href="#软件、应用和器件对系统结构的影响" class="headerlink" title="软件、应用和器件对系统结构的影响"></a>软件、应用和器件对系统结构的影响</h4><h5 id="软件对系统结构发展的影响"><a href="#软件对系统结构发展的影响" class="headerlink" title="软件对系统结构发展的影响"></a>软件对系统结构发展的影响</h5><p>主要体现在软件可移植性问题</p>
<ol>
<li>统一高级语言方法</li>
<li>系列机思想</li>
</ol>
<p><img src="/imgs/ca/10.png" alt="image-20231017171417839"></p>
<p>软件兼容种类：向上&#x2F;下、向前&#x2F;后兼容</p>
<p>系列机要求：保证向后兼容，力争向上兼容</p>
<ol start="3">
<li>模拟与仿真</li>
<li>目标代码的并行编译技术</li>
</ol>
<p>软件是促使计算机系统结构发展最重要的因素。</p>
<h5 id="应用对系统结构发展的影响"><a href="#应用对系统结构发展的影响" class="headerlink" title="应用对系统结构发展的影响"></a>应用对系统结构发展的影响</h5><ul>
<li>应用要求：高速度、大容量、大吞吐率</li>
<li>应用场合：大、中、小、巨、微型机</li>
</ul>
<h5 id="器件对系统结构发展的影响"><a href="#器件对系统结构发展的影响" class="headerlink" title="器件对系统结构发展的影响"></a>器件对系统结构发展的影响</h5><p>器件的性能、使用方法改变、影响系统结构及组成方法</p>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p>An Instruction Set provides a functional description of a processor</p>
<ul>
<li>a detailed list of the <strong>instructions</strong> that the processor is capable of processing</li>
<li>a description of the types&#x2F;locations&#x2F;access methods for <strong>operands</strong></li>
</ul>
<h3 id="Data-Representation"><a href="#Data-Representation" class="headerlink" title="Data Representation"></a>Data Representation</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>定义：具有一组值的集合，且定义了作用于该集合的操作集。</p>
<p>目的：防止不同类型数据间的误操作。</p>
<p>分类：基本类型、结构类型。</p>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>内容：二进制位、二进制位串、整数、十进制数、浮点数、字符、布尔数等</p>
<p>所有系统结构都支持基本数据类型</p>
<h4 id="结构数据类型"><a href="#结构数据类型" class="headerlink" title="结构数据类型"></a>结构数据类型</h4><p>定义：由一组相互有关的数据元素复合而成的数据类型。</p>
<p>分类：系统数据类型、用户自定义数据类型。</p>
<p>内容：数组、字符串、向量、堆栈、队列、记录等</p>
<p><img src="/imgs/ca/11.png" alt="image-20231017191946396"></p>
<h4 id="引入数据表示的规则"><a href="#引入数据表示的规则" class="headerlink" title="引入数据表示的规则"></a>引入数据表示的规则</h4><ol>
<li>whether the systematic effectiveness is improved</li>
<li>whether that data representation commonality and utilization ratio is enough</li>
</ol>
<h4 id="Self-defining-data-representation"><a href="#Self-defining-data-representation" class="headerlink" title="Self-defining data representation"></a>Self-defining data representation</h4><p>The <strong>feasible quality analysis</strong>:</p>
<ul>
<li><p>whether the dedicated space improves </p>
<p>通常面积B&gt;面积A</p>
<p><img src="/imgs/ca/13.png" alt="image-20231017192828475"></p>
</li>
<li><p>whether realization time to decrease </p>
</li>
<li><p>commonality and the utilization ratio</p>
</li>
</ul>
<ol>
<li><p>Data representation including tag</p>
<p><img src="/imgs/ca/12.png" alt="image-20231017192717658"></p>
<p>与数据相连，共存于同一存储单元中，是数据的一部分</p>
<p><strong>advantages</strong></p>
<ul>
<li>Simplify the instruction set</li>
<li>chieve consistency check and the data form transformation through hardware</li>
<li>Simplify programming，Semantic disparity lessening between human and the machinery</li>
<li>Simplify compiler，The semantic disparity between high-quality language together with the machine language cuts down enormously</li>
<li>Support data base system，software can be applicable to much kinds of data type with no modification</li>
<li>Convenient software debugging，every data includes a trap bit</li>
</ul>
<p><strong>defects</strong></p>
<ul>
<li>The length of data and instruction is probably not the same </li>
<li>The execution speed of instruction decreases 。The design time 、Compilation time and debugging time of program be shortened.</li>
<li>Increasing The hardware complexity</li>
</ul>
</li>
<li><p>Data descriptor representation</p>
<p>与数据分开，增加一级寻址，是程序的一部分</p>
<p><img src="/imgs/ca/14.png" alt="image-20231024143015233"></p>
<p><img src="/imgs/ca/15.png" alt="image-20231024143500388"></p>
</li>
</ol>
<h3 id="Instruction-set"><a href="#Instruction-set" class="headerlink" title="Instruction set"></a>Instruction set</h3><ul>
<li>The complete collection of instructions that are understood by a CPU</li>
<li>Machine Code</li>
<li>Binary</li>
<li>Usually represented by assembly codes</li>
</ul>
<h4 id="Elements-of-an-Instruction"><a href="#Elements-of-an-Instruction" class="headerlink" title="Elements of an Instruction"></a>Elements of an Instruction</h4><ul>
<li>Operation code (Op code)<ul>
<li>Do this</li>
</ul>
</li>
<li>Source Operand reference<ul>
<li>To this</li>
</ul>
</li>
<li>Result Operand reference<ul>
<li>Put the answer here</li>
</ul>
</li>
<li>Next Instruction Reference<ul>
<li>When you have done that, do this…</li>
</ul>
</li>
</ul>
<h4 id="Instruction-Cycle-State-Diagram"><a href="#Instruction-Cycle-State-Diagram" class="headerlink" title="Instruction Cycle State Diagram"></a>Instruction Cycle State Diagram</h4><p><img src="/imgs/ca/16.png" alt="image-20231024144342294"></p>
<h4 id="Instruction-Representation"><a href="#Instruction-Representation" class="headerlink" title="Instruction Representation"></a>Instruction Representation</h4><h5 id="Instruction-Types"><a href="#Instruction-Types" class="headerlink" title="Instruction Types"></a>Instruction Types</h5><ul>
<li>Data processing</li>
<li>Data storage (main memory)</li>
<li>Data movement (I&#x2F;O)</li>
<li>Program flow control</li>
</ul>
<h5 id="Number-of-Addresses"><a href="#Number-of-Addresses" class="headerlink" title="Number of Addresses"></a>Number of Addresses</h5><ul>
<li>3 addresses<ul>
<li>op1,op2,result</li>
<li>c&#x3D;a+b</li>
</ul>
</li>
<li>2 addresses<ul>
<li>op1,op2</li>
<li>a&#x3D;a+b</li>
</ul>
</li>
<li>1 address<ul>
<li>Implicit second address</li>
</ul>
</li>
<li>0 address<ul>
<li>use a stack</li>
<li>push a</li>
<li>push b</li>
<li>add</li>
<li>pop c</li>
</ul>
</li>
</ul>
<h5 id="Design-Decisions"><a href="#Design-Decisions" class="headerlink" title="Design Decisions"></a>Design Decisions</h5><ul>
<li>Operation decisions<ul>
<li>number of ops</li>
<li>op’s functions</li>
<li>complexity</li>
</ul>
</li>
<li>Data types</li>
<li>Instruction formats<ul>
<li>Length of op code field</li>
<li>Number of addresses</li>
</ul>
</li>
<li>Registers</li>
<li>Addressing modes</li>
<li>RISC vs CISC</li>
</ul>
<h5 id="Simple-Instruction-Format"><a href="#Simple-Instruction-Format" class="headerlink" title="Simple Instruction Format"></a>Simple Instruction Format</h5><p><img src="/imgs/ca/17.png" alt="image-20231024145657590"></p>
<h5 id="Operands类型、表示和大小"><a href="#Operands类型、表示和大小" class="headerlink" title="Operands类型、表示和大小"></a>Operands类型、表示和大小</h5><p><strong>常用操作数类型</strong></p>
<ul>
<li>ASCII character &#x3D; 1 byte (64-bit register can store 8 characters</li>
<li>Unicode character or Short integer &#x3D; 2 bytes &#x3D; 16 bits （half word) </li>
<li>Integer &#x3D; 4 bytes &#x3D; 32 bits (word size on many RISC Processors)</li>
<li>Single-precision float &#x3D; 4 bytes &#x3D; 32 bits (word size)</li>
<li>Long integer &#x3D; 8 bytes &#x3D; 64 bits (double word)</li>
<li>Double-precision float &#x3D; 8 bytes &#x3D; 64 bits (double word)</li>
<li>Extended-precision float &#x3D; 10 bytes &#x3D; 80 bits (Intel architecture)</li>
<li>Quad-precision float &#x3D; 16 bytes &#x3D; 128 bits</li>
</ul>
<h5 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h5><p><img src="/imgs/ca/18.png" alt="image-20231024150929836"></p>
<p>重要的寻址方式：</p>
<ul>
<li>偏移寻址</li>
<li>立即数寻址方式</li>
<li>寄存器间址方式</li>
</ul>
<p>偏移字段的大小应该在12-16bits，满足75%-99%需求</p>
<p>立即数字段的大小应该在8-16bits，满足50%-80%需求</p>
<h5 id="Types-of-Operation"><a href="#Types-of-Operation" class="headerlink" title="Types of Operation"></a>Types of Operation</h5><ul>
<li>Data Transfer</li>
<li>Arithmetic</li>
<li>Logical</li>
<li>Conversion</li>
<li>I&#x2F;O</li>
<li>System Control</li>
<li>Transfer of Control</li>
</ul>
<h5 id="指令集结构分类"><a href="#指令集结构分类" class="headerlink" title="指令集结构分类"></a>指令集结构分类</h5><h6 id="分类准则"><a href="#分类准则" class="headerlink" title="分类准则"></a>分类准则</h6><ol>
<li>根据CPU中操作数的存储方法分类；（主要分类准则）</li>
<li>根据指令中显式操作数个数分类；</li>
<li>根据操作数能否放在存储器中分类</li>
</ol>
<p>指令集划分成堆栈、累加器、寄存器型三类。目前，指令系统则为三种中某些类型的混合型</p>
<h3 id="Addressing-mode"><a href="#Addressing-mode" class="headerlink" title="Addressing mode"></a>Addressing mode</h3><p>重点是寻址方式的选择方法</p>
<p>80年以来几乎所有机器的存储器都是<strong>按字节编址</strong></p>
<p>不同体系结构对字的定义是不同的</p>
<h4 id="尾端问题"><a href="#尾端问题" class="headerlink" title="尾端问题"></a>尾端问题</h4><ul>
<li>little endian</li>
<li>big endian</li>
</ul>
<p><img src="/imgs/ca/19.png" alt="image-20231031141034197"></p>
<h4 id="对齐问题"><a href="#对齐问题" class="headerlink" title="对齐问题"></a>对齐问题</h4><ul>
<li>对s字节的对象访问地址为A，如果A mod s &#x3D;0 称为边界对齐。</li>
<li>边界对齐的原因是存储器本身读写的要求，存储器本身读写通常就是边界对齐的，对于不是边界对齐的对象的访问可能要导致存储器的两次访问，然后再拼接出所需要的数。（或发生异常）</li>
</ul>
<h4 id="编址方式"><a href="#编址方式" class="headerlink" title="编址方式"></a>编址方式</h4><h5 id="编址单位"><a href="#编址单位" class="headerlink" title="编址单位"></a>编址单位</h5><p>常见编址单位有：word、byte、bit、block</p>
<p>一般：字节编址，字访问</p>
<p>部分机器：位编址，字访问</p>
<p>辅助存储器：块编址</p>
<h5 id="零地址空间"><a href="#零地址空间" class="headerlink" title="零地址空间"></a>零地址空间</h5><ul>
<li>三个零地址空间：通用寄存器、主存储器和输入输出设备均独立编址</li>
<li>两个零地址空间：主存储器与输入输出设备统一编址</li>
<li>一个零地址空间：所有存储设备统一编址，最低端是通用寄存器，最高端是输入输出设备，中间为主存储器</li>
<li>隐含编址方式，实际上没有零地址空间：堆栈、Cache</li>
</ul>
<h5 id="对于IO设备"><a href="#对于IO设备" class="headerlink" title="对于IO设备"></a>对于IO设备</h5><ul>
<li>一地址一设备：必须通过指令中的操作码来识别该输入输出设备上的有关寄存器</li>
<li>两地址一设备：一个地址是数据寄存器，一个地址是状态&#x2F;控制寄存器</li>
<li>多地址一设备：对编程增加困难，常用于主存和输入输出设备统一编址的计算机系统</li>
</ul>
<h5 id="对于并行存储"><a href="#对于并行存储" class="headerlink" title="对于并行存储"></a>对于并行存储</h5><ul>
<li>高位交叉编址：扩大存储器容量</li>
<li>低位交叉编址：提高存储器速度</li>
</ul>
<p>[高位交叉和低位交叉](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/48014084#:~:text=%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80">https://zhuanlan.zhihu.com/p/48014084#:~:text=高位交叉编址</a> 当程序按体内地址顺序存放，即一个体存满之后，再存入下一个体时，这种方式称为 顺序存储 ，高位地址表示题号，低位表示体内地址（注意0 1 2 3….的顺序是从上往下的）： 因此，CPU给出一次存储访问总是对一块连续的存储单元进行的，在多CPU系统中，不同的CPU访问不同的存储块，达到并行工作。,低位交叉编址 对应于高位交叉编址，低位交叉编址指的是将程序连续存放在相邻体中，又称 交叉存储 。 （注意，0 1 2 3的顺序是从左往右的）)</p>
<h4 id="寻址方式-1"><a href="#寻址方式-1" class="headerlink" title="寻址方式"></a>寻址方式</h4><h5 id="立即数寻址方式"><a href="#立即数寻址方式" class="headerlink" title="立即数寻址方式"></a>立即数寻址方式</h5><p>用于数据比较短、源操作数</p>
<h5 id="面向寄存器的寻址方式"><a href="#面向寄存器的寻址方式" class="headerlink" title="面向寄存器的寻址方式"></a>面向寄存器的寻址方式</h5><h5 id="面向主存储器的寻址方式"><a href="#面向主存储器的寻址方式" class="headerlink" title="面向主存储器的寻址方式"></a>面向主存储器的寻址方式</h5><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p>Many computers support more than a single format for instructions</p>
<h5 id="指令长度"><a href="#指令长度" class="headerlink" title="指令长度"></a>指令长度</h5><p>影响因素</p>
<ul>
<li>存储器规模</li>
<li>存储器架构</li>
<li>总线结构</li>
<li>CPU复杂度</li>
<li>CPU速度</li>
</ul>
<h5 id="位分配"><a href="#位分配" class="headerlink" title="位分配"></a>位分配</h5><ul>
<li>Number of addressing modes</li>
<li>Number of operands</li>
<li>Register versus memory</li>
<li>Number of register sets</li>
<li>Address range</li>
<li>Address granularity</li>
</ul>
<h5 id="指令格式设计"><a href="#指令格式设计" class="headerlink" title="指令格式设计"></a>指令格式设计</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56561130/article/details/118516188">计算机组成原理——指令格式设计_指令中的地址码字段有多少位_花生酱拌面的博客-CSDN博客</a></p>
<h5 id="Locating-modes"><a href="#Locating-modes" class="headerlink" title="Locating modes"></a>Locating modes</h5><ul>
<li>Locating directly</li>
<li>locating statically</li>
<li>locating dynamically</li>
</ul>
<h3 id="优化指令格式"><a href="#优化指令格式" class="headerlink" title="优化指令格式"></a>优化指令格式</h3><p>three approaches</p>
<p><strong>fixed length</strong>，<strong>Huffman coding</strong>，<strong>extending coding</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/changhuzichangchang/article/details/119187648">系统结构-2-3指令操作码的优化:哈夫曼编码_哈夫曼扩展编码规则_哑巴湖小水怪的博客-CSDN博客</a></p>
<h4 id="Huffman编码法"><a href="#Huffman编码法" class="headerlink" title="Huffman编码法"></a>Huffman编码法</h4><p>和数据结构中所学的huffman树没有区别</p>
<p>例</p>
<p>7种指令使用频率分别为0.4、0.26、0.15、0.06、0.05、0.04、0.04，要求对每种指令进行操作码编码</p>
<p><img src="/imgs/ca/20.png" alt="image-20231031153106188"></p>
<h4 id="huffman的扩展方法"><a href="#huffman的扩展方法" class="headerlink" title="huffman的扩展方法"></a>huffman的扩展方法</h4><h5 id="等长扩展"><a href="#等长扩展" class="headerlink" title="等长扩展"></a>等长扩展</h5><h5 id="不等长扩展"><a href="#不等长扩展" class="headerlink" title="不等长扩展"></a>不等长扩展</h5><h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/381490718">编译器常用的8种优化方法 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/521319009">编译器 - 什么是优化编译器 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46222091/category_9729419.html">编译器技术_ronnie88597的博客-CSDN博客</a></p>
<p><img src="/imgs/ca/21.png" alt="image-20231107153317201"></p>
<h4 id="高层次"><a href="#高层次" class="headerlink" title="高层次"></a>高层次</h4><p>done at or near source code level方法内联</p>
<ul>
<li>If procedure is called only once, put it in-line and save CALL</li>
<li>more general case: if call-count &lt; some threshold, put them in-line</li>
</ul>
<h4 id="局部"><a href="#局部" class="headerlink" title="局部"></a>局部</h4><p>done within straight-line code</p>
<ul>
<li>common sub-expressions produce same value – either allocate a register or replace with single copy公共子表达式消除</li>
<li>constant propagation – replace constant valued variable with the constant常量传播</li>
<li>stack height reduction – re-arrange expression tree to minimize temporary storage needs</li>
</ul>
<h4 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h4><p>across a branch</p>
<ul>
<li><p>copy propagation – replace all instances of a variable <em>A</em> that has been assigned <em>X</em> (i.e., <em>A&#x3D;X</em>) with <em>X</em>. 复写传播</p>
</li>
<li><p>code motion – remove code from a loop that computes same value each iteration of the loop and put it before the loop代码移动</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46222091/article/details/104743294">编译器优化–6–代码移动_编译原理 代码移动-CSDN博客</a></p>
</li>
<li><p>simplify or eliminate array addressing calculations in loops</p>
</li>
</ul>
<h4 id="Machine-dependent-optimizations"><a href="#Machine-dependent-optimizations" class="headerlink" title="Machine-dependent optimizations"></a>Machine-dependent optimizations</h4><p>based on machine knowledge</p>
<ul>
<li>strength reduction – replace multiply by a constant with shifts and adds<ul>
<li>would make sense if there was no hardware support for MUL</li>
<li>a trickier version: $17 \times$&#x3D; arithmetic left shift 4 and add</li>
</ul>
</li>
<li>pipelining scheduling – reorder instructions to improve pipeline performance<ul>
<li>dependency analysis</li>
</ul>
</li>
<li>branch offset optimization - reorder code to minimize branch offsets</li>
</ul>
<h3 id="Compiler-techniques-for-exposing-ILP"><a href="#Compiler-techniques-for-exposing-ILP" class="headerlink" title="Compiler techniques for exposing ILP"></a>Compiler techniques for exposing ILP</h3><h4 id="The-impact-of-compiler-technology"><a href="#The-impact-of-compiler-technology" class="headerlink" title="The impact of compiler technology"></a>The impact of compiler technology</h4><p>Three separate areas for data allocation</p>
<ul>
<li><p>Stack</p>
<ul>
<li>Used to allocate <strong>local variables</strong></li>
<li>Grown and shrunk on calls and returns</li>
<li>Addressing is relative to the <strong>stack pointer</strong></li>
</ul>
</li>
<li><p>Global data area </p>
<ul>
<li>Used to allocate <strong>statically declared objects</strong>, such as <strong>global variables and constants</strong></li>
<li>A large percentage of these objects are aggregate data structures such as arrays</li>
</ul>
</li>
<li><p>Heap</p>
<ul>
<li>Used to allocate <strong>dynamic objects</strong></li>
<li>Access are usually by pointers </li>
<li>Data is typically not scalars (single variables)</li>
</ul>
</li>
</ul>
<h4 id="Register-Allocation-Problem"><a href="#Register-Allocation-Problem" class="headerlink" title="Register Allocation Problem"></a>Register Allocation Problem</h4><ul>
<li>Reasonably simple for stack-allocated objects<ul>
<li>Done with the graph coloring theory: variable – vertex; dependency between variables – edge; # register will be equal to # colors</li>
</ul>
</li>
<li>Essentially impossible for heap-allocated objects because they are accessed with pointers</li>
<li>Hard for global variables and some static variables due to <em>aliasing</em> opportunity<ul>
<li>There are multiple ways to refer to the address of a variable <em>b</em></li>
</ul>
</li>
</ul>
<h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><ul>
<li><p>Regularity</p>
<ul>
<li>Addressing modes, operations, and data types should be independent of each other</li>
</ul>
</li>
<li><p>Provide primitives, not solution</p>
<ul>
<li>What works in one language may be detrimental to others, so don’t optimize for one particular language</li>
</ul>
</li>
<li><p>Simplify trade-offs among alternatives</p>
<ul>
<li>Anything that makes code sequence performance obvious is a definite win!</li>
</ul>
</li>
<li><p>Provide instructions that bind the quantities known at compile time as constants</p>
</li>
</ul>
<h3 id="Instruction-Level-Parallelism"><a href="#Instruction-Level-Parallelism" class="headerlink" title="Instruction Level Parallelism"></a>Instruction Level Parallelism</h3><p>Exploit ILP across multiple basic blocks</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55663009">ILP——指令级并行 - 知乎 (zhihu.com)</a></p>
<p>Instruction independency is the key requirement for the transformations</p>
<ol>
<li><p>Eliminating Name Dependences</p>
<p><img src="/imgs/ca/22.png" alt="image-20231114145549135"></p>
</li>
<li><p>Eliminating Control Dependences</p>
<p><img src="/imgs/ca/23.png" alt="image-20231114145754435"></p>
</li>
<li><p>Eliminating Data Dependences</p>
<p><img src="/imgs/ca/24.png" alt="image-20231114145844461"></p>
</li>
<li><p>Alleviating Data Dependencies</p>
<p><img src="/imgs/ca/25.png" alt="image-20231114145933695"></p>
</li>
</ol>
<h4 id="Loop-level-Parallelism"><a href="#Loop-level-Parallelism" class="headerlink" title="Loop-level Parallelism"></a>Loop-level Parallelism</h4><h4 id="software-pipelining"><a href="#software-pipelining" class="headerlink" title="software pipelining"></a>software pipelining</h4><h4 id="Trace-Selection"><a href="#Trace-Selection" class="headerlink" title="Trace Selection"></a>Trace Selection</h4><h3 id="指令系统的功能设计"><a href="#指令系统的功能设计" class="headerlink" title="指令系统的功能设计"></a>指令系统的功能设计</h3><p><strong>指令系统的完整性、规整性、高效率和兼容性</strong></p>
<ul>
<li><p>完整性 是指应该具备的基本指令种类，通用计算机必须有５类基本指令</p>
</li>
<li><p>规整性 包括对称性和均匀性</p>
</li>
<li><p>对称性：所有寄存器同等对待，操作码的设置等都要对称，如：A－B与B－A</p>
</li>
<li><p>均匀性：不同的数据类型、字长、存储设备、操作种类要设置相同的指令</p>
</li>
<li><p>高效率：指令的执行速度要快；指令的使用频度要高；各类指令之间要有一定的比例</p>
</li>
<li><p>兼容性：在同一系列机内指令系统不变（可以适当增加）</p>
</li>
</ul>
<h4 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a>CISC</h4><p>(Complex Instruction Set Computer)	</p>
<p>增强指令功能，设置功能复杂的指令	</p>
<p>面向目标代码、高级语言和操作系统	</p>
<p>用一条指令代替一串指令</p>
<h4 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h4><p>(Reduced Instruction Set Computer)	</p>
<p>只保留功能简单的指令	</p>
<p>功能较复杂的指令用子程序来实现</p>
<ul>
<li>延时转移技术</li>
<li>指令取消技术</li>
<li>重叠寄存器窗口技术</li>
<li>指令流调整技术</li>
<li>以硬件为主固件为辅</li>
</ul>
<h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><h3 id="存储系统原理"><a href="#存储系统原理" class="headerlink" title="存储系统原理"></a>存储系统原理</h3><p><img src="/imgs/ca/26.png" alt="image-20231114153435848"></p>
<h4 id="存储系统的定义"><a href="#存储系统的定义" class="headerlink" title="存储系统的定义"></a>存储系统的定义</h4><ul>
<li>两个或两个以上速度、容量和价格各不相同的存储器用硬件、软件、或软件与硬件相结合的方法连接起来成为一个存储系统。</li>
<li>这个存储系统对应用程序员是透明的，并且，从应用程序员看，它是一个存储器，这个存储器的速度接近速度最快的那个存储器，存储容量与容量最大的那个存储器相等，单位容量的价格接近最便宜的那个存储器。</li>
<li>虚拟存储器系统：对应用程序员透明</li>
<li>Cache存储系统：对系统程序员以上均透明</li>
</ul>
<p><img src="/imgs/ca/32.png" alt="image-20231114162346705"></p>
<p><strong>虚拟存储系统</strong></p>
<p>由主存储器和硬盘构成</p>
<p>主要目的：扩大存储器容量</p>
<p><img src="/imgs/ca/33.png" alt="image-20231114162421037"></p>
<p><strong>存储系统的容量</strong></p>
<ul>
<li><p>要求：</p>
<ul>
<li><p>提供尽可能大的地址空间</p>
</li>
<li><p>能够随机访问</p>
</li>
</ul>
</li>
<li><p>方法有两种：</p>
<ul>
<li><p>只对系统中存储容量最大的那个存储器进行编址，其他存储器只在内部编址或不编址。</p>
</li>
<li><p>Cache存储系统。</p>
</li>
</ul>
</li>
<li><p>另外设计一个容量很大的逻辑地址空间，把相关存储器都映射这个地址空间中。</p>
<ul>
<li>虚拟存储系统。</li>
</ul>
</li>
</ul>
<p><strong>存储系统的价格</strong></p>
<p><img src="/imgs/ca/34.png" alt="image-20231114162803291"><br>$$<br>C&#x3D;\frac{C_1 \cdot S_1+C_2 \cdot S_2}{S_1+S_2}<br>$$<br><strong>存储系统的速度</strong></p>
<p><img src="/imgs/ca/35.png" alt="image-20231114163027416"></p>
<p>提高存储系统速度的两条途径：</p>
<ul>
<li>提高命中率H。<ul>
<li>采用预取技术提高命中率<ul>
<li>方法：不命中时，把M2存储器中相邻多个单元组成的一个数据块取出来送入M1存储器中。</li>
<li>计算公式$H^{\prime}&#x3D;\frac{H+n-1}n$</li>
<li>其中：H’是采用预取技术之后的命中率</li>
<li>H是原来的命中率</li>
<li>n为数据块大小与数据重复使用次数的乘积</li>
</ul>
</li>
</ul>
</li>
<li>两个存储器的速度不要相差太大。</li>
<li>其中：第二条有时做不到(如虚拟存储器)，这时，只能依靠提高命中率。</li>
</ul>
<p><strong>存储系统的访问效率</strong><br>$$<br>e&#x3D;\frac{T_1}{T}&#x3D;\frac{T_1}{H\cdot T_1+(1-H)\cdot T_2}&#x3D;\frac{1}{H+(1-H)\cdot\frac{T_2}{T_1}}&#x3D;f(H,\frac{T_2}{T_1})<br>$$<br>访问效率主要与命中率和两级存储器的速度之比有关</p>
<p><strong>内存</strong></p>
<ul>
<li><p>RAM</p>
<ul>
<li><p>DRAM</p>
<p><img src="/imgs/ca/27.png" alt="image-20231114161215500"></p>
</li>
<li><p>Cache-SRAM (static RAM) made up of flip-flops (like Registers)</p>
</li>
</ul>
</li>
<li><p>ROM</p>
<ul>
<li>PROM</li>
<li>EPROM</li>
<li>EEPROM</li>
</ul>
</li>
</ul>
<p><strong>外存</strong></p>
<ul>
<li><p>Magnetic Disk</p>
<ul>
<li><p>RAID</p>
</li>
<li><p>Removable</p>
</li>
</ul>
</li>
<li><p>Solid State Drive (nowadays)</p>
</li>
<li><p>Optical</p>
<ul>
<li><p>CD-ROM</p>
</li>
<li><p>CD-Recordable (CD-R)</p>
</li>
<li><p>CD-R&#x2F;W</p>
</li>
<li><p>DVD</p>
</li>
</ul>
</li>
<li><p>Magnetic Tape</p>
</li>
</ul>
<p><strong>主要性能</strong></p>
<p>存储器的主要性能：速度、容量、价格。</p>
<ul>
<li>速度用存储器的访问周期、读出时间、频带宽度等表示。</li>
<li>容量用字节B、千字节KB、兆字节MB和千兆字节GB等单位表示。</li>
<li>价格用单位容量的价格表示，例如：$C&#x2F;bit。</li>
<li>组成存储系统的关键：把速度、容量和价格不同的多个物理存储器组织成一个存储器，这个存储器的速度最快，存储容量最大，单位容量的价格最便宜。</li>
</ul>
<h4 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h4><p><img src="/imgs/ca/28.png" alt="image-20231114161940074"></p>
<p><img src="/imgs/ca/29.png" alt="image-20231114162001246"></p>
<p>存储层次工作原理：<strong>Locality</strong></p>
<ul>
<li><p>应用程序局部性原理: 给用户</p>
<ul>
<li><p>一个采用低成本技术达到的存储容量. （容量大，价格低）</p>
</li>
<li><p>一个采用高速存储技术达到的访问速度.（速度快）</p>
</li>
</ul>
</li>
<li><p>Temporal Locality (时间局部性):</p>
<ul>
<li>&#x3D;&gt;保持最近访问的数据项最接近微处理器</li>
</ul>
</li>
<li><p>Spatial Locality (空间局部性):</p>
<ul>
<li>以由地址连续的若干个字构成的块为单位，从低层复制到上一层</li>
</ul>
</li>
</ul>
<p><img src="/imgs/ca/30.png" alt="image-20231114162208874"></p>
<p><img src="/imgs/ca/31.png" alt="image-20231114162225091"></p>
<h4 id="存储系统的频带平衡"><a href="#存储系统的频带平衡" class="headerlink" title="存储系统的频带平衡"></a>存储系统的频带平衡</h4><p>解决存储器频带平衡方法</p>
<ul>
<li>多个存储器并行工作</li>
<li>设置各种缓冲存储器</li>
<li>采用存储系统</li>
</ul>
<h4 id="并行访问存储器"><a href="#并行访问存储器" class="headerlink" title="并行访问存储器"></a>并行访问存储器</h4><p><img src="/imgs/ca/36.png" alt="image-20231114163617974"></p>
<p><img src="/imgs/ca/37.png" alt="image-20231114163635363"></p>
<h4 id="交叉访问存储器"><a href="#交叉访问存储器" class="headerlink" title="交叉访问存储器"></a>交叉访问存储器</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nuo_Shar/article/details/79048019">多体并行：高位&#x2F;低位交叉编址-CSDN博客</a></p>
<h5 id="高位交叉访问存储器"><a href="#高位交叉访问存储器" class="headerlink" title="高位交叉访问存储器"></a>高位交叉访问存储器</h5><ul>
<li>主要目的：扩大存储器容量</li>
<li>实现方法：用地址码的高位部分区分存储体号</li>
<li>参数计算方法:<ul>
<li>m: 每个存储体的容量， </li>
<li>n: 总共的存储体个数， </li>
<li>j: 存储体的体内地址，$\mathrm{j&#x3D; 0, 1, 2, …, m- 1}$</li>
<li>k: 存储体的体号，k&#x3D;0, 1, 2, .., n-1</li>
<li>存储器A的地址： $\mathbf{A}&#x3D;\mathbf{m}\times\mathbf{k}+\mathbf{j}$</li>
<li>存储器的体内地址： $\mathbf{A_i}&#x3D;\mathbf{A}$ mod m</li>
<li>存储器的体号$\quad\mathbf{A_k}&#x3D;\left\lfloor\frac Am\right\rfloor$</li>
</ul>
</li>
</ul>
<h5 id="低位交叉访问存储器"><a href="#低位交叉访问存储器" class="headerlink" title="低位交叉访问存储器"></a>低位交叉访问存储器</h5><ul>
<li><p>主要目的：提高存储器访问速度</p>
</li>
<li><p>实现方法：用地址码的低位部分区分存储体号</p>
</li>
<li><p>参数计算:</p>
<ul>
<li>m: 每个存储体的容量， </li>
<li>n: 总共的存储体个数， </li>
<li>j: 存储体的体内地址，$\mathrm{j&#x3D; 0, 1, 2, …, m- 1}$</li>
<li>k: 存储体的体号，k&#x3D;0, 1, 2, .., n-1</li>
<li>存储器A的地址： $\mathbf{A}&#x3D;\mathbf{n}\times\mathbf{j}+\mathbf{k}$</li>
<li>存储器的体内地址:$\quad\mathbf{A_j}&#x3D;\left\lfloor\frac An\right\rfloor$</li>
<li>存储器的体号:$A_k&#x3D;A \mod n$</li>
</ul>
</li>
<li><p>n个存储体分时启动</p>
<ul>
<li>一种采用流水线方式工作的并行存储器</li>
<li>每个存储体的启动间隔为$t&#x3D;\left\lfloor\frac{Tm}n\right\rfloor$</li>
<li>其中： </li>
<li>Tm为每个存储体的访问周期</li>
<li>n为存储体个数</li>
</ul>
</li>
</ul>
<p><img src="/imgs/ca/38.png" alt="image-20231114164447369"></p>
<h4 id="无冲突访问存储器"><a href="#无冲突访问存储器" class="headerlink" title="无冲突访问存储器"></a>无冲突访问存储器</h4><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><h4 id="虚拟存储器工作原理"><a href="#虚拟存储器工作原理" class="headerlink" title="虚拟存储器工作原理"></a>虚拟存储器工作原理</h4><p>把主存储器、磁盘存储器和虚拟存储器都划分成固定大小的页</p>
<ul>
<li>主存储器的页称为实页</li>
<li>虚拟存储器中的页称为虚页</li>
</ul>
<p><img src="/imgs/ca/39.png" alt="image-20231121141158327"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/github_33873969/article/details/78460522">深入理解虚拟存储器（1:虚拟存储器概念与工作原理）-CSDN博客</a></p>
<h4 id="地址的映像和变换方法"><a href="#地址的映像和变换方法" class="headerlink" title="地址的映像和变换方法"></a>地址的映像和变换方法</h4><p>三种地址空间</p>
<ul>
<li>虚拟地址空间</li>
<li>主存储器地址空间</li>
<li>辅助地址空间</li>
</ul>
<p>地址映像</p>
<p>把虚拟地址空间映象到主存地址空间</p>
<p>地址变换</p>
<p>在程序运行时，把虚地址变换成主存实地址</p>
<p>三种虚拟存储器</p>
<ul>
<li><p>段式虚拟存储器</p>
<p><strong>地址映象方法</strong>：每个程序段都从0地址开始编址，长度可长可短，可以在程序执行过程中动态改变程序段的长度</p>
<p><img src="/imgs/ca/40.png" alt="image-20231121142515910"></p>
<p><strong>地址变换方法</strong>：由用户号找到基址寄存器，读出段表起始地址，与虚地址中段号相加得到段表地址，把段表中的起始地址与段内偏移D相加就能得到主存实地址</p>
<p><img src="/imgs/ca/41.png" alt="image-20231121142648106"></p>
<p>段表中的段长和访问方式用来保护程序段</p>
<ul>
<li><p>可以根据程序段的<strong>起始地址</strong>和<strong>段长</strong>计算出本次访问主存储器的地址是否越界。</p>
</li>
<li><p>访问方式可以指出本程序段是否需要保护和保护的级别。</p>
</li>
<li><p>装入位如果表明该程序段不在主存中，段表的起始地址和访问方式字段可以用来存放该程序段在磁盘存储器中的起始地址，便于从磁盘把信息读到主存。</p>
</li>
</ul>
<p>外部碎片的消除</p>
<ul>
<li><p>compaction</p>
<p>Moving segments closer to zero to eliminate wasted space</p>
<p><img src="/imgs/ca/42.png" alt="image-20231121143248395"></p>
</li>
<li><p>fit segments in existing holes</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43886592/article/details/107581653">动态分区分配算法(First Fit，Next Fit，Best Fit，Worst Fit)-CSDN博客</a></p>
<ul>
<li>Maintain a list of Addresses &amp; Hole Size</li>
<li>algorithms<ul>
<li>best fit: choose smallest hole</li>
<li>FIRST FIT: scan circularly &amp; choose which fits first.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>主要优点</p>
<ul>
<li>程序的模块化性能好</li>
<li>便于程序和数据的共享</li>
<li>程序的动态链接和调度比较容易</li>
<li>便于实现信息保护</li>
</ul>
<p>主要缺点</p>
<ul>
<li>地址变换所花费的时间长，两次加法。</li>
<li>主存储器的利用率往往比较低。</li>
<li>对辅存（磁盘存储器）的管理比较困难</li>
</ul>
</li>
<li><p>页式虚拟存储器</p>
<ul>
<li><p>把虚拟地址空间划分为固定大小的块，每一块称为1页</p>
</li>
<li><p>主存的地址空间也划分为同样大小的页</p>
</li>
<li><p>为和磁盘存储器物理块大小配合，虚拟存储器大小指定为0.5kb的整数倍</p>
</li>
<li><p>用户程序只需要将虚页号变换为实页号即可实现到主存实地址空间的映像</p>
</li>
</ul>
<p><img src="/imgs/ca/43.png" alt="image-20231121143927570"></p>
<p>内部地址变换：多用户虚拟地址$A_v$变换成主存实地址A</p>
<ul>
<li>多用户虚拟地址中的页内偏移D直接作为主存实地址中的页内偏移d</li>
<li>主存实页号p与它的页内偏移d直接拼接起来就得到主存实地址A</li>
</ul>
<p><img src="/imgs/ca/44.png" alt="image-20231121144120269"></p>
<p>地址映像方法</p>
<p><img src="/imgs/ca/45.png" alt="image-20231121144159777"></p>
<p>地址变换方法</p>
<p><img src="/imgs/ca/46.png" alt="image-20231121144220253"></p>
<p>优点</p>
<ul>
<li>主存储器的利用率比较高。每个用户程序只有不到1页的浪费。</li>
<li>页表相对比较简单。需保存的字段数比较少。</li>
<li>地址变换的速度比较快。只需建立虚页和实页之间的联系即可。</li>
<li>对磁盘的管理比较容易。一页的大小是磁盘快大小的整数倍</li>
</ul>
<p>缺点</p>
<ul>
<li>程序的模块化性能不好。一页可能多个程序或者部分程序。</li>
<li>页表很长，需要占用很大的存储空间</li>
</ul>
</li>
<li><p>段页式虚拟存储器</p>
<p>用户按段写程序, 每段分成几个固定大小的页</p>
<p>地址映像方法</p>
<ul>
<li>每个程序段在段表中占一行，</li>
<li>在段表中给出页表长度和页表的起始地址，</li>
<li>页表中给出每一页在主存储器中的实页号。</li>
</ul>
<p><img src="/imgs/ca/47.png" alt="image-20231121145440247"></p>
<p>地址变换方法</p>
<ul>
<li>先查段表，得到页表起始地址和页表长度，</li>
<li>再查页表找到要访问的主存实页号，</li>
<li>把实页号p与页内偏移d拼接得到主存实地址</li>
</ul>
<p><img src="/imgs/ca/48.png" alt="image-20231121145528211"></p>
</li>
<li><p>外部地址变换</p>
<p>保存和恢复故障点的现场，待故障处理完后返回断点继续执行程序</p>
<ul>
<li>采用硬件的缓冲寄存器，把执行该指令时的故障现场全部保存在缓冲寄存器中，等页面失效处理完，可以完整的恢复故障点还没有执行完的程序。</li>
<li>只保护部分现场，如程序计数器、处理机状态字等，等页面失效结束，从头开始执行没有完成的指令。</li>
<li>采用指令预判技术，对那些可能发生跨页执行的指令，如字符串指令等，在指令执行之前，就做页面失效处理，等该指令所需页面全部调入主存才开始执行该指令。</li>
</ul>
<p>每个程序有一张外页表，每一页或每个程序段，在外页表中都有对应的一个存储字</p>
<p><img src="/imgs/ca/49.png" alt="image-20231121150640954"></p>
</li>
</ul>
<h4 id="加快内部地址变换的方法"><a href="#加快内部地址变换的方法" class="headerlink" title="加快内部地址变换的方法"></a>加快内部地址变换的方法</h4><p>造成虚拟存储器速度降低的主要原因</p>
<ul>
<li>要访问主存储器必须先查段表或页表，</li>
<li>可能需要多级页表</li>
</ul>
<p>页表级数的计算公式<br>$$<br>g&#x3D;\left\lceil\frac{\log2N\nu-\log2Np}{\log2Np-\log2Nd}\right\rceil<br>$$</p>
<ul>
<li>Nv为虚拟存储空间大小，</li>
<li>Np为页面的大小，</li>
<li>Nd为一个页表存储字的大小。</li>
</ul>
<h5 id="目录表"><a href="#目录表" class="headerlink" title="目录表"></a>目录表</h5><p>基本思想：压缩页表存储容量，用一个小容量高速存储器存放页表，加快页表的查表速度</p>
<p>页表只为装入到主存的那些页面建立虚页号与实页号之间的对应关系</p>
<p><img src="/imgs/ca/50.png" alt="image-20231121151105280"></p>
<p>地址变换过程</p>
<p>把多用户虚地址中U与P拼接，相联访问目录表。读出主存实页号p，把p与多用户虚地址中的D拼接得到主存实地址。如果相联访问失败，发出页面失效请求。</p>
<p>优点</p>
<ul>
<li>与页表放在主存中相比，查表速度快</li>
</ul>
<p>缺点</p>
<ul>
<li>可扩展性比较差。</li>
<li>主存储器容量大时，目录表造价高，速度低</li>
</ul>
<h5 id="快慢表"><a href="#快慢表" class="headerlink" title="快慢表"></a>快慢表</h5><p><img src="/imgs/ca/51.png" alt="image-20231121151633801"></p>
<p>快表TLB(Translation Lookaside Buffer)</p>
<ul>
<li>小容量(几～几十个字)。</li>
<li>高速硬件实现。</li>
<li>采用相联方式访问</li>
</ul>
<p>慢表</p>
<ul>
<li>当快表中查不到时，从主存的慢表中查找。快表是慢表的部分副本。访问速度接近快表，存储容量是慢表的容量。</li>
<li>慢表按地址访问；用软件实现。</li>
</ul>
<p>快表与慢表也构成一个两级存储系统。</p>
<p>主要存在问题：相联访问实现困难，速度低。</p>
<h5 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h5><p>目的：把相联访问变成按地址访问</p>
<p>按地址查找信息，散列(Hashing)函数最快，对于快表就是要把多用户虚页号变成快表的地址：Ah＝H(Pv)</p>
<p><img src="/imgs/ca/52.png" alt="image-20231121152630632"></p>
<ul>
<li>把一个大得多的多用户虚页号Pv散列变成一个小的快表地址，必然有很多个多用户虚页号都变到相同的快表地址中，这种现象称为散列冲突。</li>
<li>为避免散列冲突，必须把多用户虚页号也加入到快表中，并且与主存实页号存放到同一个快表存储字中。</li>
<li>需要一个比较器，把快表中读出来的多用户虚页号与多用户虚地址中的虚页号进行比较。<ul>
<li>比较结果相等，继续正常进行主存的访问。</li>
<li>比较结果不等，发生了散列冲突，需要查询主存中的慢表。</li>
</ul>
</li>
</ul>
<p>采用散列变换实现快表按地址访问</p>
<ul>
<li>避免散列冲突：采用相等比较器</li>
<li>地址变换：相等比较与访问存储器同时进行</li>
</ul>
<p><img src="/imgs/ca/53.png" alt="image-20231121152959373"></p>
<h5 id="inverted-page-tables反置页表"><a href="#inverted-page-tables反置页表" class="headerlink" title="inverted page tables反置页表"></a>inverted page tables反置页表</h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/195657513">反置页表(Inverted Page Table) - 知乎 (zhihu.com)</a></p>
<p>使用反置页表的话，所有进程共同使用一张页表，这张页表中的条目的数量和内存中物理的页框的数量是一样的。反置页表中的每个条目拥有以下字段：</p>
<ul>
<li>页号</li>
<li>进程ID</li>
<li>控制位——包括valid位，dirty位，reference位，protection位和locking位。</li>
<li>链接指针——如果出现进程共享内存的情况，就会用到链接指针</li>
</ul>
<p><img src="/imgs/ca/54.png" alt="image-20231121153255138"></p>
<h4 id="页面替换算法及其实现"><a href="#页面替换算法及其实现" class="headerlink" title="页面替换算法及其实现"></a>页面替换算法及其实现</h4><h5 id="页面替换发生时间"><a href="#页面替换发生时间" class="headerlink" title="页面替换发生时间"></a>页面替换发生时间</h5><p>当发生页面失效时，要从磁盘中调入一页到主存。如果主存储器的所有页面都已经被占用，必须从主存储器中淘汰掉一个不常使用的页面，以便腾出主存空间来存放新调入的页面。</p>
<h5 id="评价页面替换算法好坏的标准"><a href="#评价页面替换算法好坏的标准" class="headerlink" title="评价页面替换算法好坏的标准"></a>评价页面替换算法好坏的标准</h5><ul>
<li>命中率要高，</li>
<li>算法要容易实现。</li>
</ul>
<h5 id="页面替换算法的使用场合"><a href="#页面替换算法的使用场合" class="headerlink" title="页面替换算法的使用场合"></a>页面替换算法的使用场合</h5><ul>
<li>虚拟存储器中，主存页面的替换，一般用软件实现。</li>
<li>Cache中的块替换，一般用硬件实现。</li>
<li>虚拟存储器的快慢表中，快表存储字的替换，用硬件实现。</li>
<li>虚拟存储器中，用户基地址寄存器的替换，用硬件实现。</li>
<li>在有些虚拟存储器中，目录表的替换。</li>
</ul>
<h5 id="主要页面替换算法"><a href="#主要页面替换算法" class="headerlink" title="主要页面替换算法"></a>主要页面替换算法</h5><ul>
<li>随机算法（RAND random algorithm）<ul>
<li>算法简单，容易实现。</li>
<li>没有利用历史信息，没有反映程序的局部性。</li>
<li>命中率低。</li>
</ul>
</li>
<li>先进先出算法<br>(FIFO first-in first-out algorithm)<ul>
<li>容易实现，利用了历史信息。</li>
<li>没有反映程序的局部性。</li>
<li>最先调入的页面，很可能也是要使用的页面。</li>
</ul>
</li>
<li>近期最少使用算法(LFU least frequently used algorithm)：<ul>
<li>既充分利用了历史信息，又反映了程序的局部性实现起来非常困难。</li>
</ul>
</li>
<li>最久没有使用算法(LRU least recently used algorithm)：<ul>
<li>把LFU算法中的“多”与“少”简化成“有”与“无”，实现比较容易</li>
</ul>
</li>
<li>最优替换算法（OPT optimal replacement algorithm）：<ul>
<li>是一种理想算法，仅用作评价其它页面替换算法好坏的标准。</li>
</ul>
</li>
<li>实际可能只有FIFO和LRU</li>
</ul>
<p>一个程序共有5个页面组成，分别为P1-P5。在程序执行过程中，页面地址流如下</p>
<p>P1，P2，P1，P5，P4，P1，P3，P4，P2，P4</p>
<p>假设分配给这个程序的主存只有3个页面</p>
<p><img src="/imgs/ca/55.png" alt="image-20231121153720342"></p>
<h5 id="堆栈型替换算法"><a href="#堆栈型替换算法" class="headerlink" title="堆栈型替换算法"></a>堆栈型替换算法</h5><p><img src="/imgs/ca/56.png" alt="image-20231128144311331"></p>
<p><img src="/imgs/ca/57.png" alt="image-20231128144451129"></p>
<p>堆栈型替换算法的命中率随分配给该程序的主存页面上升而单调上升</p>
<h4 id="提高主存命中率的方法"><a href="#提高主存命中率的方法" class="headerlink" title="提高主存命中率的方法"></a>提高主存命中率的方法</h4><h5 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h5><ul>
<li>程序在执行过程中的页地址流分布情况。</li>
<li>所采用的页面替换算法。</li>
<li>页面大小。</li>
<li>主存储器的容量。</li>
<li>所采用的页面调度算法。</li>
</ul>
<h5 id="页面大小与命中率的关系"><a href="#页面大小与命中率的关系" class="headerlink" title="页面大小与命中率的关系"></a>页面大小与命中率的关系</h5><ul>
<li>假设At和At+1是相邻两次访问主存的逻辑地址$d&#x3D;|A_t-A_{t-1}|$</li>
<li>如果d&lt;Sp，随着Sp增大，At和At+1在同一页面的可能性增大，即命中率Ｈ随着页面大小Sp的增大而提高</li>
<li>如果d&gt;Sp，At和At+1一定不在同一页面，Sp增大，主存页面数减少，页面替换频繁，命中率Ｈ随着页面大小Sp的增大而降低</li>
</ul>
<p><img src="/imgs/ca/58.png" alt="image-20231205153627110"></p>
<ul>
<li>当Sp比较小的时候，前一种情况是主要的，Ｈ随着Sp的增大而提高。当Sp达到某一个最大值之后，后一种情况成为主要的，Ｈ随着Sp的增大而降低。</li>
<li>当页面增大时，造成的浪费也要增加。</li>
<li>当页面减小时，页表和页面表在主存储器中所占的比例将增加。</li>
</ul>
<h5 id="主存容量与命中率的关系"><a href="#主存容量与命中率的关系" class="headerlink" title="主存容量与命中率的关系"></a>主存容量与命中率的关系</h5><p>主存命中率H随着分配给该程序的主存容量S的增加而单调上升</p>
<p>在S比较小的时候，H提高得非常快。随着S的逐渐增加，H提高的速度逐渐降低。当S增加到某一个值之后，H几乎不再提高</p>
<p><img src="/imgs/ca/59.png" alt="image-20231205153804801"></p>
<h5 id="页面调度方式与命中率的关系"><a href="#页面调度方式与命中率的关系" class="headerlink" title="页面调度方式与命中率的关系"></a>页面调度方式与命中率的关系</h5><ul>
<li>请求页式：当使用到的时候，再调入主存</li>
<li>预取式（分页式）：在程序重新开始运行之前，把上次停止运行前一段时间内用到的页面先调入到主存储器，然后才开始运行程序。</li>
<li>预取式的主要优点：<br>可以避免在程序开始运行时，频繁发生页面失效的情况。</li>
<li>预取式的主要缺点：<br>如果调入的页面用不上，浪费了调入的时间，占用了主存的资源。</li>
</ul>
<h3 id="高速缓冲存储器cache"><a href="#高速缓冲存储器cache" class="headerlink" title="高速缓冲存储器cache"></a>高速缓冲存储器cache</h3><p><img src="/imgs/ca/60.png" alt="image-20231212140842042"></p>
<h4 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h4><p>CPU将主存地址放入主存地址寄存器，通过主存——Cache地址变换部件将主存中的块号B变换成Cache的块号b，结果放到Cache地址寄存器，主存地址中的块内地址W直接作为Cache的块内地址。</p>
<p><img src="/imgs/ca/61.png" alt="image-20231212140956682"></p>
<h4 id="地址映象与变换方法"><a href="#地址映象与变换方法" class="headerlink" title="地址映象与变换方法"></a>地址映象与变换方法</h4><p><strong>地址映象</strong></p>
<p>把主存中的程序按照某种规则装入到Cache中，并建立主存地址与Cache地址之间的对应关系</p>
<p><strong>选取地址映象方法的主要考量</strong></p>
<ul>
<li>地址变换的硬件实现容易、速度要快。</li>
<li>主存空间利用率要高。</li>
<li>发生块冲突的概率要小。</li>
</ul>
<p><strong>地址变换</strong></p>
<p>当程序已经装入到Cache之后，在程序运行过程中，把主存地址变换成Cache地址</p>
<h5 id="全相联映象及其变换"><a href="#全相联映象及其变换" class="headerlink" title="全相联映象及其变换"></a>全相联映象及其变换</h5><ul>
<li>映象规则：主存的任意一块可以映象到Cache中的任意一块。</li>
<li>映象关系有Cb×Mb种。</li>
<li>采用目录表存放这种关系，目录表的容量为Cb，字长为Cache地址中的块号长度加主存地址中的块号长度，再加1位有效位。</li>
</ul>
<p><img src="/imgs/ca/62.png" alt="image-20231212141503742"></p>
<p>优点：</p>
<ul>
<li>块的冲突率最小。</li>
<li>Cache利用率最高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要一个相联访问速度很快，容量为Cb的相联存储器（目录表），代价高。</li>
<li>相联比较所花费的时间会影响到Cache的访问速度</li>
</ul>
<p>地址变换规则 硬件实现复杂</p>
<p><img src="/imgs/ca/63.png" alt="image-20231212141805213"></p>
<p>没有命中：</p>
<ul>
<li><p>利用主存地址去访问主存，将主存一个字内容送到CPU。</p>
</li>
<li><p>包括被访问字的一块内容替换到Cache中。</p>
</li>
<li><p>修改目录表中的主存块号字段，把当前的主存块号B写到目录表的存储字中。</p>
</li>
<li><p>有效位表示目录表中各个存储字是否有效。</p>
<ul>
<li>如果为1，表示目录表中主存块号B与Cache块号b建立的映像有效，b是B的正确副本。</li>
<li>如果为0，表示B和b之间映像无效，或没有关系。</li>
</ul>
</li>
</ul>
<h5 id="直接映象及其变换"><a href="#直接映象及其变换" class="headerlink" title="直接映象及其变换"></a>直接映象及其变换</h5><ul>
<li><p>映象规则：主存储器中一块只能映象到Cache的一个特定的块中。</p>
</li>
<li><p>Cache地址的计算公式：<br>$$<br>b&#x3D;B\ mod\ C_b<br>$$</p>
<ul>
<li>b为Cache块号，</li>
<li>B是主存块号，</li>
<li>Cb是Cache块数。</li>
</ul>
</li>
<li><p>Cache地址与主存储器地址的低位部分完全相同</p>
</li>
</ul>
<p><img src="/imgs/ca/64.png" alt="image-20231212142259495"></p>
<ul>
<li>主存块号B和Cache块号b完全相同。</li>
<li>体内地址完全相同。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>硬件实现很简单，不需要相联访问存储器</li>
<li>访问速度也比较快，实际上不需要进行地址变换</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>块的冲突率比较高。主存中多块都映像到Cache同一块中，又是常用块，Cache的命中率很低</li>
</ul>
<p>地址变换过程</p>
<ul>
<li>用主存地址中的块号B去访问区号存储器，把读出来的区号与主存地址中的区号E进行比较：<ul>
<li>比较结果相等，有效位为1，则Cache命中，否则该块已经作废。</li>
<li>比较结果不相等，有效位为1，Cache中的该块是有用的，否则该块是空的。</li>
</ul>
</li>
</ul>
<p><img src="/imgs/ca/65.png" alt="image-20231212142635126"></p>
<ul>
<li>如果区号比较结果相等，有效位为0，表示Cache中这一块已经作废，把从主存读出来的新块按照Cache地址装入到Cache中，有效位置1。</li>
<li>如果区号比较结果不相等，有效位为0，表示该块是空的。主存读出块写入到Cache中，有效位置1，主存区号写入到区表存储器相应单元。</li>
<li>如果区号比较结果不相等，有效位为1，表示Cache中原来那块是有用的，必须将该块写回主存，才能将新块存入，把主存区号写到区号存储器的相应单元。</li>
</ul>
<p><strong>提高cache速度的一种方法</strong></p>
<p>把区号存储器与Cache合并成一个存储器</p>
<p><img src="/imgs/ca/66.png" alt="image-20231212143414005"></p>
<h5 id="组相联映象及其变换"><a href="#组相联映象及其变换" class="headerlink" title="组相联映象及其变换"></a>组相联映象及其变换</h5><ul>
<li>映象规则：<ul>
<li>主存和Cache按同样大小划分成块和组。</li>
<li>主存和Cache的组之间采用直接映象方式。</li>
<li>在两个对应的组内部采用全相联映象方式。</li>
</ul>
</li>
<li>组相联映象方式的优点：<ul>
<li>块的冲突概率比较低，</li>
<li>块的利用率大幅度提高，</li>
<li>块失效率明显降低。</li>
</ul>
</li>
<li>组相联映象方式的缺点：<ul>
<li>实现难度和造价要比直接映象方式高。</li>
</ul>
</li>
</ul>
<p><img src="/imgs/ca/67.png" alt="image-20231212143531117"></p>
<ul>
<li>实现地址变换需要一个高速是小容量的存储器做成块表存储器。</li>
<li>采用地址访问和相联访问两种工作方式。块内相联，块间地址。</li>
<li>容量与Cache 的块数相等。字长为主存的区号、组内块号B、Cache块号b长度之和，加有效位和控制字段。</li>
</ul>
<p>变换过程</p>
<ol>
<li>用主存地址中的组号G按地址访问块表存储器。</li>
<li>把读出来的一组区号和块号与主存地址中的区号和块号进行相联比较。<ul>
<li>如果有相等的，表示Cache命中；</li>
<li>如果全部不相等，表示Cache没有命中。</li>
</ul>
</li>
</ol>
<p><img src="/imgs/ca/68.png" alt="image-20231212143908430"></p>
<p>提高Cache访问速度的一种方法：<br>用多个相等比较器来代替相联访问</p>
<p><img src="/imgs/ca/69.png" alt="image-20231212143936413"></p>
<ul>
<li><p>块内字数不多时，可以把块表和Cache合并成一个存储器。</p>
</li>
<li><p>组相联映像方式和直接映像方式相比，最明显的优点是块的冲突率大大降低，如组内有4块相联的组相联，主存的一块可以映射到4块中，直接映像只能映射到一块。</p>
<ul>
<li>块利用率大幅度提高，失效率明显下降。</li>
<li>但组内需要比较，实现难度和造价较高。</li>
</ul>
</li>
<li><p>组相联映像方式和全相联映像方式相比，实现起来还是要容易，而命中率相近。</p>
<ul>
<li>当每组的块容量Gb为1时，就是直接映像方式。</li>
<li>当每组块容量Gb与Cache的块容量Cb相等时，就是全相联方式。</li>
</ul>
</li>
<li><p>在Cache的容量和每块的大小确定后，选择每组的块容量Gb，和Cache的组容量Cg，即分配Cache地址中组号g和组内块号b的长度，可以优化Cache性能。</p>
<ul>
<li>块冲突率。</li>
<li>块失效率。</li>
<li>查表速度。</li>
<li>实现的复杂性和成本。</li>
<li>组内块容量越大，冲突率、失效率低，但查表慢、成本高。</li>
</ul>
</li>
</ul>
<h5 id="位选择组相联映象及其变换"><a href="#位选择组相联映象及其变换" class="headerlink" title="位选择组相联映象及其变换"></a>位选择组相联映象及其变换</h5><ul>
<li>地址映象规则：<ul>
<li>主存和Cache都按同样大小分块。</li>
<li>Cache在分块的基础上再分组。</li>
<li>主存按照Cache的组容量分区，区块容量等于Cache内组容量。</li>
<li>主存的块与Cache的组之间采用直接映象方式。</li>
<li>主存中的块与Cache中组内部的各个块之间采用全相联映象方式。</li>
</ul>
</li>
<li>与组相联映象方式比较：<ul>
<li>映象关系明显简单，实现起来容易。</li>
<li>在块表中存放和参与相联比较的只有区号E。</li>
</ul>
</li>
</ul>
<p><img src="/imgs/ca/70.png" alt="image-20231212144202801"></p>
<p>主存块只能到Cache中特定的组，在组内的位置随便</p>
<p><img src="/imgs/ca/71.png" alt="image-20231212144228377"></p>
<h5 id="段相联映象及其变换"><a href="#段相联映象及其变换" class="headerlink" title="段相联映象及其变换"></a>段相联映象及其变换</h5><ul>
<li>映象规则：<ul>
<li>主存和Cache都按同样大小分块和段。</li>
<li>段之间采用全相联映象方式。</li>
<li>段内部的块之间采用直接映象方式。</li>
</ul>
</li>
<li>地址变换过程：<ol>
<li>用主存地址中的段号与段表中的主存段号进行相联比较</li>
<li>如果有相等的，用主存地址的段内块号按地址访问Cache的段号部分。</li>
<li>把读出的段号s与主存地址的段内块号b及块内地址w拼接起来得到Cache地址。</li>
</ol>
</li>
</ul>
<p><img src="/imgs/ca/72.png" alt="image-20231212144325762"></p>
<p>主存内块可以到Cache内任何一个段，但在到段之后只能在段内特定的位置。</p>
<p><strong>段相联映象方式的优缺点</strong></p>
<ul>
<li>主要优点：<ul>
<li>段表比较简单，实现的成本低。</li>
<li>例如：一个容量为256KB的Cache，分成8个段，每段2048块，每块16B。</li>
<li>在段表存储器中只需要存8个主存地址的段号,</li>
<li>而在块表中要存储8×2048＝16384个区号，</li>
<li>两者相差2000多倍。</li>
</ul>
</li>
<li>主要缺点：<ul>
<li>当发生段失效时，要把本段内已经建立起来的所有映象关系全部撤消。</li>
</ul>
</li>
</ul>
<h4 id="Cache替换算法及其实现"><a href="#Cache替换算法及其实现" class="headerlink" title="Cache替换算法及其实现"></a>Cache替换算法及其实现</h4><ul>
<li>使用的场合：<ul>
<li>直接映象方式实际上不需要替换算法。</li>
<li>全相联映象方式的替换算法最复杂。</li>
<li>主要用于组相联、段相联等映象方式中。</li>
</ul>
</li>
<li>要解决的问题：<ul>
<li>记录每次访问Cache的块号。</li>
<li>在访问过程中，对记录的块号进行管理。</li>
<li>根据记录和管理结果，找出替换的块号。</li>
</ul>
</li>
<li>主要特点：全部用硬件实现。</li>
</ul>
<h5 id="轮换法及其实现"><a href="#轮换法及其实现" class="headerlink" title="轮换法及其实现"></a>轮换法及其实现</h5><p>用于组相联映象方式中，有两种实现方法</p>
<h6 id="每块一个计数器"><a href="#每块一个计数器" class="headerlink" title="每块一个计数器"></a>每块一个计数器</h6><ul>
<li>在块表内增加一个替换计数器字段。</li>
<li>计数器的长度与Cache地址中的组内块号字段的长度相同。</li>
</ul>
<p>替换方法及计数器的管理规则：</p>
<ul>
<li>新装入或替换的块，它的计数器清0，同组其它块的计数器都加“1”。</li>
<li>在同组中选择计数器的值最大的块作为被替换的块。</li>
</ul>
<h6 id="每组一个计数器"><a href="#每组一个计数器" class="headerlink" title="每组一个计数器"></a>每组一个计数器</h6><p>替换规则和计数器的管理：</p>
<ul>
<li>本组有替换时，计数器加“1”，</li>
<li>计数器的值就是要被替换出去的块号。</li>
</ul>
<p>轮换法的优点：</p>
<p>实现比较简单，能够利用历史上的块地址流情况。</p>
<p>轮换法的缺点：</p>
<p>没有利用程序的局部性特点。</p>
<h5 id="LRU算法及其实现"><a href="#LRU算法及其实现" class="headerlink" title="LRU算法及其实现"></a>LRU算法及其实现</h5><ul>
<li><p>为每一块设置一个计数器</p>
<ul>
<li>计数器的长度与块号字段的长度相同</li>
</ul>
</li>
<li><p>计数器的使用及管理规则：</p>
<ul>
<li>新装入或替换的块，计数器清0，同组中其它块的计数器加1。</li>
<li>命中块的计数器清0，同组的其它计数器中，凡计数器的值小于命中块计数器原来值的加1，其余计数器不变。</li>
<li>需要替换时，在同组的所有计数器中选择计数值最大的计数器，它所对应的块被替换。</li>
</ul>
</li>
</ul>
<p><strong>LRU算法的优缺点</strong></p>
<ul>
<li>主要优点：<ul>
<li>命中率比较高，</li>
<li>能够比较正确地利用程序的局部性特点，</li>
<li>充分地利用历史上块地址流的分布情况，</li>
<li>是一种堆栈型算法，随着组内块数增加，命中率单调上升。</li>
</ul>
</li>
<li>主要缺点：<ul>
<li>控制逻辑复杂，因为增加了判断和处理是否命中的情况。</li>
</ul>
</li>
</ul>
<h5 id="比较对法"><a href="#比较对法" class="headerlink" title="比较对法"></a>比较对法</h5><ul>
<li>一个两态的触发器可以记录两个块之间的先后顺序，多个块之间的先后顺序可以用多个两态触发器组合来实现。</li>
<li>以三个块为例，分别称为块A、块B、块C，共有3种组合。AB，BC，AC。</li>
<li>用TAB表示B块比A块更久没有被访问。3个块有6种排列。TAB，TBC，TAC，TAB，TBC，TAC</li>
</ul>
<p><strong>表示方法</strong></p>
<p>表示块C最久没有被访问过，有两种可能 ：A，B，C或者B，A，C</p>
<p><img src="/imgs/ca/73.png" alt="image-20231212150950100"></p>
<p>表示块A最久没有被访问过，有两种可能 ： B，C，A或者C，B，A</p>
<p><img src="/imgs/ca/74.png" alt="image-20231212151020924"></p>
<p>表示块B最久没有被访问过，有两种可能 ： A，C，B或者C，A，B。</p>
<p><img src="/imgs/ca/75.png" alt="image-20231212151040379"></p>
<p>每组3个块的比较对法</p>
<p><img src="/imgs/ca/76.png" alt="image-20231212151118246"></p>
<p>每次访问之后要改变触发器的状态</p>
<ul>
<li>在访问块A之后：TAB＝1，TAC＝1，触发器TBC没有关联。</li>
<li>在访问块B之后：TAB＝0，TBC＝1，触发器TAC没有关联。</li>
<li>在访问块C之后：TAC＝0，TBC＝0，触发器TAB没有关联。</li>
</ul>
<p><strong>比较对法硬件需求量计算</strong></p>
<p>需要的触发器个数为：$C_{G_b}^2&#x3D;\frac{G_b\cdot(G_b-1)}2$</p>
<p>与门个数为Gb</p>
<p>每个门的输入端个数为Gb-1</p>
<p>每组的块数比较多时, 采用分级办法实现。</p>
<ul>
<li>所分级数越多，节省器件越多，器件延迟越长。</li>
<li>实质上是用降低速度来换取节省器件。</li>
</ul>
<h5 id="堆栈法"><a href="#堆栈法" class="headerlink" title="堆栈法"></a>堆栈法</h5><p>堆栈法的管理规则：</p>
<ul>
<li>把本次访问的块号与堆栈中保存的所有块号进行相联比较。</li>
<li>如果有相等的，则Cache命中。把本次访问块号从栈顶压入，堆栈内各单元中的块号依次往下移，直至与本次访问的块号相等的那个单元为止，再往下的单元直止栈底都不变。</li>
<li>如果没有相等的，则Cache块失效。本次访问的块号从栈顶压入，堆栈内各单元的块号依次往下移，直至栈底，栈底单元中的块号被移出堆栈，它就是要被替换的块号。</li>
</ul>
<p><img src="/imgs/ca/77.png" alt="image-20231212152416603"></p>
<p>每组4块的堆栈法逻辑图</p>
<p><img src="/imgs/ca/78.png" alt="image-20231212152457077"></p>
<ul>
<li>堆栈法的主要优点：<ul>
<li>块失效率比较低，因为它采用了LRU算法。</li>
<li>硬件实现相对比较简单。</li>
</ul>
</li>
<li>堆栈法的主要缺点：<ul>
<li>速度比较低，因为它需要进行相联比较。</li>
</ul>
</li>
<li>堆栈法与比较对法所用触发器的比例</li>
</ul>
<p>$$<br>\frac{G_b\cdot(G_b-1)}2:G_b\cdot\log_2G_b<br>$$</p>
<p>其中，Gb是Cache每一组的块数。</p>
<p>当Gb大于8时，堆栈法所用的器件明显少于比较对法。</p>
<p>Cache替换算法主要解决：</p>
<ul>
<li>记录每次访问的块号，可以用寄存器，计数器。</li>
<li>管理好所记录的块号，便于找出被替换的块号。</li>
<li>根据记录和管理的结果，采用时序逻辑判断哪个块号即将被替换。<ul>
<li>轮换法找出最早访问的块号。其他三种是找出最久没有访问过的块号。</li>
</ul>
</li>
</ul>
<h4 id="cache存储系统的加速比"><a href="#cache存储系统的加速比" class="headerlink" title="cache存储系统的加速比"></a>cache存储系统的加速比</h4><h5 id="加速比与命中率的关系"><a href="#加速比与命中率的关系" class="headerlink" title="加速比与命中率的关系"></a>加速比与命中率的关系</h5><p>Cache存储系统的加速比SP:<br>$$<br>S_p&#x3D;\frac{T_m}{T}&#x3D;\frac{T_m}{H\cdot T_c+(1-H)\cdot T_m}&#x3D;\frac{1}{(1-H)+H\cdot\frac{T_c}{T_m}})&#x3D;f(H,\frac{T_m}{T_c})<br>$$<br>其中：</p>
<ul>
<li>Tm为主存储器的访问周期，</li>
<li>Tc为Cache的访问周期，</li>
<li>T为Cache存储系统的等效访问周期，</li>
<li>H为命中率。</li>
</ul>
<p>提高加速比的最好途径是提高命中率</p>
<p>加速比 SP 能够接近于期望值是$S_{pmax}&#x3D;\frac{T_m}{T_c}$</p>
<p><img src="/imgs/ca/79.png" alt="image-20231212152925572"></p>
<h5 id="Cache命中率与容量的关系"><a href="#Cache命中率与容量的关系" class="headerlink" title="Cache命中率与容量的关系"></a>Cache命中率与容量的关系</h5><p>Cache的命中率随它的容量的增加而提高。</p>
<p>关系曲线近似表示为$H&#x3D;1-\frac{1}{\sqrt S}$</p>
<p><img src="/imgs/ca/80.png" alt="image-20231212153104732"></p>
<h5 id="Cache命中率与块大小的关系"><a href="#Cache命中率与块大小的关系" class="headerlink" title="Cache命中率与块大小的关系"></a>Cache命中率与块大小的关系</h5><ul>
<li>在组相联方式中, 块大小对命中率非常敏感。</li>
<li>块很小时，命中率很低。</li>
<li>随着块大小增加命中率也增加, 有一个极大值。</li>
<li>当块非常大时, 进入Cache中的数据可能无用。</li>
<li>当块大小等于Cache容量时, 命中率将趋近零。</li>
</ul>
<p><img src="/imgs/ca/81.png" alt="image-20231212153144404"></p>
<h5 id="Cache命中率与组数的关系"><a href="#Cache命中率与组数的关系" class="headerlink" title="Cache命中率与组数的关系"></a>Cache命中率与组数的关系</h5><ul>
<li>在组相联方式中, 组数对命中率的影响很明显。</li>
<li>随着组数的增加，Cache的命中率要降低。</li>
<li>当组数不太大时(小于512), 命中率的降低很少。</li>
<li>当组数超过一定数量时, 命中率的下降非常快。</li>
</ul>
<h4 id="cache的一致性问题"><a href="#cache的一致性问题" class="headerlink" title="cache的一致性问题"></a>cache的一致性问题</h4><p>正常情况下， Cache内容该是主存内容的部分副本，但有时会造成主存和Cache的内容不一致。造成Cache与主存的不一致的原因：</p>
<ol>
<li>由于CPU写Cache，没有立即写主存</li>
<li>由于IO处理机或IO设备写主存</li>
</ol>
<p><img src="/imgs/ca/82.png" alt="image-20231212153249906"></p>
<h5 id="Cache的更新算法"><a href="#Cache的更新算法" class="headerlink" title="Cache的更新算法"></a>Cache的更新算法</h5><ol>
<li>写直达法，写通过法，WT(Write-through)<ul>
<li>CPU的数据写入Cache时，同时也写入主存。</li>
</ul>
</li>
<li>写回法，抵触修改法，WB(Write-Back)<ul>
<li>CPU的数据只写入Cache，不写入主存，仅当替换时，才把修改过的Cache块写回主存。</li>
</ul>
</li>
</ol>
<p>写回法与写直达法的优缺点比较</p>
<ul>
<li>可靠性，写直达法优于写回法。<ul>
<li>写直达法能够始终保证Cache是主存的副本。</li>
<li>如果Cache发生错误，可以从主存得到纠正。</li>
</ul>
</li>
<li>与主存的通信量，写回法少于写直达法。<ul>
<li>对于写回法：<ul>
<li>大多数操作只需要写Cache，不需要写主存。</li>
<li>当发生块失效时，可能要写一个块到主存。</li>
<li>即使是读操作，也可能要写一个块到主存。</li>
</ul>
</li>
<li>对于写直达法：<ul>
<li>每次写操作，必须写、且只写一个字到主存。</li>
<li>实际上：<ul>
<li>写直达法的写次数很多、每次只写一个字；</li>
<li>写回法是的写次数很少、每次要写一个块。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>控制的复杂性, 写直达法比写回法简单。<ul>
<li>对于写回法：<ul>
<li>要为每块设置一个修改位，而且要对修改位进行管理；</li>
<li>为了保证Cache的正确性，通常要采用比较复杂的校验方式或校正方式。</li>
</ul>
</li>
<li>对于写直达法：<ul>
<li>不需要设置修改位；</li>
<li>只需要采用简单的奇偶校验即可。由于Cache始终是主存的副本，Cache一旦有错误可以从主存得到纠正。</li>
</ul>
</li>
</ul>
</li>
<li>硬件实现的代价, 写回法要比写直达法好。<ul>
<li>对于写直达法：<ul>
<li>为了缩短写Cache流水段的时间，通常要设置一个小容量的高速寄存器堆（后行写数缓冲站），每个存储单元要有数据、地址和控制状态等3部分组成。</li>
<li>每次写主存时，首先把写主存的数据和地址写到高速寄存器堆中。</li>
<li>每次读主存时，要首先判断所读数据是否在这个高速寄存器堆中。</li>
</ul>
</li>
<li>写回法不需要设置高速缓冲寄存器堆。</li>
</ul>
</li>
</ul>
<h5 id="写cache的两种方法"><a href="#写cache的两种方法" class="headerlink" title="写cache的两种方法"></a>写cache的两种方法</h5><ul>
<li>不按写分配法：<ul>
<li>在写Cache不命中时，只把所要写的字写入主存。</li>
<li>写直达法中采用不按写分配法</li>
</ul>
</li>
<li>按写分配法：<ul>
<li>在写Cache不命中时，还把一个块从主存读入Cache。</li>
<li>写回法中采用按写分配法</li>
</ul>
</li>
</ul>
<h5 id="解决cache与主存不一致的不要办法"><a href="#解决cache与主存不一致的不要办法" class="headerlink" title="解决cache与主存不一致的不要办法"></a>解决cache与主存不一致的不要办法</h5><ol>
<li>共享Cache法。能根本解决Cache不一致，共享Cache可能成为访问的瓶颈，硬件复杂。</li>
<li>作废法。当某一处理机写局部Cache时，同时作废其他处理机的局部Cache。</li>
<li>播写法。把写Cache的内容和地址放到公共总线上，各局部Cache随时监听公共总线。</li>
<li>目录表法。在目录表中存放Cache一致性的全部信息。</li>
<li>禁止共享信息放在局部Cache中。</li>
</ol>
<h4 id="cache的预取算法"><a href="#cache的预取算法" class="headerlink" title="cache的预取算法"></a>cache的预取算法</h4><ol>
<li>按需取。当出现Cache不命中时，才把需要的一个块取到Cache中。</li>
<li>恒预取。无论Cache是否命中，都把下一块取到Cache中。</li>
<li>不命中预取。当出现Cache不命中，把本块和下一块都取到Cache中。</li>
</ol>
<p>主要考虑因素：</p>
<ul>
<li>命中率是否提高，Cache与主存间通信量。</li>
<li>恒预取能使Cache不命中率降低75～85％。</li>
<li>不命中预取能使Cache不命中率降低30～40％。</li>
</ul>
<h4 id="cache性能优化"><a href="#cache性能优化" class="headerlink" title="cache性能优化"></a>cache性能优化</h4><h5 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h5><ul>
<li>Hit rate: fraction found in that level<ul>
<li>So high that usually talk about Miss rate</li>
<li>Miss rate fallacy: as MIPS to CPU performance,</li>
</ul>
</li>
<li>Average memory-access time 	&#x3D; Hit time + Miss rate x Miss penalty (ns)</li>
<li>Miss penalty: time to replace a block from lower level, including time to replace in CPU<ul>
<li>access time to lower level &#x3D; f(latency to lower level)</li>
<li>transfer time: time to transfer block &#x3D;f(bandwidth)</li>
</ul>
</li>
<li>Average memory-access time (AMAT)	&#x3D; Hit time + Miss rate x Miss penalty</li>
<li>Cache optimizations<ul>
<li><strong>Reducing the miss rate</strong></li>
<li><strong>Reducing the miss penalty</strong></li>
<li><strong>Reducing the hit time</strong></li>
</ul>
</li>
</ul>
<p>降低未命中率</p>
<p>降低未命中惩罚</p>
<p>降低命中时间</p>
<h5 id="降低miss-penalty"><a href="#降低miss-penalty" class="headerlink" title="降低miss penalty"></a>降低miss penalty</h5><h6 id="Multi-level-Caches"><a href="#Multi-level-Caches" class="headerlink" title="Multi-level Caches"></a>Multi-level Caches</h6><h6 id="Critical-Word-First-and-Early-Restart"><a href="#Critical-Word-First-and-Early-Restart" class="headerlink" title="Critical Word First and Early Restart"></a>Critical Word First and Early Restart</h6><h6 id="Priority-to-Read-Misses-over-Writes"><a href="#Priority-to-Read-Misses-over-Writes" class="headerlink" title="Priority to Read Misses over Writes"></a>Priority to Read Misses over Writes</h6><h6 id="Merging-Write-Buffers"><a href="#Merging-Write-Buffers" class="headerlink" title="Merging Write Buffers"></a>Merging Write Buffers</h6><h6 id="Victim-Caches"><a href="#Victim-Caches" class="headerlink" title="Victim Caches"></a>Victim Caches</h6><h6 id="Sub-block-placement"><a href="#Sub-block-placement" class="headerlink" title="Sub-block placement"></a>Sub-block placement</h6><h5 id="降低miss-rates"><a href="#降低miss-rates" class="headerlink" title="降低miss rates"></a>降低miss rates</h5><h6 id="Larger-block-size"><a href="#Larger-block-size" class="headerlink" title="Larger block size"></a>Larger block size</h6><h6 id="Larger-Caches"><a href="#Larger-Caches" class="headerlink" title="Larger Caches"></a>Larger Caches</h6><h6 id="Higher-associativity"><a href="#Higher-associativity" class="headerlink" title="Higher associativity"></a>Higher associativity</h6><h6 id="Pseudo-associative-caches"><a href="#Pseudo-associative-caches" class="headerlink" title="Pseudo-associative caches"></a>Pseudo-associative caches</h6><h6 id="Compiler-optimizations"><a href="#Compiler-optimizations" class="headerlink" title="Compiler optimizations"></a>Compiler optimizations</h6><h5 id="Reducing-Cache-Miss-Penalty-or-Miss-Rate-via-Parallelism"><a href="#Reducing-Cache-Miss-Penalty-or-Miss-Rate-via-Parallelism" class="headerlink" title="Reducing Cache Miss Penalty or Miss Rate via Parallelism"></a>Reducing Cache Miss Penalty or Miss Rate via Parallelism</h5><h6 id="Nonblocking-Caches"><a href="#Nonblocking-Caches" class="headerlink" title="Nonblocking Caches"></a>Nonblocking Caches</h6><h6 id="Hardware-Prefetching"><a href="#Hardware-Prefetching" class="headerlink" title="Hardware Prefetching"></a>Hardware Prefetching</h6><h6 id="Compiler-controlled-Prefetching"><a href="#Compiler-controlled-Prefetching" class="headerlink" title="Compiler controlled Prefetching"></a>Compiler controlled Prefetching</h6><h5 id="降低hit-time"><a href="#降低hit-time" class="headerlink" title="降低hit time"></a>降低hit time</h5><h6 id="Small-and-Simple-Caches"><a href="#Small-and-Simple-Caches" class="headerlink" title="Small and Simple Caches"></a>Small and Simple Caches</h6><h6 id="Avoiding-address-Translation-during-Indexing-of-the-Cache"><a href="#Avoiding-address-Translation-during-Indexing-of-the-Cache" class="headerlink" title="Avoiding address Translation during Indexing of the Cache"></a>Avoiding address Translation during Indexing of the Cache</h6><h3 id="三级存储系统"><a href="#三级存储系统" class="headerlink" title="三级存储系统"></a>三级存储系统</h3><ul>
<li>虚拟存储系统和Cache存储系统可同时存在</li>
<li>存储系统可以有多种构成方法</li>
<li>不同的构成只是实现技术不同</li>
</ul>
<p><img src="/imgs/ca/83.png" alt="image-20231212163329127"></p>
<p><img src="/imgs/ca/84.png" alt="image-20231212163346679"></p>
<p><img src="/imgs/ca/85.png" alt="image-20231212163406247"></p>
<p>存储系统组织方式</p>
<ul>
<li><p>两个存储系统的组织方式：</p>
<p><img src="/imgs/ca/86.png" alt="image-20231212163538219"></p>
<ul>
<li>又称为：物理地址Cache存储系统。</li>
<li>目前的大部分处理机采用这种两级存储系统。</li>
</ul>
</li>
<li><p>一个存储系统组织方式：</p>
<p><img src="/imgs/ca/87.png" alt="image-20231212163554180"></p>
<ul>
<li>又称为：虚拟地址Cache存储系统。</li>
<li>如Intel公司的i860等处理机采用这种组织方式。</li>
</ul>
</li>
<li><p>全Cache系统：</p>
<ul>
<li>没有主存储器。</li>
<li>由Cache和磁盘组成存储系统。</li>
</ul>
</li>
</ul>
<h4 id="虚拟地址cache"><a href="#虚拟地址cache" class="headerlink" title="虚拟地址cache"></a>虚拟地址cache</h4><p>既有虚拟存储器又有Cache的系统：</p>
<ul>
<li>虚拟存储器采用位选择组相联方式</li>
<li>虚拟存储器中的一页等于主存储器的一个区</li>
<li>用虚拟地址中的虚页号访问快表<ul>
<li>如果快表命中，把块表中的主存区号E与快表中的主存实页号P进行比较。<ul>
<li>若比较结果相等，则Cache命中。读出Cache的块号b，并与B、b、W拼接得到Cache地址。</li>
<li>若Cache不命中，则用主存实页号P、及B和W拼接，得到主存实地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="全cache存储系统"><a href="#全cache存储系统" class="headerlink" title="全cache存储系统"></a>全cache存储系统</h4><ul>
<li><p>建立存储系统的目的：获得一个速度接近Cache，容量等于虚拟地址空间的存储器。</p>
<ul>
<li>这个存储器如何构成，具体分成几级来实现，只是具体的实现技术而已。</li>
<li>随着计算机硬件和软件技术的发展，存储系统的实现技术也在不断改变。</li>
<li>最直接最简单的方法：用一个速度很高，存储容量很大的存储器来实现。</li>
</ul>
</li>
<li><p>全Cache(all-Cache)是一种理想的存储系统。</p>
</li>
</ul>
<p><img src="/imgs/ca/88.png" alt="image-20231212163724701"></p>
<p><strong>重点</strong></p>
<ol>
<li><p>存储系统的定义及主要性能计算。</p>
</li>
<li><p>并行存储器的工作原理。</p>
</li>
<li><p>虚拟存储系统的工作原理。</p>
</li>
<li><p>虚拟存储器中加快地址变换的方法。</p>
</li>
<li><p>虚拟存储系统的页面替换算法。</p>
</li>
<li><p>Cache存储系统的地址映象及变换方法。</p>
</li>
<li><p>Cache存储系统的替换算法。</p>
</li>
<li><p>Cache存储系统的加速比。</p>
</li>
</ol>
<h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><h3 id="输入输出原理"><a href="#输入输出原理" class="headerlink" title="输入输出原理"></a>输入输出原理</h3><p>通常把处理机与主存储器之外的部分统称为输入输出系统，包括<strong>输入输出设备</strong>、<strong>输入输出接口</strong>和输入输出软件等。<br>实际上，运算器、控制器、主存储器和总线等也要通过输入输出系统来管理。</p>
<h4 id="输入输出系统的特点"><a href="#输入输出系统的特点" class="headerlink" title="输入输出系统的特点"></a>输入输出系统的特点</h4><ul>
<li>输入输出系统是处理机与外界进行数据交换的通道。</li>
<li>输入输出系统是计算机系统中最具多样性和复杂性的部分。</li>
<li>输入输出系统涉及到机、光、电、磁、声、自动控制等多种学科。</li>
<li>输入输出系统最典型地反映着硬件与软件的相互结合。</li>
<li>输入输出系统的复杂性隐藏在系统软件中，用户无需了解输入输出设备的具体细节。</li>
</ul>
<p><img src="/imgs/ca/94.png" alt="image-20231214190443537"></p>
<h5 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h5><p>采用<strong>自治控制</strong>的方法</p>
<ul>
<li>输入输出设备通常不使用统一的中央时钟，各个设备按照自己的时钟工作，但又要在某些时刻接受处理机的控制。</li>
<li>处理机与外围设备之间，外围设备与外围设备之间能并行工作</li>
</ul>
<h5 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h5><p>采用<strong>层次结构</strong>的方法</p>
<ul>
<li>对于一般输入输出设备,如果处理机提供的服务不及时，可能丢失数据，或造成外围设备工作的错误。</li>
<li>对于实时控制计算机系统，如果处理机提供的服务不及时，可能造成巨大的损失，甚至造成人身伤害。</li>
<li>对于处理机本身的硬件或软件错误：如电源故障、数据校验错、页面失效、非法指令、地址越界等，处理机必须及时处理。</li>
<li>对不同类型的设备，必须具有与设备相配合的多种工作方式。</li>
</ul>
<h5 id="设备无关性"><a href="#设备无关性" class="headerlink" title="设备无关性"></a>设备无关性</h5><p>采用<strong>分类处理</strong>的方法</p>
<ul>
<li>独立于具体设备的标准接口。例如，串行接口、并行接口、SCSI（Small Computer System Interface）接口等。</li>
<li>计算机系统的使用者，在需要更换外围设备时，各种不同型号，不同生产厂家的设备都可以直接通过标准接口与计算机系统连接。</li>
<li>处理机采用统一的硬件和软件对品种繁多的设备进行管理。</li>
<li>某些计算机系统已经实现了即插即用技术。</li>
</ul>
<h4 id="输入输出系统的组织方式"><a href="#输入输出系统的组织方式" class="headerlink" title="输入输出系统的组织方式"></a>输入输出系统的组织方式</h4><h5 id="自治控制"><a href="#自治控制" class="headerlink" title="自治控制"></a>自治控制</h5><p>输入输出系统是独立于CPU之外的自治系统处理机与外围设备之间要有恰当的分工</p>
<h5 id="层次组织"><a href="#层次组织" class="headerlink" title="层次组织"></a>层次组织</h5><p><img src="/imgs/ca/95.png" alt="image-20231214190731398"></p>
<ul>
<li>最内层是输入输出处理机、输入输出通道等。</li>
<li>中间层是标准接口。</li>
<li>标准接口通过设备控制器与输入输出设备连接。</li>
</ul>
<h5 id="分类组织"><a href="#分类组织" class="headerlink" title="分类组织"></a>分类组织</h5><ul>
<li>面向字符的设备，如字符终端、打字机等</li>
<li>面向数据块的设备，如磁盘、磁带、光盘等</li>
</ul>
<h4 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h4><h5 id="程序控制输入输出方式"><a href="#程序控制输入输出方式" class="headerlink" title="程序控制输入输出方式"></a>程序控制输入输出方式</h5><p>状态驱动输入输出方式、应答输入输出方式、查询输入输出方式、条件驱动输入输出方式</p>
<p>程序控制输入输出方式有<strong>4个特点</strong></p>
<ol>
<li>何时对何设备进行输入输出操作受CPU控制。</li>
<li>CPU要通过指令对设备进行测试才能知道设备的工作状态。<br>如：闲、准备就绪、忙碌等</li>
<li>数据的输入和输出都要经过CPU。</li>
<li>用于连接低速外围设备，如终端、打印机等。</li>
</ol>
<h5 id="中断输入输出方式"><a href="#中断输入输出方式" class="headerlink" title="中断输入输出方式"></a>中断输入输出方式</h5><p>当出现来自系统外部，机器内部，甚至处理机本身的任何例外的，或者虽然是事先安排的，但出现在现行程序的什么地方是事先不知道的事件时，CPU暂停执行现行程序，转去处理这些事件，等处理完成后再返回来继续执行原先的程序</p>
<p>特点</p>
<ol>
<li>CPU与外围设备能够并行工作。</li>
<li>能够处理例外事件。</li>
<li>数据的输入和输出都要经过CPU。</li>
<li>用于连接低速外围设备。</li>
</ol>
<h5 id="直接存储器访问方式DMA"><a href="#直接存储器访问方式DMA" class="headerlink" title="直接存储器访问方式DMA"></a>直接存储器访问方式DMA</h5><p>直接存储器访问方式(DMA：Direct Memory Access)，主要用来连接高速外围设备。如磁盘存储器，磁带存储器、光盘辅助存储器，行式打印机等。</p>
<p><img src="/imgs/ca/96.png" alt="image-20231214191057909"></p>
<p>特点</p>
<ol>
<li>外围设备的访问请求直接发往主存储器，数据的传送过程不需要CPU的干预。</li>
<li>全部用硬件实现，不需要做保存现场和恢复现场等工作。</li>
<li>DMA控制器复杂，需要设置数据寄存器、设备状态控制寄存器、主存地址寄存器、设备地址寄存器和数据交换个数计数器及控制逻辑等。</li>
<li>在DMA方式开始和结束时，需要处理机进行管理。</li>
</ol>
<p>工作流程：</p>
<ol>
<li>从设备读一个字节到DMA控制器中的数据缓冲寄存器中。</li>
<li>若一个字没有装配满，则返回到上面；若校验出错，则发中断申请；若一个字已装配满，则将数据送主存数据寄存器。</li>
<li>把主存地址送主存地址寄存器，并将主存地址增值。</li>
<li>把DMA控制器内的数据交换个数计数器减１。</li>
<li>若交换个数为0，则DMA数据传送过程结束，否则回到上面。</li>
</ol>
<p>目前使用的DMA方式实际上有如下三种</p>
<ol>
<li>周期窃取方式<ul>
<li>在每一条指令执行结束时，CPU测试有没有DMA服务申请。</li>
<li>借用CPU完成DMA工作流程。包括数据和主存地址的传送，交换个数计数器减1，主存地址的增值及一些测试判断等。</li>
<li>周期窃取方式的优点是硬件结构简单，比较容易实现。</li>
<li>缺点是在数据输入或输出过程种实际上占用了CPU的时间。</li>
</ul>
</li>
<li>直接存取方式<ul>
<li>整个工作流程全部用硬件完成。</li>
<li>优点与缺点正好与周期窃取方式相反。</li>
</ul>
</li>
<li>数据块传送方式<ul>
<li>在设备控制器中设置一个比较大的数据缓冲存储器。设备控制器与主存储器之间的数据交换以数据块为单位，并采用程序中断方式进行。</li>
<li>采用数据块传送方式的外围设备有软盘驱动器、行式打印机、激光打印机、卡片阅读机、绘图仪等。</li>
</ul>
</li>
</ol>
<h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><h4 id="中断源的组织"><a href="#中断源的组织" class="headerlink" title="中断源的组织"></a>中断源的组织</h4><ul>
<li>中断系统需要硬件和软件共同来实现。</li>
<li>引起中断的各种事件称为中断源。</li>
<li>中断系统的复杂性实际上主要是由中断源的多样性引起的。</li>
<li>中断源可以来自系统外部，也可以来自机器内部，甚至处理机本身。</li>
<li>中断可以是硬件引起的，也可以是软件引起的。</li>
<li>把各种各样的中断源分类、分级组织好，是中断系统的关键之一。</li>
</ul>
<h5 id="中断源的种类"><a href="#中断源的种类" class="headerlink" title="中断源的种类"></a>中断源的种类</h5><ol>
<li>由外围设备引起的中断。<ul>
<li>低速外围设备每传送一个字节申请一次中断；高速外围设备的前、后处理。</li>
</ul>
</li>
<li>由处理机本身产生的中断。<ul>
<li>如算术溢出，除数为零，数据校验错等。</li>
</ul>
</li>
<li>由存储器产生的中断。<ul>
<li>如地址越界、页面失效、访问存储器超时等。</li>
</ul>
</li>
<li>由控制器产生的中断。<ul>
<li>如非法指令、堆栈溢出、时间片到、切换到特权态。</li>
</ul>
</li>
<li>由总线产生的中断。<ul>
<li>输入输出总线出错,存储总线出错等。</li>
</ul>
</li>
<li>实时过程控制产生的中断。</li>
<li>实时钟的定时中断。</li>
<li>多处理机系统中，从其它处理机发送来的中断。</li>
<li>程序调试过程中，由断点产生的中断。</li>
<li>硬件故障中断</li>
<li>电源故障中断。</li>
</ol>
<h5 id="中断源的分类组织"><a href="#中断源的分类组织" class="headerlink" title="中断源的分类组织"></a>中断源的分类组织</h5><ul>
<li>中断源分类组织的目的：在响应中断后能尽快找到中断入口。</li>
<li>根据中断事件的紧迫程度，中断源工作速度、性质等进行分类</li>
<li>为每一类中断源分配一个硬件的中断入口，在进入这个入口之后，再通过软件找到具体的中断源。</li>
<li>可屏蔽中断与不可屏蔽中断，或称一般中断和异常中断。</li>
</ul>
<blockquote>
<p>以IBM为例，中断源分为6类：</p>
<ol>
<li>机器检验出错中断。由硬件或软件故障时产生。</li>
<li>程序性错误引起的中断。</li>
<li>访问管理程序中断。当用户程序执行访管指令引起的中断。</li>
<li>外部事件中断。</li>
<li>输入输出中断。</li>
<li>重新启动中断。处理机不能禁止这类中断</li>
</ol>
</blockquote>
<h5 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h5><ul>
<li>安排中断优先顺序主要由下列因素来决定：<ul>
<li>中断源的急迫性。</li>
<li>设备的工作速度。</li>
<li>数据恢复的难易程度。</li>
<li>要求处理机提供的服务量。</li>
</ul>
</li>
<li>中断优先级与中断服务顺序<ul>
<li>要求：响应速度快，灵活性好。</li>
<li>做法：由硬件排队器决定中断优先级，</li>
</ul>
</li>
<li>通过软件设置中断屏蔽码改变中断服务顺序。</li>
</ul>
<blockquote>
<p>在IBM 370系列机中，把7类中断分为5个中断优先级，从高到低分别是:</p>
<ol>
<li>紧急的机器检验错误引起的中断。</li>
<li>调用管理程序，程序性错误，可以抑制的机器检验错误引起的中断。</li>
<li>外部事件引起的中断。</li>
<li>外围设备的中断。</li>
<li>重新启动引起的中断。</li>
</ol>
</blockquote>
<blockquote>
<p>DEC公司的机器，其优先级从高到低分别是</p>
<ol>
<li>总线错误引起的中断</li>
<li>主存刷新中断</li>
<li>指令错误引起的中断</li>
<li>程序跟踪中断</li>
<li>电源掉电中断</li>
<li>在线停机中断</li>
<li>在线事件中断(如实时钟等)</li>
<li>外围设备中断</li>
<li>用户程序中断</li>
</ol>
</blockquote>
<h4 id="中断系统的软硬件分配"><a href="#中断系统的软硬件分配" class="headerlink" title="中断系统的软硬件分配"></a>中断系统的软硬件分配</h4><p>有些功能必须用硬件实现，有的功能必须用软件实现，而大部分功能既可以用硬件实现，也可以用软件实现。</p>
<p>恰当分配中断系统的软硬件功能，是中断系统最关键问题。</p>
<p>主要考虑的两个因素：</p>
<ul>
<li>中断响应时间：中断响应时间是一个非常重要的指标。</li>
<li>灵活性：硬件实现速度快，灵活性差；软件实现正好相反。</li>
</ul>
<h5 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h5><ul>
<li>现行指令结束，且没有更紧急的服务请求。</li>
<li>关CPU中断。</li>
<li><strong>保存断点</strong>，主要保存PC中的内容。（<strong>硬件</strong>）</li>
<li>撤消中断源的中断请求。</li>
<li>保存硬件现场，主要是PSW及SP等。</li>
<li>识别中断源。</li>
<li>改变设备的屏蔽状态。</li>
<li><strong>进入中断服务程序入口</strong>。（<strong>硬件</strong>）</li>
<li>保存软件现场，在中断服务程序中使用的通用寄存器等。</li>
<li>开CPU中断，可以响应更高级别的中断请求。</li>
<li><strong>中断服务</strong>，执行中断服务程序。（<strong>软件</strong>）</li>
<li>关CPU中断。</li>
<li>恢复软件现场。</li>
<li>恢复屏蔽状态。</li>
<li>恢复硬件现场。</li>
<li>开CPU中断。</li>
<li><strong>返回到中断点</strong>。（<strong>软件</strong>）</li>
</ul>
<p><strong>保存中断点</strong>和<strong>进入中断服务程序入口</strong>，这两个功能相当于执行一条转子程序指令，因为中断发生在现行程序的什么地方是不确定的，不能由程序员来安排。</p>
<p>返回到中断点，通过执行一条中断返回指令来实现。</p>
<p>中断服务必须用软件实现，因为是“程序中断方式”</p>
<h5 id="中断响应时间"><a href="#中断响应时间" class="headerlink" title="中断响应时间"></a>中断响应时间</h5><p>从中断源向处理机发出中断服务请求开始，到处理机开始执行这个中断源的中断服务程序时为止，这一段时间称为中断响应时间</p>
<p><strong>影响中断响应时间的因素</strong></p>
<ol>
<li>最长指令执行时间<ul>
<li>有些指令的执行时间很长，甚至无法预测。</li>
</ul>
</li>
<li>处理其它更紧急的任务所用时间<ul>
<li>如处理DMA请求等。</li>
</ul>
</li>
<li>从第一次关CPU中断到第一次开CPU中断所经历的时间<ul>
<li>中断系统的软件与硬件功能分配，主要就是要考虑这一段内要所的事情用软件来实现，还是用硬件来实现。</li>
</ul>
</li>
<li>通过软件找到中断服务程序入口所用时间<ul>
<li>主要是第1和第3两部分。其中，第1部分是指令系统设计时考虑的问题，在中断系统的设计中，主要考虑第3部分。</li>
</ul>
</li>
</ol>
<h4 id="中断源的识别方法"><a href="#中断源的识别方法" class="headerlink" title="中断源的识别方法"></a>中断源的识别方法</h4><h5 id="识别中断源的查询法"><a href="#识别中断源的查询法" class="headerlink" title="识别中断源的查询法"></a>识别中断源的查询法</h5><ul>
<li>所有中断源共用一条中断请求线</li>
<li>处理机响应中断后都进入同一个程序入口</li>
<li>用软件找出申请中断的中断源</li>
<li>主要优点：灵活性好。</li>
<li>主要缺点：速度慢。</li>
</ul>
<p><img src="/imgs/ca/97.png" alt="image-20231214193931096"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">INTR:	SKIP DZ, PRN  ；如果打印机DONE＝0，跳过下一条指令
JMP  PRINT    ；转入打印机的中断服务程序入口PRINT
SKIP DZ, KEY  ；测试键盘的DONE＝0？
JMP  KEYBORD  ；转入键盘的中断服务程序入口KEYBORD
SKIP DN, MNT  ；测试显示器的DONE＝1？
JMP  ERROR    ；所有中断源均没有请求中断服务
JMP  MONITOR  ；转显示器的中断服务程序入口MONITOR
PRINT: ……           ；打印机中断服务程序
RNTI          ；返回到中断点
KEYBORD: ……         ；键盘输入的中断服务程序
RNTI          ；返回到中断点
MONITOR: ……         ；显示器输出的中断服务程序
RNTI          ；返回到中断点
ERROR: ……           ；出错处理程序
RNTI          ；返回到中断点  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="软件排队链法"><a href="#软件排队链法" class="headerlink" title="软件排队链法"></a>软件排队链法</h5><ul>
<li>设置一个中断请求寄存器，每个中断源在其中占据一位，并且按照中断的优先级从高位到低的顺序排列。</li>
<li>所有中断源使用同一条公共的中断请求线，进入公共中断源服务程序入口，其过程与查询法相同。</li>
<li>在公共中断服务程序入口，用一条特殊指令读出中断请求寄存器中的内容，并根据读出的内容直接进入中断服务程序。</li>
<li>节省了用软件逐个寻找中断源的时间</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">inta R1;中断请求寄存器中的内容读入R1
sbt R1,R2;找到发出请求的最高级中断源,存入R2
jmp @tab(R2);转向中断服务程序入口
tab:dev1;最高级中断服务程序入口地址
dev2

devn;最低级中断服务程序入口地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="硬件排队链法"><a href="#硬件排队链法" class="headerlink" title="硬件排队链法"></a>硬件排队链法</h5><ul>
<li>用硬件排队器和编码器，在所有请求中断服务的中断源中，找出具有最高优先级的中断源。</li>
<li>设置一个中断请求寄存器，每个中断源在其中中占据一位。</li>
<li>所有中断源使用同一条公共的中断请求线，进入公共中断源服务程序入口。</li>
<li>转入公共的中断服务程序后，用一条特殊指令直接读到所有请求中断服务的中断源中具有最高优先级的中断源编号。</li>
<li>特点：识别中断源的速度更快</li>
</ul>
<p><img src="/imgs/ca/98.png" alt="image-20231214194412254"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">INTA R1      ;发出请求的最高级中断源送R1
JMP @VTAB(R1);转向中断源的中断服务程序入口
TAB:	DEV1         ;最高级中断服务程序入口地址
DEV2         ;第二级中断服务程序入口地址
     　……
DENn         ;最低级中断服务程序入口地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>硬件排队器和编码器</p>
<p><img src="/imgs/ca/99.png" alt="image-20231214194531879"></p>
<h5 id="中断向量法"><a href="#中断向量法" class="headerlink" title="中断向量法"></a>中断向量法</h5><ul>
<li>在主存储器的固定区域中开辟出一个专用的中断向量区。</li>
<li>用硬件排队器和编码器在所有请求中断服务的中断源中，产生具有最高优先级的中断源编号。</li>
<li>隐含执行上面方法中的两条识别中断源的指令，直接通过硬件转向这个中断源的中断服务程序入口。</li>
<li>不需要进入公共中断服务程序，能够实现到中断程序的最快转移。</li>
</ul>
<p>上面的2、3、4三种识别中断源的方法都属于串行排队链法</p>
<p>串行排队链法的优点：</p>
<ul>
<li>识别中断源的速度比较快，特别是中断向量法。</li>
<li>实现比较简单，中断源与处理机的连线很少。</li>
</ul>
<p>串行排队链法的缺点：</p>
<ul>
<li>灵活性比较差，中断优先级是由硬件固定。不能由程序员通过软件修改。</li>
<li>可靠性比较差，排队链串行分布在各个中断源中。一个出错，都出错。</li>
</ul>
<h5 id="独立请求法"><a href="#独立请求法" class="headerlink" title="独立请求法"></a>独立请求法</h5><ul>
<li>各个中断源使用自己独立的中断请求线。每一根中断请求线在处理机中有固定的或可编程的中断优先级。</li>
<li>如果同时有多个中断源请求中断服务，通过仲裁线路立即选择具有最高优先级的中断源，并向它发出中断响应信号INIT，处理机就可以立即转入这个中断源的中断服务程序。</li>
<li>独立请求法实际上是把分布在各个中断源内的串行排队器都集中到处理机中，从而克服了串行排队链法可靠性差的缺点，但灵活性差的缺点仍然存在。</li>
</ul>
<p><img src="/imgs/ca/100.png" alt="image-20231214194706297"></p>
<p>识别中断源的分组独立请求法（应用于中断源很多时）</p>
<ul>
<li>把独立请求法与串行排队链法结合起来。</li>
<li>中断源分组：组内采用串行排队链法，组间采用独立请求法。</li>
</ul>
<p><img src="/imgs/ca/101.png" alt="image-20231214194745196"></p>
<h4 id="中断现场的保存和回复"><a href="#中断现场的保存和回复" class="headerlink" title="中断现场的保存和回复"></a>中断现场的保存和回复</h4><p>中断现场的保护和恢复分别是中断处理机过程开始和结束时必须执行的步骤，可以分为三类：</p>
<ol>
<li>程序计数器PC，必须由硬件来完成保存，可以保存在存储器固定单元或者堆栈。利用中断返回指令来恢复。</li>
<li>当前程序状态的有关信息，包括：处理机状态字、堆栈指针、基址寄存器、中断屏蔽码等<ul>
<li>保存与恢复方法有：主存固定区域，压入系统堆栈、交换处理机状态字。也可以采用软件在中断服务程序中保存和恢复。</li>
</ul>
</li>
<li>软件现场：指在中断服务程序中被破坏的通用寄存器。一般采用软件来保存和恢复现场，指令系统给予适当支持。也有些处理机采用硬件来保存软件现场，如Sparc处理机。</li>
</ol>
<h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h4><h5 id="设置中断屏蔽用处"><a href="#设置中断屏蔽用处" class="headerlink" title="设置中断屏蔽用处"></a>设置中断屏蔽用处</h5><ol>
<li>在中断优先级由硬件确定了的情况下，改变中断源的中断服务顺序。</li>
<li>决定设备是否采用中断方式工作。</li>
<li>在多处理机系统中，把外围设备的服务工作分配到不同的处理机中。</li>
</ol>
<h5 id="中断屏蔽的实现方法"><a href="#中断屏蔽的实现方法" class="headerlink" title="中断屏蔽的实现方法"></a>中断屏蔽的实现方法</h5><ol>
<li>每级中断源设置一个中断屏蔽位。<ul>
<li>中断屏蔽位可以分部在各个中断源中，也可以集中到处理机，如放到处理机的状态字中。</li>
</ul>
</li>
<li>改变处理机优先级<ul>
<li>中断优先级不仅在处理机相应中断源的中断服务请求时使用，而且为每个中断的中断服务程序也赋予同样的中断优先级。</li>
</ul>
</li>
</ol>
<h5 id="中断屏蔽位的方法和处理机优先级法两种方法的差别"><a href="#中断屏蔽位的方法和处理机优先级法两种方法的差别" class="headerlink" title="中断屏蔽位的方法和处理机优先级法两种方法的差别"></a>中断屏蔽位的方法和处理机优先级法两种方法的差别</h5><ol>
<li>两者使用的概念不同。<ul>
<li>前者使用中断屏蔽，</li>
<li>后者使用中断优先级。</li>
</ul>
</li>
<li>需要屏蔽码的位数不同。<ul>
<li>前者所需要的屏蔽位数比较多，</li>
<li>n：log2n</li>
</ul>
</li>
<li>可屏蔽的中断源数量和种类不同。<ul>
<li>前者可以任意屏蔽掉一个或几个中断源，</li>
<li>后者只能屏蔽掉比某一个优先级低的中断源。</li>
</ul>
</li>
</ol>
<h3 id="通道处理机"><a href="#通道处理机" class="headerlink" title="通道处理机"></a>通道处理机</h3><p>通道处理机的作用主要是在外围设备种类、数量很多的情况下把外围设备的管理工作从CPU中分离出来</p>
<p>处理机与外部设备的连接方式</p>
<ul>
<li>直接连接</li>
<li>通道处理机</li>
<li>输入输出处理机</li>
</ul>
<h4 id="通道的作用和功能"><a href="#通道的作用和功能" class="headerlink" title="通道的作用和功能"></a>通道的作用和功能</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>通道处理机能够负担外围设备的大部分输入输出工作，包括管理所有按字节传输方式工作的低速和中速外围设备，按数据块传输方式工作的高速设备。对DMA接口初始化，设备故障的检测和处理。</li>
<li>可以看作一台能够执行有限输入输出指令，并且能够被多台外围设备共享的小型DMA专用处理机。</li>
<li>在一台大型计算机系统中可以有多个通道，一个通道可以连接多个设备控制器，一个设备控制器又可以管理一台或者多台外围设备。形成典型的I&#x2F;O系统四层结构。</li>
</ul>
<h5 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h5><ol>
<li>接受CPU发来的指令，选择一台指定的外围设备与通道相连接。</li>
<li>执行CPU为通道组织的通道程序。</li>
<li>管理外围设备的有关地址。</li>
<li>管理主存缓冲区的地址。</li>
<li>控制外围设备与主存缓冲区之间数据交换的个数。</li>
<li>指定传送工作结束时要进行的操作。</li>
<li>检查外围设备的工作状态，是正常或故障。</li>
<li>在数据传输过程中完成必要的格式变换。</li>
</ol>
<h4 id="通道的工作过程"><a href="#通道的工作过程" class="headerlink" title="通道的工作过程"></a>通道的工作过程</h4><ol>
<li>在用户程序中使用访管指令进入管理程序，由CPU通过管理程序组织一个通道程序，并启动通道。</li>
<li>通道处理机执行通道程序，完成指定的数据输入输出工作。</li>
<li>通道程序结束后再次调用管理程序进行处理。</li>
</ol>
<p>每完成一次输入输出工作，CPU只需要两次调用管理程序</p>
<p><img src="/imgs/ca/102.png" alt="image-20231214195837317"></p>
<p><img src="/imgs/ca/103.png" alt="image-20231214195856661"></p>
<p><img src="/imgs/ca/104.png" alt="image-20231214195910121"></p>
<p><img src="/imgs/ca/105.png" alt="image-20231214195926524"></p>
<h4 id="通道的种类"><a href="#通道的种类" class="headerlink" title="通道的种类"></a>通道的种类</h4><p><img src="/imgs/ca/106.png" alt="image-20231214195950798"></p>
<h5 id="字节多路通道"><a href="#字节多路通道" class="headerlink" title="字节多路通道"></a>字节多路通道</h5><p><img src="/imgs/ca/107.png" alt="image-20231214200045830"></p>
<ul>
<li><p>为多台低中速的外围设备服务。</p>
</li>
<li><p>有多个子通道，每个子通道连接一个控制器。</p>
</li>
<li><p>字节交叉方式：可以有不同的工作方式，连接在通道上的各个设备轮流占有一个时间片传输字节，或者，不同设备在它所分得的时间片内与通道在逻辑上建立不同的传输连接。</p>
</li>
<li><p>成组方式：允许一个设备占用通道较长时间传输一组数据，或者设备与通道的连接可以根据需要维持到一组数据传输完成。</p>
</li>
<li><p>两种方式自动转换。通过超时机制控制。</p>
</li>
</ul>
<h5 id="选择通道"><a href="#选择通道" class="headerlink" title="选择通道"></a>选择通道</h5><p><img src="/imgs/ca/108.png" alt="image-20231214200305811"></p>
<ul>
<li>为高速外围设备服务</li>
<li>只有一个以成组方式工作的子通道</li>
<li>高速外围设备必须设置专门通道在一段时间单独为一台外围设备服务，不同时间可以选择不同设备。一旦选中，通道进入忙状态。直至数据传输结束。</li>
<li>只有一套完整硬件，逐个为物理连接的几台高速设备服务。</li>
</ul>
<h5 id="数组多路通道"><a href="#数组多路通道" class="headerlink" title="数组多路通道"></a>数组多路通道</h5><ul>
<li>字节多路通道和选择通道的结合。</li>
<li>每次为一台高速设备传送一个数据块，并轮流为多台外围设备服务。</li>
<li>从磁盘存储器读出文件的的过程分为三步：<ol>
<li>定位</li>
<li>找扇区</li>
<li>读出数据</li>
</ol>
</li>
<li>数组多路通道的实际工作方式：<ul>
<li>在为一台高速设备传送数据的同时，有多台高速设备可以在定位或者在找扇区。</li>
</ul>
</li>
<li>与选择通道相比，数组多路通道的数据传输率和通道的硬件利用都很高，控制硬件的复杂度也高。</li>
</ul>
<h4 id="通道中的数据传送过程"><a href="#通道中的数据传送过程" class="headerlink" title="通道中的数据传送过程"></a>通道中的数据传送过程</h4><h5 id="字节多路通道的数据传送过程"><a href="#字节多路通道的数据传送过程" class="headerlink" title="字节多路通道的数据传送过程"></a>字节多路通道的数据传送过程</h5><p><img src="/imgs/ca/109.png" alt="image-20231214200454364"></p>
<h5 id="选择通道的数据传送过程"><a href="#选择通道的数据传送过程" class="headerlink" title="选择通道的数据传送过程"></a>选择通道的数据传送过程</h5><p><img src="/imgs/ca/110.png" alt="image-20231214200534173"></p>
<h5 id="数组多路通道的数据传送过程"><a href="#数组多路通道的数据传送过程" class="headerlink" title="数组多路通道的数据传送过程"></a>数组多路通道的数据传送过程</h5><p><img src="/imgs/ca/111.png" alt="image-20231214200555866"></p>
<h4 id="通道流量分析"><a href="#通道流量分析" class="headerlink" title="通道流量分析"></a>通道流量分析</h4><p>通道流量：</p>
<p>单位时间内能够传送的最大数据量。又称通道吞吐率，通道数据传输率等。<br>通道最大流量：通道在满负荷工作状态下的流量。</p>
<h5 id="通道流量与连接在通道上的设备的数据传输率的关系"><a href="#通道流量与连接在通道上的设备的数据传输率的关系" class="headerlink" title="通道流量与连接在通道上的设备的数据传输率的关系"></a>通道流量与连接在通道上的设备的数据传输率的关系</h5><p>$$<br>f_{BYTE}&#x3D;\sum_{i&#x3D;1}^pf_i\f_{SELETE}&#x3D;\operatorname*{Max}<em>{i&#x3D;1}^pf_i\f</em>{BLOCK}&#x3D;\operatorname*{Max}_{i&#x3D;1}^pf_i<br>$$</p>
<h5 id="三种通道的最大流量计算公式"><a href="#三种通道的最大流量计算公式" class="headerlink" title="三种通道的最大流量计算公式"></a>三种通道的最大流量计算公式</h5><p>$$<br>\begin{aligned}<br>&amp;f_{MAX.BYTE}&#x3D;\frac{p\cdot n}{(T_S+T_D)\cdot p\cdot n}&#x3D;\frac{1}{T_S+T_D}\text{字节&#x2F;秒} \<br>&amp;\begin{aligned}f_{MAX.SELETE}&amp;&#x3D;\frac{p\cdot n}{(T_S&#x2F;n+T_D)\cdot p\cdot n}&#x3D;\frac{1}{T_S&#x2F;n+T_D}\text{字节&#x2F;秒}\end{aligned} \<br>&amp;f_{\textit{MAX BLOCK}} &#x3D; \frac { p \cdot n }{ ( T _ S &#x2F; k + T _ D ) \cdot p \cdot n }&#x3D;\frac1{T_S&#x2F;k+T_D}\text{字节&#x2F;秒}<br>\end{aligned}<br>$$</p>
<p>为保证通道不丢失数据，通道的实际流量应不大于通道最大流量<br>$$<br>f_{\mathrm{BYTE}}\le f_{\mathrm{MAX}:\mathrm{BYTE}}\ f_{\mathrm{SELETE}}\le f_{\mathrm{MAX}:\mathrm{SELETE}}\f_\text{BLOCK}\le f_{\mathrm{MAX}:\mathrm{BLOCK}}<br>$$</p>
<h3 id="输入输出处理机"><a href="#输入输出处理机" class="headerlink" title="输入输出处理机"></a>输入输出处理机</h3><p><img src="/imgs/ca/112.png" alt="image-20231214201217394"></p>
<h4 id="输入输出处理机的作用"><a href="#输入输出处理机的作用" class="headerlink" title="输入输出处理机的作用"></a>输入输出处理机的作用</h4><p>输入输出处理机除了能够完成通道处理机的全部功能之外，还具有如下功能：</p>
<ol>
<li>码制转换。</li>
<li>数据校验和校正。</li>
<li>故障处理。</li>
<li>文件管理。</li>
<li>诊断和显示系统状态。</li>
<li>处理人机对话。</li>
<li>连接网络或远程终端。</li>
</ol>
<ul>
<li>输入输出处理机还可以根据需要完成分配给它的其它任务，如数据库管理等。</li>
<li>除了具有数据的输入输出功能之外，还具有运算功能和程序控制等功能。</li>
<li>不仅能够执行输入输出指令，还能够执行算术逻辑指令和程序控制指令等，就象一般的处理机那样。</li>
</ul>
<h5 id="通道处理机存在的问题"><a href="#通道处理机存在的问题" class="headerlink" title="通道处理机存在的问题"></a>通道处理机存在的问题</h5><ol>
<li>每完成一次输入输出操作要两次中断CPU的现行程序。</li>
<li>通道处理机不能处理自身及输入输出设备的故障。</li>
<li>数据格式转换、码制转换、数据块检验等工作要CPU完成。</li>
<li>文件管理、设备管理等工作，通道处理机本身无能为力。</li>
</ol>
<h5 id="输入输出处理机的多种组织方式"><a href="#输入输出处理机的多种组织方式" class="headerlink" title="输入输出处理机的多种组织方式"></a>输入输出处理机的多种组织方式</h5><ol>
<li>多个输入输出处理机从功能上分工。</li>
<li>以输入输出处理机作为主处理机。</li>
<li>采用与主处理机相同型号的处理机作为输入输出处理机。</li>
<li>采用廉价的微处理机来专门承担输入输出任务。</li>
</ol>
<h4 id="输入输出处理机的种类"><a href="#输入输出处理机的种类" class="headerlink" title="输入输出处理机的种类"></a>输入输出处理机的种类</h4><h5 id="根据是否共享主存储器"><a href="#根据是否共享主存储器" class="headerlink" title="根据是否共享主存储器"></a>根据是否共享主存储器</h5><ol>
<li>共享主存储器的输入输出处理机。<br>CDC公司的CYBER，Texas公司的ASC，</li>
<li>不共享主存储器的输入输出处理机。<br>STAT-100巨型机</li>
</ol>
<h5 id="根据运算部件和指令控制部件是否共享"><a href="#根据运算部件和指令控制部件是否共享" class="headerlink" title="根据运算部件和指令控制部件是否共享"></a>根据运算部件和指令控制部件是否共享</h5><ol>
<li>合用同一个运算部件和指令控制部件。<br>造价低，控制复杂。如CDC-CYBER和ASC</li>
<li>独立运算部件和指令控制部件。<br>独立运算部件和指令控制部件已经成为主流。<br>如B-6700大型机和STAT-100巨型机等。</li>
</ol>
<h4 id="输入输出处理机实例"><a href="#输入输出处理机实例" class="headerlink" title="输入输出处理机实例"></a>输入输出处理机实例</h4><p><img src="/imgs/ca/113.png" alt="image-20231214201444120"></p>
<p><strong>重点</strong></p>
<ol>
<li>了解三种基本输入输出方式的原理及特点。</li>
<li>中断系统中的软硬件功能分配。</li>
<li>中断优先级和中断屏蔽的原理及方法。</li>
<li>通道中的数据传送过程与流量分析。</li>
<li>输入输出处理机的作用及种类。</li>
</ol>
<h2 id="scalar-processor"><a href="#scalar-processor" class="headerlink" title="scalar processor"></a>scalar processor</h2><p>只有标量数据表示和标量指令系统的处理机称为标量处理机<br>提高指令执行速度的主要途径</p>
<ol>
<li>提高处理机的工作主频</li>
<li>采用更好的算法和设计更好的功能部件</li>
<li>采用指令级并行技术</li>
</ol>
<p>三种指令级并行处理机：</p>
<ol>
<li>流水线处理机和超流水线(Super-pipelining)处理机</li>
<li>超标量(Superscalar)处理机</li>
<li>超长指令字(VLIW:  Very Long Instruction Word)处理机</li>
</ol>
<h3 id="流水线原理"><a href="#流水线原理" class="headerlink" title="流水线原理"></a>流水线原理</h3><p>计算机的各个部分几乎都可以采用:</p>
<ol>
<li>指令的执行过程可以采用流水线，称为指令流水线。</li>
<li>运算器中的操作部件，如浮点加法器、浮点乘法器等可以采用流水线，称为操作部件流水线。</li>
<li>访问主存的部件可以采用访存部件流水线。多个计算机之间，通过存储器连接，也可以采用流水线，称为宏流水线。</li>
</ol>
<h4 id="指令的重叠执行方式"><a href="#指令的重叠执行方式" class="headerlink" title="指令的重叠执行方式"></a>指令的重叠执行方式</h4><h5 id="顺序执行方式"><a href="#顺序执行方式" class="headerlink" title="顺序执行方式"></a>顺序执行方式</h5><p><img src="/imgs/ca/90.png" alt="image-20231212165551223"></p>
<p>一条指令的执行过程：取指令-&gt;分析-&gt;执行</p>
<p>执行n条指令所用的时间为<br>$$<br>T&#x3D;\sum_{i&#x3D;1}^n(t_{\text{ 取指令 }i}+t_{\text{分析 }i}+t_{\text{执行 }i})<br>$$</p>
<ul>
<li>如每段时间都为t，则执行n条指令所用的时间为：T&#x3D;3nt</li>
<li>主要优点：控制简单，节省设备。</li>
<li>主要缺点：执行指令的速度慢，功能部件的利用率很低。</li>
</ul>
<p>重叠（Overlap）：在两条相近指令的解释过程中，某些不同解释阶段在时间上存在重叠部分。包括一次重叠、先行控制技术和多操作部件并行。 </p>
<p>一次重叠：把取指令操作隐含在分析、执行指令过程中，则在任何时候只允许上条指令“执行”与下条指令“分析”相重叠。T&#x3D;（n+1）×t </p>
<p>若各段时间不等时，有实际执行时间：<br>$$<br>T&#x3D;t_{\text{分}1}+\sum_{i&#x3D;2}^{n}[\max{t_{\text{分}i},t_{\text{执}i-1}}]+t_{\text{执}n}<br>$$</p>
<h5 id="一次重叠执行方式-一种最简单的流水线方式"><a href="#一次重叠执行方式-一种最简单的流水线方式" class="headerlink" title="一次重叠执行方式(一种最简单的流水线方式)"></a>一次重叠执行方式(一种最简单的流水线方式)</h5><p><img src="/imgs/ca/91.png" alt="image-20231214184707805"></p>
<p>如果两个过程的时间相等，则执行n条指令的时间为：$T&#x3D;(1+2n)t$</p>
<p>主要优点：   </p>
<ul>
<li>指令的执行时间缩短   </li>
<li>功能部件的利用率明显提高</li>
</ul>
<p>主要缺点：    </p>
<ul>
<li>需要增加一些硬件    </li>
<li>控制过程稍复杂</li>
</ul>
<h5 id="二次重叠执行方式"><a href="#二次重叠执行方式" class="headerlink" title="二次重叠执行方式"></a>二次重叠执行方式</h5><p>把取第k+1条指令提前到分析第k条指令同时执行</p>
<p>如果三个过程的时间相等，执行n条指令的时间为$T&#x3D;(2+n)t$</p>
<p>理想情况下同时有三条指令在执行</p>
<p>处理机的结构要作比较大的改变，必须采用先行控制方式</p>
<p><img src="/imgs/ca/92.png" alt="image-20231214185015139"></p>
<p>采用二次重叠执行方式，必须解决两个问题：</p>
<ol>
<li><p>有独立的取指令部件、指令分析部件和指令执行部件</p>
<p>独立的控制器：存储控制器、指令控制器、运算控制器</p>
</li>
<li><p>要解决访问主存储器的冲突问题</p>
<p>取指令、分析指令、执行指令都可能要访问存储器</p>
</li>
</ol>
<p><img src="/imgs/ca/93.png" alt="image-20231214185150935"></p>
<p>先行控制执行时间:<br>$$<br>T_{\text{先行}} &#x3D; t _ {\text{分}1}+\sum_{i&#x3D;1}^nt_{\text{执}i}<br>$$<br>多操作部件并行：采用有多个功能部件的处理机，把ALU的多种功能分散到几个具有专门功能的部件中，这些功能部件可以并行工作，使指令流出速度大大提高。 </p>
<h3 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h3><ul>
<li><p>空间并行性</p>
<p>设置多个独立的操作部件</p>
<p>多操作部件处理机</p>
<p>超标量处理机</p>
</li>
<li><p>时间并行性</p>
<p>采用流水线技术。</p>
<p>不增加或只增加少量硬件就能使运算速度提高几倍流水线处理机</p>
<p>超流水线处理机</p>
</li>
</ul>
<h4 id="流水线的表示方法"><a href="#流水线的表示方法" class="headerlink" title="流水线的表示方法"></a>流水线的表示方法</h4><p>连接图、时空图、预约表，主要考虑前两种</p>
<h5 id="连接图"><a href="#连接图" class="headerlink" title="连接图"></a>连接图</h5><p><img src="/imgs/ca/114.png" alt="image-20231218152918849"></p>
<p>流水线的每一个阶段称为流水步、流水步骤、流水段、流水线阶段、流水功能段、功能段、流水级、流水节拍等。</p>
<p>一个流水阶段与另一个流水阶段相连形成流水线。指令从流水线一端进入，经过流水线的处理，从另一端流出</p>
<p>有些复杂指令 在执行阶段也采用流水线方式工作，称为操作流水线。</p>
<p>指令流水线</p>
<p><img src="/imgs/ca/115.png" alt="image-20231218153041344"></p>
<p>一般4至12个流水段，<strong>等于及大于8个流水段</strong>的称为<strong>超流水线处理机</strong></p>
<h5 id="时空图"><a href="#时空图" class="headerlink" title="时空图"></a>时空图</h5><p>采用“时空图”表示流水线的工作过程。在时空图中，横坐标表示时间，也就是输入到流水线中的各个任务在流水线中所经过的时间。当流水线中各个流水段的执行时间都相等时，横坐标被分割成相等长度的时间段。纵坐标表示空间，即流水线的每一个流水段 </p>
<p><img src="/imgs/ca/116.png" alt="image-20231218153257774"></p>
<p>一个浮点加法器流水线的时空图(由求阶差、对阶、尾数加和规格化4个流水段组成)</p>
<p><img src="/imgs/ca/117.png" alt="image-20231218153331196"></p>
<p><img src="/imgs/ca/118.png" alt="image-20231218153434563"></p>
<ul>
<li><strong>建立时间</strong>：在流水线开始时有一段流水线填入时间，使得流水线填满。</li>
<li><strong>正常流动时间</strong>：流水线正常工作，各功能段源源不断满载工作。</li>
<li><strong>排空时间</strong>：在流水线第一条指令结束时，其他指令还需要一段释放时间。</li>
</ul>
<p><img src="/imgs/ca/119.png" alt="image-20231218153534740"></p>
<h6 id="流水线的特点"><a href="#流水线的特点" class="headerlink" title="流水线的特点"></a>流水线的特点</h6><ol>
<li>流水一定重叠，比重叠更苛刻。</li>
<li>一条流水线通常有多个子过程。每个子过程称为流水线的“级”或“段”。其数目称为流水线的“深度”。</li>
<li>每段有专用功能部件，各部件顺序连接。</li>
<li>流水线有建立时间、正常满载时间、排空时间。另外，流水线需要有“通过&#x2F;装入时间”（第一个任务流出结果所需的时间），在此之后流水过程才进入稳定工作状态，每一个时钟周期（拍）流出一个结果。</li>
<li>流水线每一个功能段部件后面都要有一个缓冲寄存器，或称为锁存器，其作用是保存本流水段的结果，如图8所示。由于流水线中每一个流水段的延迟时间不可能绝对相等，再加上电路的延迟时间及时钟等都存在偏移，因此流水段之间传送任务时，必须通过锁存器。</li>
<li>流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流，这个时间一般为一个时钟周期（拍） 。要求流水线的时钟周期不能快于最慢的流水段。另一方面，执行时间长的一个流水段将成为整个流水线的瓶颈，此时流水线中的其他功能部件就不能发挥作用。因此瓶颈问题是流水线设计中必须解决的问题。</li>
<li>只有连续不断地提供同一种任务时才能发挥流水线的效率。例如，要使浮点加法器流水线充分发挥作用，需要连续提供浮点加法运算。只有流水线完全满载时，整个流水线的效率才能得到充分发挥。</li>
<li>给出指标如最大吞吐率，为满负载最佳指标。</li>
</ol>
<p><img src="/imgs/ca/120.png" alt="image-20231218153828898"></p>
<h6 id="流水的分级分类"><a href="#流水的分级分类" class="headerlink" title="流水的分级分类"></a>流水的分级分类</h6><p><strong>分级</strong>：（处理的级别分类）</p>
<ul>
<li>部件级：将复杂的算逻运算组成流水工作方式； </li>
<li>指令级：把一条指令解释过程分成多个子过程 ；</li>
<li>处理机级：每个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中</li>
</ul>
<p><strong>其他分类</strong></p>
<ul>
<li>功能：单功能流水线（如CRAY-1）、多功能流水线   （如TI-ASC）</li>
<li>工作方式：静态流水线、动态流水线</li>
<li>连接方式：线性、非线性</li>
<li>处理数据：标量流水、向量流水</li>
</ul>
<h4 id="建立流水线"><a href="#建立流水线" class="headerlink" title="建立流水线"></a>建立流水线</h4><ul>
<li>每一阶段添加锁存器<ul>
<li>在阶段转变时，一个锁存器存储临时的寄存器值</li>
<li>锁存器由时钟控制和阶段同步<ul>
<li>每个阶段同时将其寄存器信息传递到下一个阶段（在每个时钟脉冲的开头）</li>
<li>注意：锁存器会造成轻微延迟，因此时钟周期时间可能会略有延长</li>
</ul>
</li>
<li>锁存器由它们连接的阶段表示，例如 IF&#x2F;ID、ID&#x2F;EX</li>
</ul>
</li>
<li>利用锁存器、合适的时机和控制建立流水线<ul>
<li>每一阶段拥有硬件<ul>
<li>我们最多可以同时执行 5 条指令，其中每条指令都处于 5 个阶段之一</li>
</ul>
</li>
<li>需要5轮来完成任一指令<ul>
<li>如果没有流水线，一个存储或一个分支可以分 4 个阶段完成</li>
</ul>
</li>
<li>但是，由于重叠，我们可以在 5 个周期内完成多达 5 条指令</li>
</ul>
</li>
</ul>
<p>MIPS流水线</p>
<p><img src="/imgs/ca/121.png" alt="image-20231218155044290"></p>
<h4 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/447682231">关于流水线的三种冒险 - 知乎 (zhihu.com)</a></p>
<p>流水线中的<strong>相关</strong>是指相邻或相近的两条指令因存在某种关联，后一条指令不能在原指定的时钟周期开始执行。</p>
<h5 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h5><p>当指令在流水线中重叠执行时，后面的指令需要用到前面的指令的执行结果，而前面的指令尚未写回导致的冲突，称为数据冒险（也称为<strong>数据相关性</strong>）</p>
<p>相关性是程序的一个属性<br>相关性的存在表明存在潜在的危险，但实际危险和任何失速的长度是管道的属性<br>数据相关性的重要性</p>
<ol>
<li>表示危险的可能性</li>
<li>确定必须计算结果的顺序</li>
<li>设定了可以利用的并行度的上限</li>
</ol>
<p>用硬件方案以避免危险</p>
<ul>
<li>当管道中任何一对指令之间出现相关性以导致重叠时，就会发生数据危害</li>
<li>如果一对指令共享相同的寄存器或存储器位置，则可能会发生这种情况</li>
</ul>
<p>三种数据冒险</p>
<h6 id="RAW"><a href="#RAW" class="headerlink" title="RAW"></a>RAW</h6><p>先读后写</p>
<p>ADD R1, R2,R3<br>SUB R4, R5,R1</p>
<p>第一条指令写入R1</p>
<p>第二条指令读入R1</p>
<p>造成先读后写</p>
<p>有针对存储器RAW和针对寄存器RAW两种</p>
<p><img src="/imgs/ca/128.png" alt="image-20231218170612822"></p>
<ul>
<li><p>后推法：停顿后继指令的运行，直到前面指令结果生成；（不同拍之间）（R或M相关）</p>
</li>
<li><p>相关专用通路法：执行结果除写寄存器外，可直接送到ALU的操作数保存栈中。（R相关）</p>
<p><img src="/imgs/ca/129.png" alt="image-20231218170746842"></p>
</li>
<li><p>同一拍中，采用推后读、提前写的方法 （R或M相关），对整个流水线来说，一个时钟周期分成前后两部分，于是可将ID流水段中读寄存器堆的操作安排在后半周期，而将WB流水段中写寄存器堆的操作安排在前半周期。 </p>
</li>
<li><p>装载延迟则采用联锁硬件检测，并使流水线停顿，直到相关消除。（RISC特有）流水线中还采用一种装入延迟的方法解决数据相关冲突。</p>
<p><img src="/imgs/ca/130.png" alt="image-20231218170920635"></p>
<p><img src="/imgs/ca/131.png" alt="image-20231218170941365"></p>
</li>
<li><p>异步流动法：让流水线中相关指令的后续不相关指令先执行，自动消除相关。</p>
</li>
</ul>
<p>下面两种相关只有在异步流动流水线中才会产生。</p>
<p>使用动态调度方法检测和处理相关</p>
<h6 id="WAR"><a href="#WAR" class="headerlink" title="WAR"></a>WAR</h6><p>先写后读</p>
<p>ADD R3, R2,R1<br>SUB R1, R4,R5</p>
<p>第一条读入R1</p>
<p>第二条写入R1</p>
<p>可能会先写后读</p>
<p>这种相关仅出现在这样的流水线中：<br>有些指令是在流水线的后部读源操作数，而有些指令则是在流水线的前部写结果。</p>
<p>MIPS流水线中不会发生这种相关；读在先（ID），写在后（WB））<br>这种相关很少发生；因为流水线一般是先读操作数，后写结果）<br>复杂指令可能导致这种相关。</p>
<h6 id="WAW"><a href="#WAW" class="headerlink" title="WAW"></a>WAW</h6><p>ADD R1, R2,R3<br>SUB R1, R4,R5</p>
<p>第一条写入R1</p>
<p>第二条写入R1</p>
<p>先第二条后第一条写</p>
<p>这种相关仅出现在这样的流水线中：</p>
<ul>
<li>流水线中有多个段可以进行写操作</li>
<li>当某条指令在流水线中暂停时，允许其后的指令继续向前流动。</li>
</ul>
<p>MIPS整数流水线中不会发生这种相关   （仅在WB段进行写操作）</p>
<p><img src="/imgs/ca/127.png" alt="image-20231218170225781"></p>
<p>第二-第四条指令发生RAW</p>
<h5 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h5><p>当一条指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务，那就导致了结构冒险。（这里结构是指硬件当中的某个部件、也称为<strong>资源冲突</strong>）</p>
<h6 id="同时读写存储器"><a href="#同时读写存储器" class="headerlink" title="同时读写存储器"></a>同时读写存储器</h6><p>如果指令和数据放在同一个存储器中，则不能同时读存储器</p>
<p><img src="/imgs/ca/122.png"></p>
<p><strong>解决方案1</strong>：我们有一个方便又简便的方法，即流水线停顿（stall），产生空泡（bubble）</p>
<p><img src="/imgs/ca/126.png" alt="image-20231218163626685"></p>
<p><img src="/imgs/ca/123.png"></p>
<ul>
<li>Insert a “bubble” into the pipeline to prevent 2 writes at the same cycle</li>
</ul>
<p>当一条指令被暂停时，暂停在其后发射（流出）的指令，但继续执行在其前发射的指令。</p>
<p>虽然流水线停顿能用来解决各种冒险，但它的效率低下，应尽量避免</p>
<p><strong>解决方案2</strong>：Delay R-type’s Write by One Cycle延迟一轮</p>
<p>Mem stage is a NOP stage: nothing is being done</p>
<p><strong>解决方案3</strong>：在存储器中设置单独的指令高速缓存和数据高速缓存。（要强调的在计算机中主存储器也就是内存是统一存放指令和数据的，这也是冯诺依曼结构的要求，只是在CPU当中的一级高速缓存会采用指令和数据分别存放的方式）</p>
<p><img src="/imgs/ca/124.png"></p>
<h6 id="同时读写寄存器"><a href="#同时读写寄存器" class="headerlink" title="同时读写寄存器"></a>同时读写寄存器</h6><p><img src="/imgs/ca/125.png"></p>
<p>前半个周期写，后半个周期读，并且设置独立的读写端口</p>
<p>结构冒险在设计处理器时就考虑并解决</p>
<p>A structural hazard can always be avoided by adding more hardware to design</p>
<p>解决存储器争用冲突的其他办法是：</p>
<ul>
<li>如果指令和数据放在同一个存储器，可使用双端口存储器，其中一个端口存／取数据，另一个端口取指令。</li>
<li>设置两个存储器，其中一个作为数据存储器，另一个作为指令存储器。</li>
</ul>
<p>上述两种方案中，取指令和访问(存／取)数据可以并行进行，不会发生结构相关。</p>
<p>指令相关</p>
<p>由当前指令产生后续指令，即指令可修改引起。</p>
<p>解决办法：</p>
<p>指令不允许修改；</p>
<p>把新指令作为“执行”指令的操作数，使指令相关变成数据相关。</p>
<h5 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h5><p>如果现在想要执行哪条指令，是由之前指令的运行结果决定，而现在那条之前指令的结果还没产生，就导致了控制冒险（实际上就是riscv的跳转指令引起的，跳转指令要经过2个周期后才会出现<strong>跳转结果</strong>）</p>
<p>流水线的<strong>控制相关</strong>是因为程序执行转移类指令而引起的相关。转移类指令如无条件转移、条件转移、子程序调用、中断等，它们属于分支指令，执行中可能改变程序的方向，从而造成流水线断流。</p>
<p>数据相关影响到的仅仅是本条指令附近少数几条指令，所以称为<strong>局部相关</strong>。而控制相关影响的范围要大得多，它会引起程序执行方向的改变，使流水线损失更多的性能，所以称为<strong>全局相关</strong>。</p>
<p>控制相关会使流水线的连续流动受到破坏。当执行条件转移指令时，有两种可能结果：</p>
<ol>
<li>如发生转移，将程序计数器PC的内容改变成转移目标地址；</li>
<li>如不发生转移，只是将PC加上一个增量，指向下一条指令的地址</li>
</ol>
<p>控制相关无需保存</p>
<p>两个对程序正确性重要的是异常行为和数据流</p>
<p><img src="/imgs/ca/135.png" alt="image-20231218195631012"></p>
<h6 id="stall"><a href="#stall" class="headerlink" title="stall"></a>stall</h6><p><img src="/imgs/ca/136.png" alt="image-20231218195807046"></p>
<p>插入空泡</p>
<p>wait until decision is clear</p>
<p>直到分支干净</p>
<p>图中浪费两轮</p>
<h6 id="prediction"><a href="#prediction" class="headerlink" title="prediction"></a>prediction</h6><p><img src="/imgs/ca/137.png" alt="image-20231218200312807"></p>
<p><strong>加快和提前形成条件码</strong></p>
<p>对转移指令的条件码，部分可提前生成；</p>
<p>加快循环内条件码形成。</p>
<p>对一般条件转移指令，转移条件码是由上一条运算型指令产生的。对于大多数运算类指令，可以在实际运算之前或运算中间就能产生条件码，不必等到运算结束后。    </p>
<p>例如乘法或除法指令，两个源操作数符号相同，结果为正，符号相反，结果为负；两个源操作数中有一个为0，则乘积为0；被除数为0，则商为0；除数为0，则除法结果溢出。因此，只要比较两个操作数的符号或阶码，就能确定运算结果的正负号，是否为0，是否溢出。对加减法来说，运算结果的正负号，是否为0，是否溢出，也能提前得知。 </p>
<ul>
<li>预测分支失败<ul>
<li>流水线继续照常流动，就像没发生什么似的。</li>
<li>在知道分支结果之前，分支指令后的指令不能</li>
<li>改变机器状态，或者改变了之后能够回退。</li>
<li>若分支失败，则照常执行；否则，从转移目标处开始取指令执行。</li>
</ul>
</li>
<li>预测分支成功<ul>
<li>假设分支转移成功，并开始从分支目标地址处取指令执行。</li>
<li>起作用的前题：先知道分支目标地址，后知道分支是否成功。</li>
<li>对MIPS流水线没有任何好处。</li>
</ul>
</li>
</ul>
<h6 id="double-buffer"><a href="#double-buffer" class="headerlink" title="double buffer"></a>double buffer</h6><p>硬件上设置两个指令缓冲栈</p>
<p>当指令分析器分析到条件转移指令时，指令缓冲栈A按照转移不成功的方向预取指令，指令缓冲栈B按照转移成功的方向预取指令。当指令执行部件产生转移条件码时，如果转移不成功，则分析指令缓冲栈A中的指令；如果转移成功，则分析指令缓冲栈B中的指令，如图26(a)所示。</p>
<p><img src="/imgs/ca/138.png" alt="image-20231218200509021"></p>
<h6 id="delayed-branch"><a href="#delayed-branch" class="headerlink" title="delayed branch"></a>delayed branch</h6><p><img src="/imgs/ca/139.png" alt="image-20231218200536503"></p>
<p>延迟转移技术由编译程序重排指令序列来实现。其基本思想是从逻辑上“延长”转移指令的执行时间，即发生“转移成功” 时并不排空指令流水线，而是让紧跟在转移指令I之后已进入流水线的少数几条指令继续完成，如果这些指令是与转移指令I结果无关的有用指令，那么延迟损失时间就可以有效地利用。 </p>
<p>所有的顺序后继指令构成“延迟转移槽”指令(一般情况下，n＝1)。无论转移成功与否，流水线都会执行这些指令。具有“延迟转移槽”的流水线时空图如图所示。</p>
<p>从时空图27看出，基于“延迟转移”方法，无论转移成功与否，其流水线时空图均相同，流水线中均没有插入暂停周期，从而极大地降低了流水线的转移损失。事实上，处于转移延迟槽中的指令“填补”了流水线原来所必须插入的暂停周期。</p>
<p>在哪里获得指令来填充分支延迟槽?</p>
<ul>
<li>分支指令前</li>
<li>从目标地址:只有当分支采用时才有价值</li>
<li>从失败处:只有当分支不被采用时才有价值</li>
<li>取消分支允许更多的插槽被填充</li>
</ul>
<p>延迟分支方法对比</p>
<table>
<thead>
<tr>
<th>调 度  策 略</th>
<th>对调度的要求</th>
<th>什么情况下起作用？</th>
</tr>
</thead>
<tbody><tr>
<td>从  前 调 度</td>
<td>被调度的指令必须与分支无关</td>
<td>任何情况</td>
</tr>
<tr>
<td>从目标处调度</td>
<td>必须保证在分支失败时执行被调度的指令不会导致错误。有可能需要复制指令。</td>
<td>分支成功时  （但由于复制指令，有可能会增大程序空间）</td>
</tr>
<tr>
<td>从失败处调度</td>
<td>必须保证在分支成功时执行被调度的指令不会导致错。</td>
<td>分支失败时</td>
</tr>
</tbody></table>
<h6 id="猜测方法"><a href="#猜测方法" class="headerlink" title="猜测方法"></a>猜测方法</h6><p>选取发生概率较高的分支为猜测方向，运行但不写回结果。若猜对，继续执行；否则,作废猜测方向的执行，返回实际转移处。</p>
<p><strong>如何提高猜测命中率</strong></p>
<ul>
<li><p>静态猜测法：猜测不成功方向。</p>
<p>由程序员和编译程序把发生概率高的分支安排在猜测方向。</p>
</li>
<li><p>动态猜测法：根据转移历史猜测</p>
<p>硬件要求：增设转移目标缓冲器BTB。</p>
</li>
</ul>
<h6 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h6><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/561643046">计算机体系结构学习（5）——分支预测 - 知乎 (zhihu.com)</a></p>
<ul>
<li>Static Branch Prediction </li>
<li>1-bit Branch-Prediction Buffer</li>
<li>2-bit Branch-Prediction Buffer</li>
<li>Correlating (Two-level) Branch Prediction Buffer</li>
<li>Tournament Branch Predictor</li>
<li>Branch Target Buffer</li>
<li>Integrated Instruction Fetch Units</li>
<li>Return Address Predictors</li>
</ul>
<ol>
<li><p>只有1个预测位的分支预测缓冲 </p>
<ul>
<li><p>索引：分支指令地址的低位。</p>
</li>
<li><p>存储区：1位的分支历史记录位，又称为预测位，<br>记录该指令最近一次分支是否成功。</p>
</li>
<li><p>“0”记录分支不成功 </p>
<p>“1”记录分支成功</p>
</li>
<li><p>状态转换图</p>
<p><img src="/imgs/ca/140.png" alt="image-20231218202208655"></p>
</li>
<li><p>分支预测缓冲技术包括两个步骤 </p>
<ul>
<li><p>分支预测</p>
<p>如果当前缓冲记录的预测位为“1”，则预测分支为成功；如果预测位为“0”，则预测分支为不成功。</p>
</li>
<li><p>预测位修改</p>
<p>如果当前分支成功，则预测位置为“1”；如果当前分支不成功，预测位置为“0”。</p>
</li>
</ul>
</li>
<li><p>分支预测错误时，预测位就被修改，并且需要恢复现场，程序从分支指令处重新执行。 </p>
<p><img src="/imgs/ca/141.png" alt="image-20231218202825906"></p>
</li>
<li><p>缺点：只要预测出错，往往是连续两次而不是一次。</p>
</li>
<li><p>解决方法：采用两个预测位的预测机制。<br>在两个预测位的分支预测中，更改对分支的预测<br>必须有两次连续预测错误。</p>
<p><img src="/imgs/ca/142.png" alt="image-20231218203453946"></p>
</li>
</ul>
</li>
<li><p>n位分支预测缓冲</p>
<ul>
<li>采用n位计数器，则计数器的值在0到2n-1之间：<br>当计数器的值大于或等于最大值的一半（$2^n-1$）时，<br>预测下一次分支成功；否则预测下一次分支不成功。</li>
<li>预测位的修改和两位预测时相同：<br>当分支成功时计数器的值加1，不成功时减1。</li>
<li>研究表明：n位分支预测的性能和两位分支预测差不多，因而<br>大多数处理器都只采用两位分支预测</li>
</ul>
</li>
</ol>
<p><strong>实现方法</strong></p>
<p>两个关键问题</p>
<ul>
<li>记录转移历史信息</li>
<li>根据所记录的转移历史信息来预测转移的方向</li>
</ul>
<ol>
<li><p>使用BHT的转移预测</p>
<p>当执行转移指令时，转移成功或转移失败的信息可记录在一个所谓的“转移历史表”BHT中。BHT是一个小容量的高速Cache。</p>
<p>为了取得好的预测效果，又便于硬件实现，通常用2位计数器来记录最近二次转移是否成功的状态信息。图30示出了转移预测的状态转换图：每一个圆圈表示一种状态，分别用二进制数字10、11、01、00来表示；圆圈中的汉字表示在该状态下执行一条转移指令时将预测“转移取”指令或是“顺序取”指令；圆圈外的有向线段表示转移指令实际执行后状态位的变化方向。从这个状态转换图我们看到：在改变一次预测方向后，如果连续两次预测错误，则必定会改变预测方向。 </p>
<p><img src="/imgs/ca/143.png" alt="image-20231219102551694"></p>
</li>
<li><p>使用BTB的转移预测</p>
<p>Pentium处理机中使用了转移目标缓冲栈BTB作为转移预测策略。支持这种策略的也是一个内部cache，其结构类似于图31所介绍的BHT结构，只不过每项的转移指令字段现在改为转移指令地址字段，如图32(a)所示。BTB是一个4路组相联的Cache，共有256行。转移指令地址(高24位)字段即为该项的标记(tag)，以转移指令地址的低8位为行索引。每项有2位历史状态位，记录最近执行该转移指令的历史，即以该转移指令的过去行为来猜测它的将来行为。每次转移指令执行完毕，依据预测是否正确要相应地修改历史位。历史位的使用和修改规则如图32(b)所示。将它与图30(a)相对照，不难发现BTB的预测更倾向于转移取。进入BTB的新基初始设置历史位为11状态</p>
<p><img src="/imgs/ca/144.png" alt="image-20231219102633023"></p>
<p><img src="/imgs/ca/145.png" alt="image-20231219102651071"></p>
<p>每当Pentium流水线D1段译码出一条转移指令，控制逻辑将检索BTB，确定是否有该“转移指令地址”的相应项。如果cache未命中，则预测该转移指令为顺序取；如果命中，此项的历史位用于预测该转移指令应是“转移取”还是“顺序取”。若是顺序取，则继续由I-cache预取指令送至原先使用的一个预取缓冲栈。若是预测为转移取，则原先使用的预取缓冲栈立即冻结，依BTB相应表项给出的转移目标地址，由I-cache预取目标路径的指令序列送至另一个预取缓冲栈。因检索BTB和预取指令都是cache访问，故能在D1段同一时间内完成。因此，当转移指令Ib出现在D1段并被预测为转移取且I-cache也命中的话，转移目标处的最初两条指令It，It+1已及时出现在流水线上，没有任何延迟损失</p>
<p>用2位二进制数记录实际转移状态(历史位)，高位为1时预测转移发生，高位为0时预测转移不发生。</p>
<p><img src="/imgs/ca/146.png" alt="image-20231219102759012"></p>
</li>
<li><p>使用BTIB的转移预测</p>
<p>当转移指令在指令分析部件中译码时，转移不成功方向上的指令已经被预取到指令缓冲栈中，或者已经存放在I-cache中。为了能够在转移成功方向上也预取一部分指令，可以把图32(a)中的“转移目标地址”部分改为存放转移目标地址之后的n条指令。这种预测策略称为转移目标指令缓冲栈BTIB，它也是一个内部Cache，项逻辑结构如图33所示。它的工作原理、预测转移方向的规则、修改历史位的方法与BTB方法相类似。 </p>
<p><img src="/imgs/ca/147.png" alt="image-20231219102855613"></p>
</li>
</ol>
<p>猜测的后续处理</p>
<p>分支现场的保护及恢复</p>
<ul>
<li>采用后援寄存器保存可能被破坏的状态；</li>
<li>猜测执行只完成译码、取操作数或执行，但不写结果。</li>
</ul>
<p>预防猜不中时的加速处理：</p>
<p>预取猜测方向的另一方向的前几条指令，放到缓冲器中，加速猜不中时回头速度。</p>
<h6 id="精确中断与非精确中断"><a href="#精确中断与非精确中断" class="headerlink" title="精确中断与非精确中断"></a>精确中断与非精确中断</h6><ul>
<li>精确中断<ul>
<li>如果流水线可以控制使得引起异常的指令前序指令都执行完，故障后的指令可以重新执行，则称该流水线支持精确中断</li>
<li>按照指令的逻辑序处理异常</li>
<li>理想情况，引起故障的指令没有改变机器的状态</li>
<li>要正确的处理这类异常请求，必须保证故障指令不产生副作用</li>
</ul>
</li>
<li>在有些机器上，浮点数异常<ul>
<li>流水线段数多，在发现故障前，故障点后的指令就已经写了结果，在这种情况下，必须有办法处理。</li>
<li>很多高性能计算机，Alpha 21164，MIPS R10000等支持精确中断，但精确模式要慢10+倍，一般用在代码调试时，很多系统要求精确中断模式，如IEEE FP标准处理程序，虚拟存储器等。</li>
</ul>
</li>
<li>精确中断对整数流水线而言，不是太难实现<ul>
<li>指令执行的中途改变机器的状态</li>
<li>例如IA-32 的自动增量寻址模式</li>
</ul>
</li>
</ul>
<p><img src="/imgs/ca/148.png" alt="image-20231219103352920"></p>
<p>处理中断4种可能的办法</p>
<ul>
<li>方法1：忽略这种问题，当非精确处理<ul>
<li>原来的supercomputer的方法</li>
<li>但现代计算机对IEEE 浮点标准的异常处理，虚拟存储的异常处理要求必须是精确中断。</li>
</ul>
</li>
<li>方法2：缓存操作结果，直到早期发射的指令执行完<ul>
<li>当指令运行时间较长时，Buffer区较大</li>
<li>Future file  (Power PC620 MIPS R10000)<ul>
<li>缓存执行结果，按指令序确认</li>
</ul>
</li>
<li>history file  (CYBER 180&#x2F;990)<ul>
<li>尽快确认</li>
<li>缓存区存放原来的操作数，如果异常发生，回卷到合适的状态</li>
</ul>
</li>
</ul>
</li>
<li>方法3：以非精确方式处理，用软件来修正<ul>
<li>为软件修正保存足够的状态</li>
<li>让软件仿真尚未执行完的指令的执行</li>
<li>例如<ul>
<li>Instruction 1 – A 执行时间较长，引起中断的指令</li>
<li>Instruction 2, instruction 3, ….instruction n-1 未执行完的指令</li>
<li>Instruction n    已执行完的指令</li>
<li>由于第n条指令已执行完，希望中断返回后从第n+1条指令开始执行，如果我们保存所有的流水线的PC值，那么软件可以仿真Instruction1 到Instruction n-1 的执行</li>
</ul>
</li>
</ul>
</li>
<li>方法4：暂停发射，直到确定先前的指令都可无异常的完成，再发射下面的指令。<ul>
<li>在EX段的前期确认（MIPS流水线在前三个周期中）</li>
<li>MIPS R2K to R4K 以及Pentium使用这种方法</li>
</ul>
</li>
</ul>
<h4 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h4><h5 id="线性与非线性流水线"><a href="#线性与非线性流水线" class="headerlink" title="线性与非线性流水线"></a>线性与非线性流水线</h5><ul>
<li>流水线的各个流水段之间是否有反馈信号</li>
<li>线性流水线(Linear Pipelining)每个流水段都流过一次，且仅流过一次</li>
<li>非线性流水线(Nonlinear Pipelining)在流水线的某些流水段之间有反馈回路或前馈回路</li>
<li>线性流水线能够用流水线连接图唯一表示非线性流水线必须用流水线连接图与流水线预约表等共同表示</li>
</ul>
<p>一种简单的非线性流水</p>
<p><img src="/imgs/ca/149.png" alt="image-20231219104036534"></p>
<h5 id="流水线级别分类"><a href="#流水线级别分类" class="headerlink" title="流水线级别分类"></a>流水线级别分类</h5><h6 id="处理机级流水线"><a href="#处理机级流水线" class="headerlink" title="处理机级流水线"></a>处理机级流水线</h6><p>又称为指令流水线 (Instruction Pipelining)，例如：在采用先行控制器的处理机中，各功能部件之间的流水线</p>
<p><img src="/imgs/ca/150.png" alt="image-20231219104143397"></p>
<h6 id="部件级流水线"><a href="#部件级流水线" class="headerlink" title="部件级流水线"></a>部件级流水线</h6><p>把处理机的算术逻辑部件分段，使得各种数据类型的操作能够进行流水。<br>如浮点加法器流水线</p>
<p><img src="/imgs/ca/151.png" alt="image-20231219104251086"></p>
<h6 id="宏流水线"><a href="#宏流水线" class="headerlink" title="宏流水线"></a>宏流水线</h6><p>每个处理机对同一个数据流的不同部分分别进行处理，它是指由两个以上的处理机串行地对同一数据流进行处理，每个处理机完成一项任务。</p>
<p><img src="/imgs/ca/152.png" alt="image-20231219104335644"></p>
<h5 id="单功能与多功能流水线"><a href="#单功能与多功能流水线" class="headerlink" title="单功能与多功能流水线"></a>单功能与多功能流水线</h5><h6 id="单功能流水线"><a href="#单功能流水线" class="headerlink" title="单功能流水线"></a>单功能流水线</h6><p>只能完成一种固定功能的流水线</p>
<p>Cray-1计算机中有12条；</p>
<p>YH-1计算机有18条；</p>
<p>Pentium有一条5段的定点和一条8段的浮点流水线；</p>
<p>PentiumⅢ有三条指令流水线，其中两条定点指令流水线，一条浮点指令流水线。</p>
<h6 id="多功能流水线"><a href="#多功能流水线" class="headerlink" title="多功能流水线"></a>多功能流水线</h6><p>流水线的各段通过不同连接实现不同功能</p>
<p>Texas公司的ASC计算机中的8段流水线，能够实现：定点加减法、定点乘法、浮点加法、浮点乘法、逻辑运算、移位操作、数据转换、向量运算等。</p>
<p><img src="/imgs/ca/153.png" alt="image-20231219104636204"></p>
<h5 id="静态流水线与动态流水线"><a href="#静态流水线与动态流水线" class="headerlink" title="静态流水线与动态流水线"></a>静态流水线与动态流水线</h5><h6 id="静态流水线"><a href="#静态流水线" class="headerlink" title="静态流水线"></a>静态流水线</h6><p>同一段时间内，多功能流水线中的各个功能段只能按照一种固定的方式连接，实现一种固定的功能。</p>
<p>只有连续出现同一种运算时，流水线的效率才能得到充分的发挥。</p>
<p><img src="/imgs/ca/154.png" alt="image-20231219104743632"></p>
<p>只有当进入的是<strong>一串相同运算的指令</strong>时，流水的效能才得以发挥，才能使各个功能段并行地对多条指令的数据进行流水处理</p>
<h6 id="动态流水线"><a href="#动态流水线" class="headerlink" title="动态流水线"></a>动态流水线</h6><p>在同一段时间内，多功能流水线中的各段可以按照不同的方式连接，同时执行多种功能</p>
<p>优点：能提高流水线的效率</p>
<p>缺点：会使流水线的控制变得复杂</p>
<p><img src="/imgs/ca/155.png" alt="image-20231219104812470"></p>
<p>区别：如果从软硬功能分配的观点上来看，静态流水线其实是把功能负担较多地加到软件上，以简化硬件，动态流水线则是把功能负担较多地加在硬件上，以提高流水的效能。</p>
<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><h6 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h6><ul>
<li>标量处理机：不具有向量指令和向量数据表示，仅对标量进行流水处理的处理机。</li>
<li>向量处理机：具有向量指令和向量数据表示的处理机。</li>
</ul>
<h6 id="是否有反馈回路"><a href="#是否有反馈回路" class="headerlink" title="是否有反馈回路"></a>是否有反馈回路</h6><ul>
<li>线性流水线：流水线中的各段串行连接，没有反馈回路。</li>
<li>非线性流水线：流水线中的各段除有串行连接外，还有反馈回路</li>
</ul>
<p>非线性流水线必须用流水线连接图与流水线预约表等共同表示</p>
<h6 id="流动是否可以乱序"><a href="#流动是否可以乱序" class="headerlink" title="流动是否可以乱序"></a>流动是否可以乱序</h6><ul>
<li>顺序流动流水线，流水线输出端任务流出的顺序与输入端任务流入的顺序相同。</li>
<li>异步流动流水线（乱序流水线&#x2F;无序流水线&#x2F;错序流水线），流水线输出端任务流出的顺序与输入端任务流入的顺序不同。</li>
</ul>
<p><img src="/imgs/ca/156.png" alt="image-20231219105400666"></p>
<h4 id="线性流水线的性能分析"><a href="#线性流水线的性能分析" class="headerlink" title="线性流水线的性能分析"></a>线性流水线的性能分析</h4><p>衡量流水线性能的主要指标有：吞吐率、加速比和效率</p>
<h5 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h5><p>求流水线吞吐率的最基本公式<br>$$<br>T_P&#x3D;n&#x2F;T_k<br>$$<br>n为任务数, Tk为完成n个任务所用时间</p>
<p>最大吞吐率TPmax是指流水线在连续流动达到稳定状态后所得到的吞吐率</p>
<p><img src="/imgs/ca/157.png" alt="image-20231219105921009"></p>
<p>若各段执行时间相等，则输入连续任务情况下完成n个连续任务需要的总时间为<br>$$<br>T_k&#x3D;(k+n-1)D_t<br>$$<br>k为流水线的段数，Dt为时钟周期<br>$$<br>TP&#x3D;\frac n{(k+n-1)\Delta t}<br>$$</p>
<p>$$<br>TP\max&#x3D;\underset{n\to\infty}{\operatorname*{Lim}}\frac n{(k+n-1)\Delta t}&#x3D;\frac1{\Delta t}<br>$$</p>
<p>各段执行时间不相等、输入连续任务情况下<br>$$<br>TP&#x3D;\frac n{\sum_{i&#x3D;1}^kt_i+(n-1)\max(\Delta t_1,\Delta t_2,\cdot\cdot\cdot,\Delta t_k)}<br>$$</p>
<p>$$<br>TP_{\max}&#x3D;\frac1{\max(\Delta t_1,\Delta t_2,\cdots,\Delta t_k)}<br>$$</p>
<p>流水线各段执行时间不相等的解决办法</p>
<p><img src="/imgs/ca/158.png" alt="image-20231219110205100"></p>
<h5 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h5><p>$$<br>S&#x3D;\text{顺序执行时间}T_0&#x2F;\text{流水线执行时间}T_k<br>$$</p>
<p>各段执行时间相等，输入连续任务情况下加速比为<br>$$<br>S&#x3D;\frac{k\cdot n\cdot\Delta t}{(k+n-1)\Delta t}&#x3D;\frac{k\cdot n}{k+n-1}<br>$$<br>最大加速比为<br>$$<br>S_{\textrm{m a x}}&#x3D; \lim_{n \to \infin} \frac{k\cdot n}{k+n-1}&#x3D;k<br>$$<br>各段执行时间不等，输入连续任务情况下实际加速比为：<br>$$<br>S&#x3D;\frac{n\cdot\sum\limits_{i&#x3D;1}^{k}\Delta ti}{\sum\limits_{i&#x3D;1}^{k}\Delta t_i+(n-1)\cdot\max(\Delta t_1,\Delta t_2,\cdots,\Delta t_k)}<br>$$</p>
<h5 id="效率E"><a href="#效率E" class="headerlink" title="效率E"></a>效率E</h5><p>效率是指流水线的设备利用率</p>
<p>由于流水线有通过时间和排空时间，所以流水线的</p>
<p>各段并不是一直满负荷地工作。故：E ＜1</p>
<p><img src="/imgs/ca/159.png" alt="image-20231219110844560"></p>
<p>若各段时间相等，则各段的效率$e_i$相等<br>$$<br>e_1&#x3D;e_2&#x3D;\cdots&#x3D;e_k&#x3D;n\Delta t_0&#x2F;T_\text{流水}<br>$$</p>
<p>$$<br>E&#x3D;\frac{n\Delta t_0}{T_\text{流水}} &#x3D; \frac n { k + n - 1 }&#x3D;\frac1{1+\frac{k-1}n}<br>$$</p>
<p>$n&gt;&gt;m,E \approx 1$</p>
<p>从时－空图上看，效率实际上就是 n 个任务所占的时空区与 k 个段总的时空区之比，即：<br>$$<br>E&#x3D;\frac{n\text{个任务占用的时空区}}{ k\text{个流水段的总的时空区}} &#x3D; \frac { T _ 0 }{ k \cdot T _ k}<br>$$<br>提高流水线效率所采取的措施对于提高吞吐率也有好处。</p>
<p>各流水段执行时间相等，输入n个连续任务流水线的效率为：<br>$$<br>E&#x3D;\frac{k\cdot n\cdot\Delta t}{k\cdot(k+n-1)\cdot\Delta t}&#x3D;\frac n{k+n-1}<br>$$<br>流水线的最高效率为<br>$$<br>E_{\max}\quad&#x3D;\lim_{n\to\infty}\quad\frac{n}{k+n-1}&#x3D;1<br>$$<br>各流水段执行时间不等，输入n个连续任务流水线的效率为<br>$$<br>E&#x3D;\frac{n\cdot\sum_{i&#x3D;1}^k\Delta t_i}{k\cdot[\sum_{i&#x3D;1}^k\Delta t_i+(n-1)\cdot\max(\Delta t_1,\Delta t_2,\cdots,\Delta t_k)]}<br>$$<br>流水线各段的设备量或各段的价格不相等时：<br>流水线的效率为<br>$$<br>E&#x3D;\frac{n\cdot\sum_{i&#x3D;1}^ka_i\cdot\Delta t_i}{\sum_{I&#x3D;1}^{i&#x3D;k}a_i\cdot[\sum_{i&#x3D;1}^ka_i\cdot\Delta t_i+(n-1)\cdot\max(\Delta t_1,\Delta t_2,,\Delta t_n)]}<br>$$<br>$\sum_{i&#x3D;1}^k a_i&#x3D;k$</p>
<h5 id="流水线的吞吐率、加速比与效率的关系"><a href="#流水线的吞吐率、加速比与效率的关系" class="headerlink" title="流水线的吞吐率、加速比与效率的关系"></a>流水线的吞吐率、加速比与效率的关系</h5><p>$$<br>\begin{aligned}TP&amp;&#x3D;\frac n{(k+n-1)\Delta t}\S&amp;&#x3D;\frac{k\cdot n}{k+n-1}\E&amp;&#x3D;\frac n{k+n-1}\end{aligned}<br>$$</p>
<p>$$<br>E&#x3D;TP·\Delta t , S&#x3D;k·E<br>$$</p>
<h5 id="性能分析举例"><a href="#性能分析举例" class="headerlink" title="性能分析举例"></a>性能分析举例</h5><p>Z &#x3D; [(A+B) + (C+D)] + [(E+F) + (G+H)]</p>
<p><img src="/imgs/ca/160.png" alt="image-20231219141925167"></p>
<p>确定适合于流水处理的计算过程</p>
<p>画时－空图</p>
<p>计算性能</p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/586202303">计算机体系结构——动态流水线&amp;动态调度 - 知乎 (zhihu.com)</a></p>
<p>指令调度技术的一个前提是不改变程序正确性，通过改变指令的执行次序来避免由于指令相关引起的流水线阻塞</p>
<h4 id="静态指令调度"><a href="#静态指令调度" class="headerlink" title="静态指令调度"></a>静态指令调度</h4><p>静态调度(static scheduling)是由优化的编译程序来完成，其基本思想是重排指令序列，拉开具有数据相关的有关指令间的距离。由于是用编译程序判测潜在的数据相关，并在程序运行之前完成调度，故称为静态调度</p>
<p><img src="/imgs/ca/161.png" alt="image-20231219142638867"></p>
<ul>
<li>Basic block scheduling基础块调度</li>
<li>Loop unrolling循环展开</li>
<li>Software pipelining (modulo scheduling)软件流水</li>
<li>Trace scheduling轨迹调度</li>
<li>Predication预测</li>
</ul>
<h4 id="动态指令调度"><a href="#动态指令调度" class="headerlink" title="动态指令调度"></a>动态指令调度</h4><p>Expose more parallelism by ignoring artificial serial constraints of “sequential” program</p>
<p>Also called out-of-order issue (OOO-issue): instructions need not execute in original program order</p>
<p>寄存器重命名</p>
<p>精准中断</p>
<h5 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h5><p>data, structural, control</p>
<ul>
<li>Data: RAW (true data dependence), WAR ( anti-dependence), WAW (output dependence)</li>
<li>Structural: Are the required resources available? </li>
<li>Control: Is this instruction supposed to execute or not?</li>
</ul>
<h5 id="实现-两种早期方法"><a href="#实现-两种早期方法" class="headerlink" title="实现-两种早期方法"></a>实现-两种早期方法</h5><p>Control flow </p>
<p>Data flow – Tomasulo</p>
<ul>
<li>Simple idea – when opcode and operands are ready, and the appropriate set of resources are ready, launch the “execution packet”</li>
<li>Interesting wrinkle – does not used named registers for intermediate storage</li>
<li>Implicit introduction of Register Renaming</li>
</ul>
<h5 id="动态调度的优势"><a href="#动态调度的优势" class="headerlink" title="动态调度的优势"></a>动态调度的优势</h5><ul>
<li>处理实例当在编译期相关性未知</li>
<li>简化编译器</li>
<li>允许为一个流水线编译的代码在另一个流水线上高效运行</li>
<li>硬件推测，一种基于动态调度的具有显著性能优势的技术</li>
</ul>
<h5 id="硬件策略：指令并行"><a href="#硬件策略：指令并行" class="headerlink" title="硬件策略：指令并行"></a>硬件策略：指令并行</h5><ul>
<li><p>Key idea: Allow instructions behind stall to proceed</p>
<p>DIVD F0,F2,F4<br>ADDD F10,F0,F8<br>SUBD F12,F8,F14</p>
</li>
<li><p>Enables out-of-order execution and allows out-of-order completion</p>
</li>
<li><p>Will distinguish when an instruction begins execution and when it completes execution; between 2 times, the instruction is in execution</p>
</li>
<li><p>In a dynamically scheduled pipeline, all instructions pass through issue stage in order (in-order issue)</p>
</li>
</ul>
<h5 id="流水线修改"><a href="#流水线修改" class="headerlink" title="流水线修改"></a>流水线修改</h5><p>基础的必须的流水线变化</p>
<ul>
<li>Stalled dependent instructions cannot block later independent instructions停滞的依赖指令无法阻塞以后的独立指令</li>
<li>Split ID (decode stage) into two new stages将 ID（解码阶段）拆分为两个新阶段<ul>
<li>DISPATCH (ID): instruction dispatchDISPATCH （ID）：指令调度</li>
<li>ISSUE (IS): instruction schedule &#x2F; issue ISSUE （IS）：指令规划&#x2F;问题</li>
</ul>
</li>
<li>The ISSUE stage buffers instructions waiting (stalled) for dataISSUE阶段缓冲等待（停止）数据的指令</li>
<li>This allows later instructions to make progress (FETCH and DISPATCH are not stalled)这允许稍后的指令取得进展（FETCH 和 DISPATCH 不会停止）</li>
</ul>
<p>无序流水线</p>
<h5 id="scoreboard"><a href="#scoreboard" class="headerlink" title="scoreboard"></a>scoreboard</h5><ul>
<li>仅当两个操作数在寄存器文件中都可用时，指令的操作数才是只读的<ul>
<li>记分牌不利用转发</li>
<li>指令在完成执行后立即写入寄存器文件（假设没有 WAR 危害），并且不要等待写入插槽</li>
<li>一个额外的延迟周期，因为写入结果和读取操作数阶段不能重叠</li>
</ul>
</li>
<li>总线结构<ul>
<li>注册文件的总线数量有限代表结构性危险</li>
</ul>
</li>
</ul>
<p>三个数据结构</p>
<ul>
<li>指令状态Which stage is the instruction in</li>
<li>功能单元状态<ul>
<li>Busy	- FU is busy executing another instruction</li>
<li>Op	- What instruction is the FU busy with</li>
<li>Fi		- Destination register</li>
<li>Fj, Fk	- Source registers</li>
<li>Qj, Qk	- Functional units producing source registers</li>
<li>Rj, Rk	- Flags indicating source registers are ready</li>
</ul>
</li>
<li>寄存器结果状态<ul>
<li>Which FU is going to write each register</li>
</ul>
</li>
</ul>
<h5 id="分布式动态调度-Tomasulo"><a href="#分布式动态调度-Tomasulo" class="headerlink" title="分布式动态调度-Tomasulo"></a>分布式动态调度-Tomasulo</h5><h6 id="Tomasulo-vs-scoreboard"><a href="#Tomasulo-vs-scoreboard" class="headerlink" title="Tomasulo vs scoreboard"></a>Tomasulo vs scoreboard</h6><ul>
<li><p>控制和缓冲区与功能单元（FU）一起分布，而不是集中在记分牌中;（旁路）</p>
<ul>
<li>FU 缓冲区称为预留站;有挂起的操作数</li>
</ul>
</li>
<li><p>指令中的寄存器由值或指向预订站（RS）的指针代替;称为寄存器重命名</p>
<ul>
<li>避免 WAR、WAW 危害</li>
<li>预留站多于寄存器，因此可以进行编译器无法做到的优化</li>
</ul>
</li>
<li><p>结果通过公共数据总线从 RS 传输到 FU，而不是通过寄存器，将结果广播到所有 Fu</p>
</li>
<li><p>加载和存储也被视为具有预订站的 FU</p>
</li>
<li><p>整数指令可以经过分支，允许 FP 操作超出 FP 队列中的基本块</p>
</li>
</ul>
<h6 id="tomasulo算法的关键方面"><a href="#tomasulo算法的关键方面" class="headerlink" title="tomasulo算法的关键方面"></a>tomasulo算法的关键方面</h6><ol>
<li>在调度阶段读取寄存器操作数<ul>
<li>如果操作数可用，则数据将与“预订站”中的指令一起缓冲</li>
<li>CDC：仅缓冲指令，当所有操作数都准备好时，从寄存器文件中读取所有操作数（在问题阶段读取操作数）</li>
<li>CDC – 晚读 &#x2F; Tomasulo – 早读：早读有助于 WAR 状况</li>
</ul>
</li>
<li>不可用的寄存器在调度阶段重命名<ul>
<li>等待指令将寄存器说明符替换为指示生产者指令的“标记”</li>
<li>寄存器说明符在发货时仅使用一次！</li>
<li>重命名消除了 WAR&#x2F;WAW 危害</li>
</ul>
</li>
<li>连续写入寄存器<ul>
<li>实际上只有最后一个用于更新寄存器：帮助 WAW 条件</li>
<li>CDC：在WAW危害消失之前停止调度</li>
</ul>
</li>
</ol>
<h6 id="DLX版本"><a href="#DLX版本" class="headerlink" title="DLX版本"></a>DLX版本</h6><p>提取后的四个阶段</p>
<ul>
<li>调度<ul>
<li>检查结构危险<ul>
<li>如果没有免费预订站，则在调度阶段停滞不前</li>
</ul>
</li>
<li>读取寄存器文件<ul>
<li>读取数据操作数（如果可用）</li>
<li>如果数据操作数不可用，则读取“标签”：标签是生产者指令的预留站号</li>
</ul>
</li>
<li>将指令和数据或标签路由到预订站，在那里等待，直到所有操作数都可用</li>
</ul>
</li>
<li>发射<ul>
<li>等到操作数在 CDB 上可用（将 CDB 标记与操作数标记匹配）</li>
<li>从 CDB 获取操作数并颁发给 FU（如果可用）</li>
</ul>
</li>
<li>执行</li>
<li>写入结果<ul>
<li>通过CDB将结果+标签广播到所有预订站，存储缓冲区和注册文件</li>
<li>仅当 CDB 标记与寄存器文件中的标记匹配时，才写入寄存器文件</li>
</ul>
</li>
</ul>
<p><img src="/imgs/ca/162.png" alt="image-20231221232426047"></p>
<h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6><ul>
<li>寄存器状态Register file stores either a tag or a value</li>
<li>指令状态This is for illustration only, not a real data structure</li>
</ul>
<h6 id="保留站内容"><a href="#保留站内容" class="headerlink" title="保留站内容"></a>保留站内容</h6><ul>
<li>Op:	Operation to perform in the unit (e.g., + or –)</li>
<li>Vj, Vk: Value of Source operands<ul>
<li>Store buffers has V field, result to be stored</li>
</ul>
</li>
<li>Qj, Qk: Reservation stations producing source registers (value to be written)<ul>
<li>Note: Qj,Qk&#x3D;0 &#x3D;&gt; ready</li>
<li>Store buffers only have Qi for RS producing result</li>
</ul>
</li>
<li>Busy: Indicates reservation station or FU is busy</li>
<li>Register result status—Indicates which functional unit will write each register, if one exists. Blank when no pending instructions that will write that register.</li>
</ul>
<h6 id="tomasulo算法的三个阶段"><a href="#tomasulo算法的三个阶段" class="headerlink" title="tomasulo算法的三个阶段"></a>tomasulo算法的三个阶段</h6><ol>
<li><p>发射issue</p>
<p>get instruction from FP Op Queue</p>
<ul>
<li>If reservation station free (no structural hazard), control issues instr &amp; </li>
<li>sends operands (renames registers).</li>
</ul>
</li>
<li><p>执行execute</p>
<p>operate on operands (EX）</p>
<ul>
<li>When both operands ready then execute; </li>
<li>if not ready, watch Common Data Bus for result</li>
</ul>
</li>
<li><p>写结果</p>
<p>finish execution (WB)</p>
<ul>
<li>Write on Common Data Bus to all awaiting units; </li>
<li>mark reservation station available</li>
</ul>
</li>
</ol>
<ul>
<li>Normal data bus: data + destination (“go to” bus)</li>
<li>Common data bus: data + source  (“come from” bus)<ul>
<li>64 bits of data + 4 bits of Functional Unit  source address</li>
<li>Write if matches expected Functional Unit (produces result)</li>
<li>Does the broadcast</li>
</ul>
</li>
</ul>
<h3 id="超流水线处理机"><a href="#超流水线处理机" class="headerlink" title="超流水线处理机"></a>超流水线处理机</h3><p>一个周期内能够分时发射多条指令的处理机称为 超流水线处理机。    </p>
<p>指令流水线有8个或更多功能段的流水线处理机称为超流水线处理机。</p>
<p>提高处理机性能的不同方法：    </p>
<ol>
<li>超标量处理机是通过增加硬件资源为代价来换取处理机性能的。</li>
<li>超流水线处理机则通过各硬件部件充分重叠工作来提高处理机性能。</li>
</ol>
<p>两种不同并行性：    </p>
<ol>
<li><strong>超标量处理机</strong>采用的是空间并行性    </li>
<li><strong>超流水线处理机</strong>采用的是时间并行性</li>
</ol>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>指令级并行度为(1,n)的超流水线处理机，执行N条指令所的时间为<br>$$<br>T\left(1,n\right)&#x3D;(k+\frac{N-1}n)\Delta t<br>$$<br>超流水线处理机相对于单流水线普通标量处理机的加速比为：<br>$$<br>S\left(1,n\right)&#x3D;\frac{T\left(1,1\right)}{T\left(1,n\right)}&#x3D;\frac{\left(k+N-1\right)\Delta t}{(k+\frac{N-1}n)\Delta t}<br>$$</p>
<p>$$<br>S(1,n)&#x3D;\frac{n(k+N-1)}{nk+N-1}<br>$$</p>
<p>最大加速比为$\mathbf{S(1,n)}_{\mathbf{MAX}}&#x3D;n$</p>
<h4 id="超标量超流水线处理机"><a href="#超标量超流水线处理机" class="headerlink" title="超标量超流水线处理机"></a>超标量超流水线处理机</h4><p>把超标量与超流水线技术结合在一起，就成为超标量超流水线处理机</p>
<h5 id="指令执行时序"><a href="#指令执行时序" class="headerlink" title="指令执行时序"></a>指令执行时序</h5><p>超标量超流水线处理机在一个时钟周期内分时发射指令n次，每次同时发射指令m条，每个时钟周期总共发射指令m × n条。</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20231224174902809.png" alt="image-20231224174902809"></p>
<h5 id="典型处理机结构"><a href="#典型处理机结构" class="headerlink" title="典型处理机结构"></a>典型处理机结构</h5><ul>
<li>DEC公司的Alpha处理机采用超标量超流水线结构。主要由四个功能部件和两个Cache组成：整数部件EBOX、浮点部件FBOX、地址部件ABOX和中央控制部件IBOX。</li>
<li>中央控制部件IBOX可以同时从指令Cache中读入两条指令，同时对读入的两条指令进行译码，并且对这两条指令作资源冲突检测，进行数据相关性和控制相关性分析。如果资源和相关性允许，IBOX就把两条指令同时发射给EBOX、ABOX和FBOX三个指令执行部件中的两个。</li>
<li>指令流水线采用顺序发射乱序完成的控制方式。在指令Cache中有一个转移历史表，实现条件转移的动态预测。在EBOX内还有多条专用数据通路，可以把运算结果直接送到执行部件。</li>
</ul>
<h5 id="超标量流水线处理机性能"><a href="#超标量流水线处理机性能" class="headerlink" title="超标量流水线处理机性能"></a>超标量流水线处理机性能</h5><p>指令级并行度为(m,n)的超标量超流水线处理机，连续执行N条指令所需要的时间为<br>$$<br>T(m,n)&#x3D;(k+\frac{N-m}{m\cdot n})\Delta t<br>$$<br>超标量超流水线处理机相对于单流水线标量处理机的加速比为<br>$$<br>\begin{aligned}<br>&amp;\begin{aligned}S(m,n)&#x3D;\frac{S(1,1)}{S(m,n)}&amp;&#x3D;\frac{(k+N-1)\Delta t}{(k+\frac{N-m}{mn})\Delta t}\end{aligned} \<br>&amp;\begin{aligned}S(m,n)&#x3D;\frac{m\cdot n\cdot(k+N-1)}{m\cdot n\cdot k+N-m}\end{aligned}<br>\end{aligned}<br>$$<br>在理想情况下，超标量超流水线处理机加速比的最大值为<br>$$<br>S(m,n)_\text{MAX}{ &#x3D; m n}<br>$$</p>
<p>三种指令级并行处理机性能比较</p>
<p><strong>超标量处理机</strong>、<strong>超流水线处理机</strong>和<strong>超标量超流水线处理机</strong>相对于单流水线普通标量处理机的性能曲线。</p>
<p><img src="/imgs/ca/163.png" alt="image-20231224175404083"></p>
<p>从三种指令级并行处理机的性能曲线中，可以得出如下结论:</p>
<ol>
<li><p>三种处理机的性能关系      </p>
<p>超标量处理机的相对性能最高，其次是超标量超流水线处理机，超流水线处理机的相对性能最低，主要原因如下：      </p>
<ol>
<li>超标量处理机在每个时钟周期的一开始就同时发射多条指令，而超流水线处理机则要把一个时钟周期平均分成多个流水线周期，每个流水线周期发射一条指令；因此，超流水线处理机的启动延迟比超标量处理机大。</li>
<li>条件转移造成的损失，超流水线处理机要比超标量处理机大。</li>
<li>在指令执行过程中的每一个功能段，超标量处理机都重复设置有多个相同的指令执行部件，而超流水线处理机只是把同一个指令执行部件分解为多个流水级；因此，超标量处理机指令执行部件的冲突要比超流水线处理机小</li>
</ol>
</li>
<li><p>实际指令级并行度与理论指令级并行度的关系</p>
<p>当横坐标给出的理论指令级并行度比较低时，处理机的实际指令级并行度的提高比较快。    </p>
<p>当理论指令级并行度进一步增加时，处理机实际指令级并行度提高的速度越来越慢。    </p>
<p>在实际设计超标量、超流水线、超标量超流水线处理机的指令级并行度时要适当，否则，有可能造成花费了大量的硬件，但实际上处理机所能达到的指令级并行度并不高。    </p>
<p>目前，一般认为，m 和 n 都不要超过4。</p>
</li>
<li><p>最大指令级并行度</p>
<p>一个特定程序由于受到本身的数据相关和控制相关的限制，它的指令级并行度的最大值是有限的，是有个确定的值。这个最大值主要由程序自身的语义来决定，与这个程序运行在那一种处理机上无关。对于某一个特定的程序，图中的三条曲线最终都要收拢到同一个点上。当然，对于各个不同程序，这个收拢点的位置也是不同的。</p>
</li>
</ol>
<h2 id="向量处理机"><a href="#向量处理机" class="headerlink" title="向量处理机"></a>向量处理机</h2><ul>
<li>向量处理机是解决数值计算问题的一种高性能计算机结构</li>
<li>向量处理机一般都采用流水线结构，有多条流水线并行工作</li>
<li>向量处理机通常属大型或巨型机，也可以用微机加一台向量协处理器组成</li>
<li>一般向量计算机中包括有一台高性能标量处理机</li>
<li>必须把要解决的问题转化为向量运算，向量处理机才能充分发挥作用</li>
</ul>
<p>提高流水性能方法</p>
<ul>
<li>增加流水线段数，以减少Δt；</li>
<li>每个时钟同时启动多条指令；</li>
<li>减少相关，减少功能变换次数，增加处理指令条数。</li>
</ul>
<p>向量操作特点：</p>
<ol>
<li>向量元素间操作相互独立，且为相同操作。</li>
<li>相当于标量循环，对指令带宽的访问要求不高。</li>
<li>可采用多体交叉存储器，减少访存延迟</li>
</ol>
<p>向量操作很适合于流水处理或并行处理。</p>
<h3 id="向量处理的基本概念"><a href="#向量处理的基本概念" class="headerlink" title="向量处理的基本概念"></a>向量处理的基本概念</h3><h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><p>a set of scalar data items, all of the same type, stored in memory</p>
<h4 id="向量处理机-1"><a href="#向量处理机-1" class="headerlink" title="向量处理机"></a>向量处理机</h4><p>an ensemble of hardware resources, including vector registers, functional pipelines, processing elements, and register counters for performing vector operations</p>
<h4 id="向量处理"><a href="#向量处理" class="headerlink" title="向量处理"></a>向量处理</h4><p>occurs when arithmetic or logical operations are applied to vectors</p>
<h4 id="向量处理方式"><a href="#向量处理方式" class="headerlink" title="向量处理方式"></a>向量处理方式</h4><p>根据向量运算的特点和向量处理机的类型选择向量的处理方式</p>
<p>有三种处理方式：</p>
<ol>
<li><strong>横向处理方式</strong>，又称为水平处理方式，横向加工方式等。向量计算是按行的方式从左至右横向地进行。</li>
<li><strong>纵向处理方式</strong>，又称为垂直处理方式，纵向加工方式等。向量计算是按列的方式自上而下纵向地进行。</li>
<li><strong>纵横处理方式</strong>，又称为分组处理方式，纵横向加工方式等。横向处理和纵向处理相结合的方式。</li>
</ol>
<p>以下列程序为例</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;1;i&lt;&#x3D;n;i++)
	y[i]&#x3D;a[i]*(b[i]+c[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="横向处理"><a href="#横向处理" class="headerlink" title="横向处理"></a>横向处理</h5><p>也称为水平处理方式，横向加工方式等</p>
<p>逐个分量进行处理：假设中间结果为$T[i]$</p>
<p>计算第1个分量:$T[1]&#x3D;B[1]+C[1],Y[1]&#x3D;A[1]*T[1]$</p>
<p>计算第1个分量:$T[2]&#x3D;B[2]+C[2],Y[2]&#x3D;A[2]*T[2]$</p>
<p>…</p>
<p>计算第n个分量:$T[n]&#x3D;B[n]+C[n],Y[n]&#x3D;A[n]*T[n]$</p>
<p>存在两个问题：</p>
<ol>
<li>在计算向量的每个分量时，都发生写读数据相关。</li>
<li>流水线效率低如果采用多功能流水线，必须频繁进行流水线切换</li>
</ol>
<p>横向处理方式对向量处理机不适合</p>
<p>即使在标量处理机中，也经常通过编译器进行指令流调度。</p>
<h5 id="纵向处理"><a href="#纵向处理" class="headerlink" title="纵向处理"></a>纵向处理</h5><p>也称为垂直处理方式，纵向加工方式等</p>
<p>$T[1]&#x3D;B[1]+C[1]$</p>
<p>$T[2]&#x3D;B[2]+C[2]$</p>
<p>…</p>
<p>$T[n]&#x3D;B[n]+C[n]$</p>
<p>$Y[1]&#x3D;A[1]*T[1]$</p>
<p>$Y[2]&#x3D;A[2]*T[2]$</p>
<p>…</p>
<p>$Y[n]&#x3D;A[n]*T[n]$</p>
<p>采用向量指令只需要2条</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">vadd b,c,t
vmul a,t,y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这种处理方式适用于向量处理机</p>
<p>数据相关不影响流水线连续工作。不同的运算操作只需要切换1次</p>
<h5 id="纵横处理方式"><a href="#纵横处理方式" class="headerlink" title="纵横处理方式"></a>纵横处理方式</h5><p>将长度为n的向量分成若干组，每组长度为m，组内按纵向方式处理，依次处理各组。</p>
<p>用于寄存器-寄存器结构的向量处理机中</p>
<p>向量寄存器的长度是有限的，例如，每个向量寄存器有64个寄存器。当向量长度N大于向量寄存器长度n时，需要分组处理。</p>
<p>分组方法<br>$$<br>n&#x3D;K \cdot m+r<br>$$<br>其中：ｒ为余数，共分Ｋ＋１组</p>
<p>组内采用纵向处理方式，组间采用横向处理方式。因此，也称为分组处理方式，纵横向加工方式等。</p>
<h4 id="向量结构风格"><a href="#向量结构风格" class="headerlink" title="向量结构风格"></a>向量结构风格</h4><ul>
<li>内存-内存的向量处理机<ul>
<li>All  vector operations are memory to memory</li>
</ul>
</li>
<li>向量-寄存器处理器<ul>
<li>All vector operations between vector registers (except vector load and store)</li>
<li>Vector equivalent of load-store architectures</li>
<li>Includes all vector machines since late 1980s</li>
<li>We assume vector-register for rest of the lecture</li>
</ul>
</li>
</ul>
<p>以下的结构都假设为向量-寄存器</p>
<p>下图说明一个具有8个存储体的向量处理机：多体交叉+并行访问 </p>
<p>三条互相独立的数据通路，可并行工作，同一个存储模块同时只能为一个通路服务</p>
<p><img src="/imgs/ca/164.png" alt="image-20231225164452175"></p>
<p>寄存器-寄存器结构</p>
<ul>
<li>使主存有较高带宽的一种方法是形成一个层次结构的存储器系统。当处理器需要向量时，把向量从主存送到速度最快的存储器。运算结果也先送到速度最快的中间存储器。</li>
<li>中间存储器起着数据的中间存储作用，功能上相当于寄存器，因此称为寄存器-寄存器型向量处理机。</li>
<li>把存储器-存储器结构中的缓冲栈改为向量寄存器，运算部件需要的操作数从向量寄存器中读取，运算的中间结果也写到向量寄存器中。</li>
<li>向量寄存器与标量寄存器的主要差别是：<ul>
<li>一个向量寄存器能够保存一个向量，例如：64个64位寄存器。</li>
<li>连续访问一个向量的各个分量。</li>
<li>需要有标量寄存器和地址寄存器等。</li>
</ul>
</li>
<li>采用寄存器-寄存器结构的主要优点：降低主存储器的流量。例如：采用寄存器-寄存器结构的CRAY-1与采用存储器-存储器结构的STAR-100比较，运算速度高3倍多，而主存流量低2.5倍。</li>
</ul>
<p><img src="/imgs/ca/165.png" alt="image-20231225164628337"></p>
<p>CRAY1向量处理机结构</p>
<h3 id="向量处理机的组成"><a href="#向量处理机的组成" class="headerlink" title="向量处理机的组成"></a>向量处理机的组成</h3><h4 id="标量CPU"><a href="#标量CPU" class="headerlink" title="标量CPU"></a>标量CPU</h4><p>registers, datapaths, instruction fetch logic</p>
<h4 id="向量寄存器"><a href="#向量寄存器" class="headerlink" title="向量寄存器"></a>向量寄存器</h4><ul>
<li>Fixed length memory bank holding a single vector 固定长度的存储区可容纳单个向量</li>
<li>Has at least 2 read and 1 write ports 至少<strong>2读1写</strong>端口</li>
<li>Typically 8-32 vector registers, each holding 1 to 8 Kbits 通常为 8-32 个向量寄存器，每个寄存器可容纳 1 至 8 Kbits</li>
<li>Can be viewed as array of 64b, 32b, 16b, or 8b elements</li>
</ul>
<h3 id="基础向量指令"><a href="#基础向量指令" class="headerlink" title="基础向量指令"></a>基础向量指令</h3><p><img src="/imgs/ca/166.png" alt="image-20231225170417584"></p>
<h3 id="向量内存操作"><a href="#向量内存操作" class="headerlink" title="向量内存操作"></a>向量内存操作</h3><p>加载&#x2F;存储操作在寄存器和内存之间移动数据组</p>
<p>三种寻址方式</p>
<ul>
<li>单位跨步Unit stride<ul>
<li>最快</li>
</ul>
</li>
<li>Non-unit (constant) stride无单位跨步</li>
<li>索引indexed<ul>
<li>寄存器间接的向量等效</li>
<li>适用于稀疏数据数组</li>
<li>增加向量化的程序数</li>
</ul>
</li>
<li>支持存储器和寄存器中数据宽度的各种组合</li>
</ul>
<h3 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>对数组的操作进行向量化</li>
<li>向量化发生在任何类型的循环（显式或隐式）中</li>
<li>只有最内层的循环是向量化的</li>
<li>数据相关性会抑制向量化;然后连续计算结果。</li>
<li>向量寄存器允许将数组值存储在非常靠近功能单元的位置。</li>
<li>一旦加载了向量寄存器，由于流水线，操作数可以在每个时钟周期内被泵入功能单元（生成结果）<ul>
<li>理想情况下，每个向量元素一个 FU，但这可能不太可能</li>
</ul>
</li>
<li>向量化通过增加流入功能单元的数据带宽来提高持续性能。</li>
</ul>
<h4 id="向量化的两种方法"><a href="#向量化的两种方法" class="headerlink" title="向量化的两种方法"></a>向量化的两种方法</h4><ul>
<li>内循环向量化<ul>
<li>比如说，把机器想象成 32 个向量寄存器，每个寄存器有 16 个元素</li>
<li>1 条指令更新 1 个向量寄存器的 32 个元素</li>
<li>适用于向量化一维数组或常规内核（例如 saxpy）</li>
</ul>
</li>
<li>外循环向量化<ul>
<li>外层循环向量化是一种用于增强性能的技术。最内层循环中的迭代数量较小。此时，对最内层循环进行向量化有些得不偿失。</li>
<li>将机器想象成 16 个“虚拟处理器”（VP），每个处理器有 32 个标量寄存器！（多线程处理器）</li>
<li>1 条指令在 16 个 VP 中更新 1 个标量寄存器</li>
<li>适用于不规则内核或在内部循环中具有循环携带依赖关系的内核</li>
</ul>
</li>
<li>这只是编译器的两个视角<ul>
<li>两者的硬件相同</li>
</ul>
</li>
</ul>
<h3 id="向量的实现"><a href="#向量的实现" class="headerlink" title="向量的实现"></a>向量的实现</h3><h4 id="向量寄存器文件"><a href="#向量寄存器文件" class="headerlink" title="向量寄存器文件"></a>向量寄存器文件</h4><ul>
<li>每个寄存器都是一个元素数组</li>
<li>每个寄存器的大小决定了最大向量长度</li>
<li>向量长度寄存器确定特定操作的向量长度</li>
</ul>
<p>多个并行执行单元 &#x3D;“流水线”</p>
<p><img src="/imgs/ca/167.png" alt="image-20231225173337631"></p>
<h4 id="向量的长度"><a href="#向量的长度" class="headerlink" title="向量的长度"></a>向量的长度</h4><p>在运行之前不知道向量的实际长度</p>
<p>向量长度寄存器 （VLR） 控制任何向量操作的长度，包括向量加载或存储。</p>
<p>（向量真实长度不能&gt;向量寄存器的长度）</p>
<p>VLR中的值不能大于MVL</p>
<p>如果向量真实长度长于最大长度，则使用一种称为strip mining的技术。</p>
<p>当循环次数n大于MVL(maximum vector length)时，需要把总的循环拆分为多个小的循环，即strip mining，以满足要求。其本质为将很长的重复循环分割嵌套为小的循环，以便编译器完成工作。</p>
<h5 id="strip-mining"><a href="#strip-mining" class="headerlink" title="strip mining"></a>strip mining</h5><ul>
<li><p>生成代码，其中对大小不大于 MVL 的向量运算进行。</p>
</li>
<li><p>创建 2 个循环</p>
<ul>
<li>一个处理任意数量的迭代倍数的 MVL。</li>
<li>另一个用于处理剩余迭代。</li>
</ul>
</li>
<li><p>代码变得可向量化。</p>
</li>
<li><p>需要小心处理 VLR。</p>
</li>
<li><p>生成每次迭代处理 MVL 元素的循环</p>
</li>
<li><p>对 MVL 元素的集合运算被转换为单个向量指令</p>
</li>
</ul>
<h3 id="向量跨步"><a href="#向量跨步" class="headerlink" title="向量跨步"></a>向量跨步</h3><p>将要收集到单个寄存器中的元素之间的距离称为跨步</p>
<ul>
<li>我们想要的元素在内存中的位置可能不是连续的。</li>
<li>向量跨步与向量起始地址一样，可以放在通用寄存器中，因此只需要一次加载或存储。</li>
<li>然后，可以使用 VMIPS 指令 LVWS（带跨步的加载向量）将向量提取到向量寄存器中。</li>
<li>同样，当存储非单位跨步向量时，可以使用 SVWS（存储跨步向量）。</li>
</ul>
<h3 id="优化向量处理机"><a href="#优化向量处理机" class="headerlink" title="优化向量处理机"></a>优化向量处理机</h3><ul>
<li>Chaining链接</li>
<li>Conditionally Executed Statements有条件执行的语句</li>
<li>Sparse Matrices稀疏矩阵</li>
<li>Multiple Lanes多流水线</li>
<li>Pipelined Instruction Start-Up流水指令启动</li>
</ul>
<h4 id="chaining"><a href="#chaining" class="headerlink" title="chaining"></a>chaining</h4><ul>
<li>向量寄存器 （V1） 不是一个单一的实体，而是一组单独的寄存器</li>
<li>流水线转发可以处理单个向量元素</li>
</ul>
<p>灵活链接：允许向量链接到任何其他活动向量操作 &#x3D; &gt; 多个读&#x2F;写端口</p>
<ol>
<li><p>向量指令的类型</p>
<p>以CRAY-1向量处理机为例，有四类指令，两种指令格式</p>
<ol>
<li>向量与向量操作，	Vi¬Vj  OP  Vk</li>
<li>向量与标量操作，	Vi ¬ Sj  OP  Vk</li>
<li>向量取，	Vi¬存储器</li>
<li>向量存，	存储器¬ Vi</li>
</ol>
<p><img src="/imgs/ca/170.png" alt="image-20231225181123554"></p>
<p><img src="/imgs/ca/171.png" alt="image-20231225181146205"></p>
</li>
<li><p>向量运算中的相关和冲突</p>
<p>向量运算中的数据相关和功能部件冲突：采用顺序发射顺序完成方式</p>
<ol>
<li>写读数据相关。</li>
<li>读读数据相关，或向量寄存器冲突。</li>
</ol>
<p>指并行工作的向量指令中的源向量或结果向量使用相同的向量寄存器。</p>
<ol start="3">
<li>运算部件冲突。</li>
</ol>
<p>同一功能部件为多条并行工作的向量指令所使用</p>
<p>在理想情况下，若有m个功能部件并行工作，可使运算速度提高m倍。但实际上，由于程序本身并行性有限，并可能发生上述两种冲突，因此能完全并行工作的功能部件数总是小于m。</p>
</li>
</ol>
<p><img src="/imgs/ca/172.png" alt="image-20231225181934360"></p>
<p>结果寄存器可能成为后继指令的操作数寄存器</p>
<p>两条有RAW数据相关的向量指令并行执行，这种技术称为两条流水线的链接技术。</p>
<p>例如：有如下3条向量指令：<br> V3 ¬ A<br> V2 ¬ V0＋V1<br> V4 ¬ V2×V3<br>第一、二条指令没有数据相关和功能部件冲突，可以同时开始执行。第三条指令与第一、二条指令均存在写读数据相关，可以链接执行。</p>
<p><img src="/imgs/ca/168.png" alt="image-20231225182639925"></p>
<p><img src="/imgs/ca/169.png" alt="image-20231225182705120"></p>
<p>实现链接的条件</p>
<ol>
<li>没有向量寄存器冲突和运算部件冲突。</li>
<li>只有第一个结果送入向量寄存器的那一个周期可以链接。</li>
<li>先行的两条指令产生运算结果的时间必须相等。</li>
<li>两条向量指令的向量长度必须相等。</li>
</ol>
<h4 id="多流水线实现"><a href="#多流水线实现" class="headerlink" title="多流水线实现"></a>多流水线实现</h4><p><img src="/imgs/ca/173.png" alt="image-20231225183038650"></p>
<ul>
<li>向量寄存器的元素在流水线之间交错</li>
<li>每条流水线都接受相同的控制</li>
<li>每个周期执行多个元素操作</li>
<li>模块化、可扩展设计</li>
<li>对于大多数向量指令，无需通道间通信</li>
</ul>
<p><img src="/imgs/ca/174.png" alt="image-20231225183414388"></p>
<h4 id="向量条件执行"><a href="#向量条件执行" class="headerlink" title="向量条件执行"></a>向量条件执行</h4><p>Want to vectorize loops with conditional code</p>
<p>添加向量掩码（或标志）寄存器</p>
<p><img src="/imgs/ca/175.png" alt="image-20231225184207035"></p>
<h5 id="压缩-x2F-扩展操作"><a href="#压缩-x2F-扩展操作" class="headerlink" title="压缩&#x2F;扩展操作"></a>压缩&#x2F;扩展操作</h5><ul>
<li>Compress 在目标向量寄存器开始时连续打包来自一个向量寄存器的非屏蔽元素<ul>
<li>掩码向量的种群计数给出填充向量长度</li>
</ul>
</li>
<li>Expand 执行逆运算</li>
</ul>
<p>用于密度-时间条件，也用于常规选择操作</p>
<h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><ul>
<li>到目前为止，使用稀疏矩阵无法有效地实现（例如，缺乏SPICE的矢量化）</li>
<li>在稀疏矩阵中，向量的元素通常存储在一些压缩的 from，然后间接访问</li>
<li>假设：A 和 C 是稀疏向量<br>DO100 i &#x3D; 1，n<br>100A（K（i）） &#x3D; A（K（i）） + C（M（i））</li>
<li>稀疏矩阵的表示<ul>
<li>使用索引向量（例如K和M）来指定稀疏矩阵的非零元素，或</li>
<li>使用位向量表示存在哪些元素，使用密集向量表示非零元素</li>
</ul>
</li>
<li>分散-聚集操作<ul>
<li>Gather （LVI） 操作采用索引向量，并通过将基址添加到向量注册器中的索引向量 &#x3D;a non-sparse-vector 中给出的偏移量&gt;来获取元素位于给定地址的向量</li>
<li>在以密集形式对这些元素进行操作后，稀疏向量可以通过散射 （SVI） 存储以扩展形式存储，使用相同的索引向量</li>
</ul>
</li>
</ul>
<h4 id="流水线指令启动"><a href="#流水线指令启动" class="headerlink" title="流水线指令启动"></a>流水线指令启动</h4><ul>
<li>最简单的情况是当两个向量指令访问一组不同的向量寄存器时。</li>
<li>例如，在代码序列中<br>ADDV.V V1，V2，V3<br>     ADDV.V V4，V5，V6</li>
<li>通过允许一个向量指令的开始与前面向量指令的完成重叠来减少启动开销变得至关重要。</li>
<li>实现可以允许第二个向量指令的第一个元素紧随第一个向量指令的最后一个元素沿着 FP 加法器管道向下移动。</li>
</ul>
<h3 id="采用多处理机系统结构"><a href="#采用多处理机系统结构" class="headerlink" title="采用多处理机系统结构"></a>采用多处理机系统结构</h3><p>前面所讲的三种技术措施都是在单处理机结构的向量计算机上实现的。为了更有效地提高向量处理性能，新型向量机采用了多处理机系统结构。    </p>
<p>CRAY-1是单处理机系统结构的向量计算机，诞生于20世纪70年代中期，时钟周期为12.5ns。8 0年代推出的CRAY-2、CRAY X-MP，90年代推出的CRAY Y-MP、C90，基本上仍保持了CRAY-1的基本系统结构，但是它们已发展成为多处理机的系统结构。例如CRAY-2发展成为4个向量处理机，时钟周期缩短到4.1ns，运算速度提高到480MIPS，浮点运算最高可达1800MFLOPS。CRAY Y-MP，C90最多可以有16个向量处理机。    </p>
<p>CRAY X-MP的结构由4个CPU组成。CPU的结构同CRAY-1向量处理机相似。 </p>
<h3 id="向量化编译技术"><a href="#向量化编译技术" class="headerlink" title="向量化编译技术"></a>向量化编译技术</h3><h4 id="向量化基本功能"><a href="#向量化基本功能" class="headerlink" title="向量化基本功能"></a>向量化基本功能</h4><h5 id="并行性检测"><a href="#并行性检测" class="headerlink" title="并行性检测"></a>并行性检测</h5><p>是否可用向量表示。</p>
<p>是否存在相关、条件语句、操作数的间接访问等。</p>
<h5 id="并行性表示与开发"><a href="#并行性表示与开发" class="headerlink" title="并行性表示与开发"></a>并行性表示与开发</h5><p>用向量指令代替循环，用屏蔽向量实现条件判断。</p>
<p>指令系统具有向量功能，编译程序支持向量操作。</p>
<h4 id="向量化编译优化"><a href="#向量化编译优化" class="headerlink" title="向量化编译优化"></a>向量化编译优化</h4><h5 id="通用优化方法"><a href="#通用优化方法" class="headerlink" title="通用优化方法"></a>通用优化方法</h5><p>公共子表达式消除、常数调入、复制语句传递等。</p>
<h5 id="循环体优化"><a href="#循环体优化" class="headerlink" title="循环体优化"></a>循环体优化</h5><p>固定表达式移出、归约变量消除，向量指令表示等</p>
<h5 id="向量寄存器优化分配"><a href="#向量寄存器优化分配" class="headerlink" title="向量寄存器优化分配"></a>向量寄存器优化分配</h5><p>重新分配向量寄存器，减少向量寄存器使用冲突</p>
<h5 id="向量指令并行化"><a href="#向量指令并行化" class="headerlink" title="向量指令并行化"></a>向量指令并行化</h5><p>重新排序向量指令，减少流水功能转换频率，争取功能部件并行操作、向量指令链接。</p>
<h4 id="向量处理带宽问题处理"><a href="#向量处理带宽问题处理" class="headerlink" title="向量处理带宽问题处理"></a>向量处理带宽问题处理</h4><p>多条向量流水同时进行，要求存储器带宽较大。</p>
<p>解决：可以通过多体交叉存储器和多层次存储系统实现。</p>
<p>向量指令中分量步长可变，向量存储满足按行、列、对角线等方式访问。</p>
<p>解决：根据存储体数量或互连网络决定向量的存储方式。</p>
<p>I&#x2F;O带宽与存储器带宽的协调。</p>
<h3 id="向量处理机的性能评价"><a href="#向量处理机的性能评价" class="headerlink" title="向量处理机的性能评价"></a>向量处理机的性能评价</h3><p>衡量向量处理机性能的主要指标有： 向量指令处理时间$T_{vp}$、 最大性能$R_￥$、半性能向量长度$n_{1&#x2F;2}$等</p>
<h4 id="向量指令处理时间-T-vp"><a href="#向量指令处理时间-T-vp" class="headerlink" title="向量指令处理时间$T_{vp}$"></a>向量指令处理时间$T_{vp}$</h4><p>执行一条向量长度为n的向量指令的时间Tvp表示为：<br>$$<br>T_{vp}&#x3D;T_s+T_{vf}+(n-1)T_c<br>$$<br>其中：Ts为向量流水线的建立时间。 Tvf为向量流水线的流过时间。 Tc为流水线“瓶颈”段的执行时间。</p>
<p>如果每段执行时间都等于一个时钟周期，则有：<br>$$<br>\mathrm{T_{vp}&#x3D;[s+e+(n-1)]t}<br>$$<br>其中：s为向量流水线建立时间所需的时钟周期数。e为向量流水线流过时间所需的时钟周期数。 n为向量长度。t为时钟周期长度。<br>把几条能在一个时钟周期内同时开始执行的向量指令称为一个编队，同一个编队中的指令一定不存在功能部件冲突和数据相关。</p>
<h4 id="最大性能-R-￥"><a href="#最大性能-R-￥" class="headerlink" title="最大性能$R_￥$"></a>最大性能$R_￥$</h4><p>表示当向量长度为无穷大时的向量流水线的最大性能</p>
<p>常在评价峰值性能时使用，单位为MFLOPS</p>
<p><img src="/imgs/ca/176.png" alt="image-20231225191100898"></p>
<p>n为向量长度；Tn为一组向量操作的整个执行时间。</p>
<p>对于某向量机，Tn&#x3D;4n+64，假设时钟频率为200MHZ。每个循环有2个浮点操作<br>$$<br>R\infty&#x3D;\frac{2\times200\textit{MHZ}}{ \lim _ { n \to \infty }\left\lceil\frac{4n+64}n\right\rceil}&#x3D;\frac{2\times200\textit{MHZ}}{ 4 }&#x3D;100\textit{MFLOPS}<br>$$</p>
<h4 id="半性能向量长度-n-1-x2F-2"><a href="#半性能向量长度-n-1-x2F-2" class="headerlink" title="半性能向量长度$n_{1&#x2F;2}$"></a>半性能向量长度$n_{1&#x2F;2}$</h4><ul>
<li>为达到一半R¥值所需的向量长度称为半性能向量长度n1&#x2F;2。</li>
<li>主要评价向量流水线建立时间对性能的影响</li>
</ul>
<p><img src="/imgs/ca/177.png" alt="image-20231225191400922"></p>
<h3 id="向量处理机的发展"><a href="#向量处理机的发展" class="headerlink" title="向量处理机的发展"></a>向量处理机的发展</h3><h4 id="向量计算机系统结构的发展趋势"><a href="#向量计算机系统结构的发展趋势" class="headerlink" title="向量计算机系统结构的发展趋势"></a>向量计算机系统结构的发展趋势</h4><ul>
<li>提供多种向量运算指令。</li>
<li>除具有向量处理功能外还有其它功能。</li>
<li>采用多层次的存储器系统。</li>
<li>流水线技术与并行技术相结合。</li>
</ul>
<h4 id="向量计算机系统结构要解决的六个技术问题"><a href="#向量计算机系统结构要解决的六个技术问题" class="headerlink" title="向量计算机系统结构要解决的六个技术问题"></a>向量计算机系统结构要解决的六个技术问题</h4><h5 id="处理机带宽"><a href="#处理机带宽" class="headerlink" title="处理机带宽"></a>处理机带宽</h5><ol>
<li>运算部件采用流水线结构。</li>
<li>用多个运算器构成并行系统</li>
</ol>
<h5 id="存储器带宽"><a href="#存储器带宽" class="headerlink" title="存储器带宽"></a>存储器带宽</h5><ul>
<li>用多个独立的存储体构造一个大容量的存储器系统。</li>
<li>采用多层次的存储器系统提高访问速度。</li>
<li>采用高速缓冲存储器和可寻址的寄存器组效果最好。</li>
<li>采用流水线技术，存储系统的访问速度快5～20倍。</li>
</ul>
<h5 id="输入-x2F-输出带宽"><a href="#输入-x2F-输出带宽" class="headerlink" title="输入&#x2F;输出带宽"></a>输入&#x2F;输出带宽</h5><p>许多高性能向量处理机配备10 ~ 29个DMA通道</p>
<h5 id="通信带宽"><a href="#通信带宽" class="headerlink" title="通信带宽"></a>通信带宽</h5><p>共享存储器或互连网络</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>多流水线结构通过控制程序使所有流水线同步工作</p>
<p>Cray-1系统采用流水线互锁来控制向量操作，不冲突的操作可以并行地执行，相关的操作尽可能链接起来重叠地进行</p>
<h5 id="多用途"><a href="#多用途" class="headerlink" title="多用途"></a>多用途</h5><p>非数值计算问题</p>
<h4 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h4><ul>
<li>通过流水线存取方式有效地提高了存储器的带宽。</li>
<li>流水结构的运算器有很高的性能价格比。</li>
<li>非常简单的机制就能满足通信和同步的要求</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>重点</strong></p>
<ol>
<li>三种向量处理方式；</li>
<li>存储器存储器结构，寄存器－寄存器结构；</li>
<li>链接技术，中间结果不必送回存储器，而且在向量操作完成以前就使用</li>
</ol>
<h2 id="互连网络"><a href="#互连网络" class="headerlink" title="互连网络"></a>互连网络</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinbaosite/article/details/70244437">【计算机系统结构】 互连网络-CSDN博客</a></p>
<p>互连网络是一种由开关元件按照一定的拓扑结构和控制方式构成的网络，用于实现计算机系统内部多个处理机或多个功能部件之间的相互连接。</p>
<p><strong>formalism</strong></p>
<p>network is a graph V &#x3D; {switches and nodes} connected by 通讯信道 C</p>
<p>信道有宽度w和信道速率$f&#x3D;1&#x2F;\tau$</p>
<ul>
<li>信道带宽b&#x3D;wf</li>
<li>每个周期传输的 PHIT（物理单位）数据</li>
<li>FLIT - 流量控制的基本单元</li>
</ul>
<p>输入（输出）通道数为开关度</p>
<p>开关和链路的顺序后跟一条消息就是路由</p>
<p><strong>网络</strong></p>
<ul>
<li>拓扑结构<ul>
<li>网络图的物理互联结构</li>
<li>直接：连接到每个交换机的节点</li>
<li>间接：连接到特定交换机子集的节点</li>
</ul>
</li>
<li>路由算法<ul>
<li>限制 MSG 可能遵循的路径集</li>
<li>许多具有不同属性的算法<ul>
<li>避免僵局</li>
</ul>
</li>
</ul>
</li>
<li>交换策略<ul>
<li>MSG 中的数据如何遍历路由</li>
<li>电路交换与分组交换</li>
</ul>
</li>
<li>流量控制机制<ul>
<li>当 MSG 或其部分遍历路由时</li>
<li>遇到流量时会发生什么情况</li>
</ul>
</li>
</ul>
<p><strong>组织结构</strong></p>
<ul>
<li>处理器<ul>
<li>数据路径+控制逻辑</li>
<li>通过检查数据路径中的寄存器传输来确定控制逻辑</li>
</ul>
</li>
<li>网络<ul>
<li>链接</li>
<li>开关</li>
<li>网络接口</li>
</ul>
</li>
</ul>
<p><strong>链接设计&#x2F;工程空间</strong></p>
<p>一根或多根电线&#x2F;光纤的电缆，末端有连接器连接到交换机&#x2F;开关或接口</p>
<p><img src="/imgs/ca/178.png" alt="image-20231225201107598"></p>
<p><strong>开关</strong></p>
<p><img src="/imgs/ca/179.png" alt="image-20231225201403840"></p>
<ul>
<li>输出端口<br>发送器（通常驱动时钟和数据）</li>
<li>输入端口<ul>
<li>同步器将数据信号与本地时钟域对齐</li>
<li>本质上是FIFO缓冲器</li>
</ul>
</li>
<li>横梁<ul>
<li>将每个输入连接到任何输出</li>
<li>受面积或引脚排列限制的度数</li>
</ul>
</li>
<li>缓冲</li>
<li>控制逻辑<ul>
<li>复杂性取决于路由逻辑和调度算法</li>
<li>确定每个传入数据包的输出端口</li>
<li>在指向同一输出的输入之间进行仲裁</li>
</ul>
</li>
</ul>
<h3 id="互连网络基本概念"><a href="#互连网络基本概念" class="headerlink" title="互连网络基本概念"></a>互连网络基本概念</h3><p>结构特征</p>
<ol>
<li>通信方式<br>同步：同步地建立通信路径<br>异步：动态地提出连接请求以建立通信路径<br>混合型：同步+ 异步 </li>
<li>控制策略：控制网络中开关元件的状态以实现路径选择<br>集中、分散</li>
<li>交换方式<br>线路交换：在发送和接收之间建立一条物理线路<br>分组交换：数据打包，多条路径传送 </li>
<li>拓扑结构：网络的构造<br>静态拓扑：结点之间的连接路径是固定的，不重可配置<br>动态拓扑：使用开关元件，结点之间的路径可重配置</li>
</ol>
<h4 id="互连网络作用"><a href="#互连网络作用" class="headerlink" title="互连网络作用"></a>互连网络作用</h4><ul>
<li>用来实现计算机系统内部多个处理机或多个功能部件之间的相互连接。</li>
<li>互连网络已成为并行处理系统的核心组成部分。</li>
<li>互连网络对整个计算机系统的性能价格比有着决定性的影响。</li>
<li>基本功能 <ul>
<li>互连网络（IN）主要完成结点与结点间的连接，连接和控制方式不同，连接效果不同。 </li>
<li>结点（node）: 处理单元（PE、处理机）、存储器</li>
</ul>
</li>
</ul>
<p>具有本地存储器、私有高速缓存、共享存储器和共享外围设备的一般处理机系统的互连结构</p>
<p><img src="/imgs/ca/180.png" alt="image-20231225201759452"></p>
<p><img src="/imgs/ca/181.png" alt="image-20231225201818388"></p>
<h4 id="互连函数"><a href="#互连函数" class="headerlink" title="互连函数"></a>互连函数</h4><p>将互连网的N个输入和N个输出端分别用整数（0，1，2，…，N-1）来表示，则表示相互连接的输出端号和输入端号之间的一一对应关系称为互连函数</p>
<p>为了在输入结点与输出结点之间建立对应关系，互连网络有三种表示方法：</p>
<ol>
<li>互连函数表示法：如：f(xn-1…x1x0)&#x3D;x0xn-2…x1xn-1自变量和函数可以用二进制表示，也可以用十进制等表示</li>
<li>图形表示法	</li>
<li>输入输出对应表示法</li>
</ol>
<p><strong>常见互联函数</strong></p>
<h5 id="恒等置换"><a href="#恒等置换" class="headerlink" title="恒等置换"></a>恒等置换</h5><p>$$<br>I(x_{n-1}x_{n-2}…x_1x_0)&#x3D;x_{n-1}x_{n-2}…x_1x_0<br>$$</p>
<h5 id="交换置换"><a href="#交换置换" class="headerlink" title="交换置换"></a>交换置换</h5><p>实现二进制地址编号中第k(如0）位位置不同的输入和输出端之间的连接<br>$$<br>E(x_{n-1}x_{n-2}…x_1x_0){&#x3D;}x_{n-1}x_{n-2}…x_1\overline{x_0}<br>$$</p>
<p>$$<br>\mathbb{E}(X_{n-1}X_{n-2},…X_{k+1},X_k,…X_1,X_{0})&#x3D;X_{n-1}X_{n-2},…X_{k+1}\overline{X_k}\quad X_{k-1},…X_1\quad X_0<br>$$</p>
<p>当结点数N＝8时，n&#x3D;3，可得到常用的立方体互连函数<br>$$<br>\begin{aligned}C_0(x_2x_1x_0)&amp;&#x3D;x_2x_1\overline{x_0}\\C_1(x_2x_1x_0)&amp;&#x3D;x_2\overline{x_1}x_0\\C_2(x_2x_1x_0)&amp;&#x3D;\overline{x_2}x_1x_0\end{aligned}<br>$$<br>编号的二进制数规定位数取反</p>
<p><img src="/imgs/ca/182.png" alt="image-20231225203455785"></p>
<p>交换函数主要用于超立方体互联网络</p>
<h5 id="均匀洗牌函数"><a href="#均匀洗牌函数" class="headerlink" title="均匀洗牌函数"></a>均匀洗牌函数</h5><p>均匀洗牌函数就是将输入端分成数目相等的两半，前一半和后一半按序一个隔一个地从头依次与输出端相连，类似洗扑克牌。其实质就是把输入端二进制地址循环左移一位。其函数表示为：<br>$$<br>S(X_{n-1}X_{n-2}\cdots X_1X_0)&#x3D;X_{n-2}X_{n-3}\cdots x_1\quad X_0X_{n-1}<br>$$</p>
<h5 id="逆均匀洗牌函数"><a href="#逆均匀洗牌函数" class="headerlink" title="逆均匀洗牌函数"></a>逆均匀洗牌函数</h5><p>是将输入端二进制地址编码循环右移一位而得到相应地输出端地址。<br>$$<br>S^{-1}(X_{n-1}X_{n-2}\cdots X_{1}X_{0})&#x3D;X_{0}X_{n-1}X_{n-2}\cdots X_{1}<br>$$</p>
<p>均匀洗牌与逆均匀洗牌是两种十分有用的互连函数，以它们代表的链路与以交换置换代表的开关多级组合起来可构成Omega网络与逆Omega网络。 </p>
<h5 id="子混洗"><a href="#子混洗" class="headerlink" title="子混洗"></a>子混洗</h5><p>最低k位循环左移一位</p>
<h5 id="超混洗"><a href="#超混洗" class="headerlink" title="超混洗"></a>超混洗</h5><p>最高k位循环左移一位<br>$$<br>\begin{aligned}&amp;S_{(\mathrm{k})}(\mathbf{x_{n-1}x_{n-2}}\cdots\mathbf{x_{k}x_{k-1}x_{k-2}}\cdots\mathbf{x_{1}x_{0}})&#x3D;\mathbf{x_{n-1}x_{n-2}\cdots x_{k}x_{k-2}\cdots x_{1}x_{0}x_{k+1}}\&amp;S^{(\mathrm{k})}(\mathbf{x_{n-1}x_{n-2}}\cdots\mathbf{x_{n-k}x_{n-k-1}}\cdots\mathbf{x_{1}x_{0}})&#x3D;\mathbf{x_{n-2}}\cdots\mathbf{x_{n-k}x_{n-1}x_{n-k-1}}\mathbf{x_{n-k-1}}\cdots\mathbf{x_{1}x_{0}}\end{aligned}<br>$$<br><strong>混洗移动的也是二进制位</strong></p>
<h5 id="蝶式函数"><a href="#蝶式函数" class="headerlink" title="蝶式函数"></a>蝶式函数</h5><p>是将输入二进制地址的最高位和最低位互换位置，所以蝶式互连函数定义为<br>$$<br>B(x_{n-1}x_{n-2}\cdots x_1x_0)&#x3D;x_0x_{n-2}\cdots x_1x_{n-1}<br>$$<br>给出了N&#x3D;8的蝶式函数变换图形。与均匀混洗函数类似，只用蝶式函数不能实现任意结点之间的连接。但是蝶式变换与交换变换的多级组合可作为构成方体多级网络的基础。</p>
<h5 id="子蝶式"><a href="#子蝶式" class="headerlink" title="子蝶式"></a>子蝶式</h5><p>最低k位的高低位互换</p>
<h5 id="超蝶式"><a href="#超蝶式" class="headerlink" title="超蝶式"></a>超蝶式</h5><p>最高k位的高低位互换</p>
<p><img src="/imgs/ca/183.png" alt="image-20231225205823624"></p>
<h5 id="反位序函数"><a href="#反位序函数" class="headerlink" title="反位序函数"></a>反位序函数</h5><p>反位序函数是将输入端二进制地址的位序颠倒过来求得相应输出端的地址</p>
<p>互连函数表示如下<br>$$<br>\mathsf{R}\left(\mathrm{X_{n-1}X_{n-2}\ldots X_1x_0}\right)&#x3D;\mathrm{x_0x_1\ldots x_{n-1}}<br>$$<br>对于N&#x3D;8的情况，正好有B(x)函数等于R(x)函数。</p>
<p>子反位序函数，最低k位的位序反过来</p>
<p>超反位序函数，最高k位的位序反过来</p>
<p><img src="/imgs/ca/184.png" alt="image-20231225210147683"></p>
<h5 id="PM2O函数"><a href="#PM2O函数" class="headerlink" title="PM2O函数"></a>PM2O函数</h5><p>PM2I函数是一种移数函数，它是将输入端数组循环移动一定的位置向输出端传输。其函数表示为<br>$$<br>\begin{array}{c}\mathrm{PM2+i(x)&#x3D;x+2i<del>modN}\\mathrm{PM2-i(x)&#x3D;x-2i</del>modN}\end{array}<br>$$<br>其中$0\le x\le N - 1, 0\le i\le n - 1, n&#x3D;log_2N$N为结点数。显然，PM2I互连网络共有2n个互连函数。类似地也有子、超移数函数</p>
<p>题目给出处理机编号和题目给出处理机的个要看清楚</p>
<h4 id="互连网络的特性和传输的性能参数"><a href="#互连网络的特性和传输的性能参数" class="headerlink" title="互连网络的特性和传输的性能参数"></a>互连网络的特性和传输的性能参数</h4><p><strong>特性</strong></p>
<p>互连网络通常是用有向边或无向边连接有限个结点的组成。</p>
<ol>
<li>网络规模：网络中结点的个数</li>
<li>结点度：与结点相连接的边数称为结点度。包括入度和出度。进入结点的边数叫入度，从结点出来的边数则叫出度</li>
<li>距离：两个结点之间相连的最少边数</li>
<li>网络直径：网络中任意两个结点间距离的最大值。用结点间的连接边数表示</li>
<li>结点间的线长：两个结点间连线的长度。用米、公里等表示</li>
<li>对称性：从任何结点看到拓扑结构都是一样的网络称为对称网络。对称网络比较易实现，编程也较容易</li>
</ol>
<p><strong>性能参数</strong></p>
<ol>
<li>频带宽度(Bandwidth)：互连网络传输信息的最大速率。</li>
<li>传输时间(Transmission time)：等于消息长度除以频宽。</li>
<li>飞行时间(Time of flight)：第一位信息到达接收方所花费的时间。</li>
<li>传输时延(Transport latency)：等于飞行时间与传输时间之和。</li>
<li>发送方开销(Sender overhead)：处理器把消息放到互连网络的时间。</li>
<li>接收方开销(Receiver overhead)：处理器把消息从网络取出来的时间。</li>
</ol>
<p>一个消息的总时延可以用下面公式表示：</p>
<p>总时延＝发送方开销＋飞行时间＋消息长度&#x2F;频宽＋接收方开销</p>
<p><img src="/imgs/ca/185.png" alt="image-20231225212401742"></p>
<h4 id="互连网络的种类"><a href="#互连网络的种类" class="headerlink" title="互连网络的种类"></a>互连网络的种类</h4><ul>
<li>静态互连网络：连接通路是固定的，一般静态互连网络不能实现任意结点到结点之间的互连。</li>
<li>循环互连网络：通过多次重复使用同一个单级互连网络以实现任意结点到结点之间的互连。</li>
<li>多级互连网络：将多套相同的单级互连网络连接起来，实现任意结点到结点之间的互连。</li>
<li>全排列互连网络：不仅能够实现任意结点到结点之间的互连，而且能够同时实现任意结点到结点之间的互连</li>
<li>全交叉开关网络：除了能够同时实现任意结点到结点之间的互连之外，还能够实现广播和多播。</li>
</ul>
<h5 id="静态互连网络"><a href="#静态互连网络" class="headerlink" title="静态互连网络"></a>静态互连网络</h5><p>静态互连网络是指在各结点间有专用的连接通路，且在运行中不能改变的网络。在静态互连网络中，每一个开关元件固定地与一个结点相连，建立该结点与邻近结点之间的连接通路，直接实现两结点间的通信。</p>
<p><img src="/imgs/ca/186.png" alt="image-20231225212500248"></p>
<ol>
<li><p>线性阵列</p>
</li>
<li><p>环和带弦环</p>
<p>采用移数函数</p>
<ul>
<li>单向环行网：右环网采用PM2+0函数，左环网采用PM2-0函数，对称，直径是N，结点度是2</li>
<li>双向环行网：又称一维邻居网，采用{PM2+0，PM2-0}函数，对称，直径为N&#x2F;2 ，结点度是2 </li>
<li>弦环网：增加的弦愈多，则结点度愈高，网络直径愈小。</li>
<li>循环移数网络：将每个结点与其距离为2的整数幂的结点连接构成。</li>
</ul>
<p>循环移数网的结点度为2n-1，直径为$\lceil n&#x2F;2 \rceil$</p>
</li>
<li><p>循环移数网络</p>
</li>
<li><p>树形和星形</p>
<ul>
<li>二叉树：一棵k层二叉树有N＝2k－1个结点，结点度是3，直径是2(k-1)。</li>
<li>星形：一种特殊的2层树，结点度很高，为d&#x3D;N-1，直径是2。</li>
<li>二叉胖树：缓解了根结点通信速度高的矛盾</li>
</ul>
<p><img src="/imgs/ca/187.png" alt="image-20231225212958882"></p>
</li>
<li><p>胖树形</p>
</li>
<li><p>网格和环网形</p>
<ul>
<li>是一种比较流行的网络结构，有各种变体形式。在Illiac IV、MPP、DAP、CM-2和Inetl Paragon中得到了实现。</li>
<li>一般网格网，N＝nk 结点的k维网格的结点度为2k，直径为k(n-1)。</li>
<li>环网形网格网沿阵列每行每列都有环形连接。一个n×n二元环网的结点度为4，直径为2[n&#x2F;2]。环网是一种对称的拓扑结构。</li>
<li>Illiac IV的8×8 Illiac网格，其结点度为4，直径为7。一个n×n Illiac 网格的直径为d&#x3D;n-1，为纯网格直径的一半。</li>
</ul>
<p>二维网格拓扑结构，由于比较容易在VLSI芯片上实现，而且可扩充性也比较好，近年来在商业产品中得到了更多的应用。</p>
<p>典型的二维网格是一种$\sqrt n \times \sqrt n$格式结构，每格上有一个处理机。该网格拓扑结构有两类：一类结构在网格中的外围结点不卷绕相接，如图(a)所示。另一类结构则把外围结点卷绕相接。在后一类结构中，外围结点的接法又可分两种，一种是同一行的结点相接，同一列的结点相接，如图(b)所示，这种接法叫做圆环体卷绕。还有一种是一行的尾与下一行的头，一列的尾与下一列的头相接，叫做网格卷绕。例如Illiac Ⅳ的互连网络，它的列间是圆环体卷绕，它的行间则是网格卷绕，如图(c)所示</p>
</li>
<li><p>搏动式阵列</p>
</li>
<li><p>超立方体</p>
<p>n维立方体由N＝2n个结点, 分布在n维上, 每维有两个结点</p>
<p>网络规模为$2^n$个结点</p>
<p>结点度为n</p>
<p>直径也为n</p>
</li>
<li><p>带环立方体</p>
</li>
<li><p>k元n-立方体网络</p>
</li>
</ol>
<p>单级互连网络只能实现有限的几种连接。 </p>
<p><img src="/imgs/ca/188.png" alt="image-20231225213320123"></p>
<p>单级互联网络</p>
<ol>
<li><p>网络特性</p>
<p>任一单级互连网络均可表示成$N_入 \to N_出$</p>
<p>任一单级互连网络可实现部分结点(一对或几对)间的连接，不能实现任意多对结点间的同时连接</p>
<p>单级互连网络含义：某些连接方法或拓扑结构</p>
</li>
<li><p>单级互连网络应用</p>
<p>利用单级互连网络的特性作为实际IN的拓扑结构</p>
<p>通过交换开关作为IN的可变因素；</p>
<p>通过交换开关多次控制实现IN的结点间任意互连。</p>
</li>
</ol>
<p>静态网络特性比较</p>
<table>
<thead>
<tr>
<th>网络类型</th>
<th>结点度d</th>
<th>网络直径D</th>
<th>链路数l</th>
<th>等分宽度B</th>
<th>对称性</th>
<th>网络规格说明</th>
</tr>
</thead>
<tbody><tr>
<td>线性阵列</td>
<td>2</td>
<td>N-1</td>
<td>N-1</td>
<td>1</td>
<td>非</td>
<td>N个结点</td>
</tr>
<tr>
<td>环形</td>
<td>2</td>
<td></td>
<td>N</td>
<td>2</td>
<td>是</td>
<td>N个结点</td>
</tr>
<tr>
<td>全连接</td>
<td>N-1</td>
<td>1</td>
<td>N(N-1)&#x2F;2</td>
<td></td>
<td>是</td>
<td>N个结点</td>
</tr>
<tr>
<td>二维网格</td>
<td>4</td>
<td>2（r－1）</td>
<td>2N－2r</td>
<td>r</td>
<td>非</td>
<td>r×r网络，r＝</td>
</tr>
<tr>
<td>Illiac网</td>
<td>4</td>
<td>r－1</td>
<td>2N</td>
<td>2r</td>
<td>非</td>
<td>与r＝的带弦环等效</td>
</tr>
<tr>
<td>2维环网</td>
<td>4</td>
<td></td>
<td>2N</td>
<td>2r</td>
<td>是</td>
<td>r×r环网</td>
</tr>
<tr>
<td>超立方体</td>
<td>n</td>
<td>n</td>
<td>nN&#x2F;2</td>
<td>N&#x2F;2</td>
<td>是</td>
<td>N个结点，n＝</td>
</tr>
<tr>
<td>CCC</td>
<td>3</td>
<td></td>
<td>3N&#x2F;2</td>
<td>N&#x2F;（2k）</td>
<td>是</td>
<td>N&#x3D;k×  结点，环长k≥3</td>
</tr>
</tbody></table>
<ul>
<li>网络直径的变化范围很大。但随着硬件寻径技术不断革新，直径已不是一个严重问题，因为任意两结点间的通信延迟在高度流水线操作下几乎是固定不变的。链路数会影响网络价格，等分宽度将影响网络的带宽。</li>
<li>对称性会影响可扩展性和寻径效率。客观地说，网络的总价格随d和l增大而上升。直径小仍然是一种优点。但是，结点间的平均距离可能是一种更好的量度指标。等分宽度可以用较宽的通道宽度来扩大。</li>
</ul>
<h4 id="循环互连网络"><a href="#循环互连网络" class="headerlink" title="循环互连网络"></a>循环互连网络</h4><p>一般静态互连网不能实现任意两结点之间的互连。有两种解决办法：</p>
<ul>
<li>循环互连网：多次重复使用同一个单级互连网络</li>
<li>多级互连网：将多套相同的单级互连网络连接起来前一种方法是牺牲时间换取设备，后一种方法是以设备换取时间</li>
</ul>
<p>RN为网络连接寄存器，它有三个用处：发送消息，接收消息，转发消息</p>
<h4 id="动态互连网络"><a href="#动态互连网络" class="headerlink" title="动态互连网络"></a>动态互连网络</h4><p>动态互连网络设置有源开关，因而可以根据需要借助控制信号对连接通路加以重新组合，实现所要求的通信模式。包括总线、多级互连网和交叉开关网络</p>
<ol>
<li><p>总线</p>
<p>总线系统是一组导线和插座用于处理与总线相连接的处理机、存储器模块和外围设备间的数据业务。</p>
<p>总线被称为多个功能模块间争用总线或时分总线。</p>
</li>
<li><p>开关模块</p>
<p>一个$a \times b$开关模块有a个输入和b个输出。一个二元开关则与a&#x3D;b&#x3D;2的$2 \times 2$开关模块相对应。实际中a和b通常选为$a&#x3D;b&#x3D;2^k,k&gt;&#x3D;1$。</p>
<p>最常用的二元开关：a&#x3D;b&#x3D;2。</p>
<p>每个输入可与一个或多个输出相连，但是在输出端必须避免发生冲突。一对一和一对多映射是容许的；但不容许有多对一映射。</p>
<p>只容许一对一映射时称为置换连接，称这种开关为n×n交叉开关。</p>
<p>具有直通和交换两种功能的交换开关称为二功能开关，或交换开关。用一位控制信号控制。</p>
<p>具有所有四种功能的交换开关称为四功能开关，用两位控制信号控制。</p>
</li>
</ol>
<h4 id="多级互连网络"><a href="#多级互连网络" class="headerlink" title="多级互连网络"></a>多级互连网络</h4><ul>
<li>能够实现结点到结点之间的任意互连是互连网络的一种基本功能。循环互连网络虽然能够实现结点到结点之间的任意互连，但是，其通信速度低。</li>
<li>多级互连网络采用多个相同的或不同的互连网络直接连接起来。属于组合逻辑线路，一个时钟周期就能够实现任意结点到结点之间的互连。</li>
<li>多级互连网络采用的关键技术：<ol>
<li>交换开关</li>
<li>交换开关之间的拓扑连接</li>
<li>对交换开关的不同控制方式</li>
</ol>
</li>
</ul>
<h5 id="交换开关"><a href="#交换开关" class="headerlink" title="交换开关"></a>交换开关</h5><ul>
<li>一个a×b交换开关有a个输入和b个输出。</li>
<li>最常用的二元开关：a&#x3D;b&#x3D;2。</li>
<li>每个输入可与一个或多个输出相连，但是在输出端必须避免发生冲突。一对一和一对多映射是容许的；但不容许有多对一映射。</li>
<li>只容许一对一映射时称为置换连接，称这种开关为n×n交叉开关。</li>
<li>具有直通和交换两种功能的交换开关称为二功能开关，或交换开关。用一位控制信号控制。</li>
<li>具有所有四种功能的交换开关称为四功能开关，用两位控制信号控制。</li>
</ul>
<p><img src="/imgs/ca/189.png" alt="image-20231226110337054"></p>
<p><img src="/imgs/ca/190.png" alt="image-20231226110535659"></p>
<h5 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h5><ul>
<li>前一级交换开关的输出端与后一级交换开关的输入端之间的连接模式称为拓扑结构。</li>
<li>通常采用前面介绍的互连函数实现拓扑结构</li>
<li>实际上，从结点的输出到第一级交换开关的输入，以及从最后一级交换开关的输出到结点的输入也可以采用拓扑结构连接。</li>
</ul>
<h5 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h5><p>在多级互连网络中有多级交换开关，每一级又有多个交换开关。通常有三种控制方式</p>
<ol>
<li>级控制：同一级交换开关使用同一个控制信号控制。</li>
<li>单元控制：每个交换开关分别控制。</li>
<li>部分级控制：例如，第i级使用i+1个控制信号控制 (0in-1)。<br>同一个多级互连网络分别常用三种不同的控制方式，可以构成三种不同的互连网络。</li>
</ol>
<h5 id="多级立方体网"><a href="#多级立方体网" class="headerlink" title="多级立方体网"></a>多级立方体网</h5><ul>
<li><p>采用二功能开关，总共需要开关 n 2n-1个。</p>
</li>
<li><p>采用交换函数构成拓扑结构，各级分别采用E0、E1、…En-1交换函数。</p>
</li>
<li><p>当所有开关都直通时，实现恒等变换。当A、B、C、D四个开关交换，其余直通时实现 E0 互连函数。当E、F、G、H四个开关交换，其余直通时实现 E1 互连函数。当I、J、K、L四个开关交换，其余直通时实现 E2 互连函数。</p>
</li>
<li><p>采用三种不同的控制方式，可以构成三种不同的互连网络。</p>
<p>采用级控制可以构成STARAN交换网。</p>
<p>采用部分级控制，可以构成STARAN移数网。</p>
<p>采用单元控制可以构成间接二进制n方体网。</p>
</li>
</ul>
<p><img src="/imgs/ca/191.png" alt="image-20231226110830041"></p>
<p>开关：a ×b开关，如2 ×2开关ISC：级间互连模式 </p>
<p><img src="/imgs/ca/192.png" alt="image-20231226110908796"></p>
<p>有STARAN网络——级控制、部分级控制<br>间接二进制n方体网络——单元控制<br>以STARAN网络为例<br>交换开关：二功能（直通和交换） 拓扑结构：第i级为Cubei</p>
<h6 id="交换功能FLIP网络"><a href="#交换功能FLIP网络" class="headerlink" title="交换功能FLIP网络"></a>交换功能FLIP网络</h6><p>控制：级控制(开关为1时交换功能，否则为直通)</p>
<p><img src="/imgs/ca/193.png" alt="image-20231226111247124"></p>
<p><img src="/imgs/ca/194.png" alt="image-20231226111646766"></p>
<p><img src="/imgs/ca/195.png" alt="image-20231226111715038"></p>
<h6 id="移位功能（移数网络）"><a href="#移位功能（移数网络）" class="headerlink" title="移位功能（移数网络）"></a>移位功能（移数网络）</h6><p><img src="/imgs/ca/196.png" alt="image-20231226111859886"></p>
<p>拓扑结构：不同级完成地址不同位取反功能。</p>
<p>注意：有交换开关的拓扑结构的实现。</p>
<ol>
<li>级控制且开关为二功能开关：<br>ω网络是STARAN交换网络的逆网络； （F、G交换位置） </li>
<li>部分级控制且开关为二功能：<br>ω网络是STARAN移数网络的逆网络； </li>
<li>单元控制：可实现更强大的功能。<br>利用交换开关的播送功能实现一对多的连接。</li>
</ol>
<h4 id="多级混洗-交换网络"><a href="#多级混洗-交换网络" class="headerlink" title="多级混洗-交换网络"></a>多级混洗-交换网络</h4><p>多级混洗—交换网络又称为Omega网。</p>
<p>多级混洗—交换网络结构：它由n级构成，每一级包含一个无条件混洗拓扑线路和一列可控的二元交换开关，前后重复，便于制造。如P436图7.43所示。</p>
<p>各级编号是n-1，……，0，即按降序排列。</p>
<p>在多级混洗—交换网络中，单独一级混洗拓扑线路可完成一次数据混洗（shuffle），而单独一列二元交换开关在处于“交换”状态时可完成一次交换操作（Cube0）。如果各级二元交换开关都处于“直连”状态，N个结点的数据通过网络仅经过n次混洗操作，排列顺序最终恢复输入状态（混洗函数性质2）；如果各级二元交换开关都处于“交换”状态，则N个结点的数据在每次混洗之后紧接着一次交换（Cube0），也就是地址码的最低位取反，最后n位地址均被取反。程序员根据数据置换或复制的需要，可以灵活地设置各开关的状态。</p>
<h5 id="寻径算法-x2F-路由算法"><a href="#寻径算法-x2F-路由算法" class="headerlink" title="寻径算法&#x2F;路由算法"></a>寻径算法&#x2F;路由算法</h5><p>目的：根据给定的输入&#x2F;输出对应关系，确定各开关的状态。</p>
<p>名称：源-目的地址异或法</p>
<p>操作：将任一个输入地址与它要到达的输出地址作异或运算，其结果的biti位控制数据到达的第i级开关，“0”表示“直连”，“1”表示“交换”。</p>
<p>例如给定传输101B→011B，二者异或结果为110B，于是从101B号输入端开始，把它遇到的第2级开关置为“交换”，第1级开关置为“交换”，第0级开关置为“直连”。如下图红线所示。</p>
<p><img src="/imgs/ca/197.png" alt="image-20231226143118308"></p>
<h4 id="全排列网络"><a href="#全排列网络" class="headerlink" title="全排列网络"></a>全排列网络</h4><h5 id="多级网络比较"><a href="#多级网络比较" class="headerlink" title="多级网络比较"></a>多级网络比较</h5><p>灵活性(低→高)：STARAN、间接二进制n方体、<br>                  Omega(ω)、ADM(混洗四功能)</p>
<p>成本(低→高)：同上</p>
<p>用途： STARAN、Omega        PE←→M</p>
<p>间接二进制n方体      PE→PE</p>
<p>功能：只能实现同时部分多对多功能。</p>
<h5 id="全排列网络-1"><a href="#全排列网络-1" class="headerlink" title="全排列网络"></a>全排列网络</h5><p>只允许1对1</p>
<p>定义：所有入端、出端的连接均不发生冲突的网络，又称非阻塞型网络，即：N入→N出有N！种排列。</p>
<h3 id="消息传递机制"><a href="#消息传递机制" class="headerlink" title="消息传递机制"></a>消息传递机制</h3><h4 id="消息寻径方式"><a href="#消息寻径方式" class="headerlink" title="消息寻径方式"></a>消息寻径方式</h4><ul>
<li><p>线路交换</p>
</li>
<li><p>存储转发</p>
</li>
<li><p>虚拟直通</p>
</li>
<li><p>虫蚀寻径</p>
</li>
<li><p>Store-and-forward routing</p>
</li>
<li><p>Wormhole routing</p>
</li>
<li><p>Virtual channels</p>
</li>
<li><p>Deadlock situations</p>
</li>
<li><p>Deterministic and adaptive routing algorithms</p>
</li>
</ul>
<h4 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h4><ul>
<li>消息：节点间通信的逻辑单元</li>
<li>数据包：包含路由目标地址的基本单元</li>
<li>数据包具有顺序 用于重组</li>
<li>Flits：数据包的流量控制位flow control units</li>
<li>存储和转发：数据包</li>
<li>虫洞路由：飞</li>
</ul>
<p><img src="/imgs/ca/198.png" alt="image-20231226145437884"></p>
<h5 id="包与flits"><a href="#包与flits" class="headerlink" title="包与flits"></a>包与flits</h5><ul>
<li>头部flits包括路由信息和序列号</li>
<li>flits长度受网络规模影响</li>
<li>包长度由路由策略和网络实现决定</li>
<li>长度也与信道带宽、路由设计、网络交通等相关</li>
</ul>
<h4 id="存储转发路由"><a href="#存储转发路由" class="headerlink" title="存储转发路由"></a>存储转发路由</h4><ul>
<li>数据包是基本单位</li>
<li>每个节点都有一个数据包缓冲区</li>
<li>当数据包到达中间节点时，它首先存储在缓冲区中，在输出通道和下一个缓冲区准备就绪时发送</li>
<li>延迟与源和目标之间的距离成正比</li>
</ul>
<h4 id="虫洞路由"><a href="#虫洞路由" class="headerlink" title="虫洞路由"></a>虫洞路由</h4><ul>
<li>Flits 是基本单位</li>
<li>通过路由器序列进行传输</li>
<li>同一数据包的所有 flit 都通过流水线传输</li>
<li>所有数据 flits 都遵循标头 flit</li>
<li>数据包可以交错，而不是flits</li>
<li>延迟几乎与距离无关</li>
</ul>
<p><img src="/imgs/ca/199.png" alt="image-20231226145723856"></p>
<h5 id="异步流水线"><a href="#异步流水线" class="headerlink" title="异步流水线"></a>异步流水线</h5><ul>
<li>flits 的流水线是异步的</li>
<li>相邻路由器之间使用的 1 位就绪&#x2F;请求线</li>
<li>当 D 准备好接收flit时，R&#x2F;A &#x3D; 0</li>
<li>当 S 就绪时，R&#x2F;A &#x3D; 1，并发送 flit i</li>
<li>在收到flit时，R&#x2F;A 保持高位</li>
<li>对剩余的flits重复循环</li>
</ul>
<h5 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h5><p><img src="/imgs/ca/200.png" alt="image-20231226151018950"></p>
<h5 id="延迟分析"><a href="#延迟分析" class="headerlink" title="延迟分析"></a>延迟分析</h5><p><img src="/imgs/ca/201.png" alt="image-20231226151751430"></p>
<h4 id="虚拟直通"><a href="#虚拟直通" class="headerlink" title="虚拟直通"></a>虚拟直通</h4><ul>
<li>逻辑链路 b&#x2F;t 两个节点，由源中的 flit 缓冲区、它们的物理通道 b&#x2F;t 和接收器中的 flit 缓冲区组成</li>
<li>物理通道由虚拟通道共享时间</li>
<li>一组虚拟信道对物理信道的共享是通过逐个flit进行的时间复用进行的</li>
</ul>
<p><img src="/imgs/ca/202.png" alt="image-20231226152250951"></p>
<h5 id="死锁情况"><a href="#死锁情况" class="headerlink" title="死锁情况"></a>死锁情况</h5><p><img src="/imgs/ca/203.png" alt="image-20231226152623747"></p>
<h5 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h5><ul>
<li>单向&#x2F;双向通道</li>
<li>将两个单向组合成一个双向将提高利用率和双通道信道</li>
<li>双向仲裁更复杂</li>
<li>实现大量虚拟通道需要高速多路复用</li>
</ul>
<p><img src="/imgs/ca/204.png" alt="image-20231226152853125"></p>
<h5 id="包冲突解决"><a href="#包冲突解决" class="headerlink" title="包冲突解决"></a>包冲突解决</h5><ul>
<li>要移动 flit b&#x2F;t 相邻节点必须具有：<ul>
<li>源缓冲区保持 flit</li>
<li>正在分配的通道</li>
<li>接收方缓冲区接受 flit</li>
</ul>
</li>
<li>仲裁裁决<ul>
<li>哪个数据包将被分配通道</li>
<li>如何处理被拒绝的数据包</li>
</ul>
</li>
</ul>
<h5 id="使用虚拟直通路由进行缓冲"><a href="#使用虚拟直通路由进行缓冲" class="headerlink" title="使用虚拟直通路由进行缓冲"></a>使用虚拟直通路由进行缓冲</h5><ul>
<li>被拒绝的数据包临时存储在缓冲区中</li>
<li>需要较大的缓冲区来容纳整个数据包</li>
<li>不浪费分配的资源</li>
<li>最佳案例：虫洞路由</li>
<li>最坏情况：存储转发</li>
</ul>
<h5 id="拥塞和绕路策略"><a href="#拥塞和绕路策略" class="headerlink" title="拥塞和绕路策略"></a>拥塞和绕路策略</h5><ul>
<li>阻塞：阻断被拒绝的数据包，不放弃<ul>
<li>经济、闲置的资源</li>
</ul>
</li>
<li>丢弃：滴块包装<ul>
<li>资源浪费</li>
</ul>
</li>
<li>绕行：绕行通道的路线错误<ul>
<li>灵活，但浪费通道资源，可能造成活锁循环</li>
</ul>
</li>
</ul>
<p><img src="/imgs/ca/205.png" alt="image-20231226155210678"></p>
<h4 id="维度顺序路由"><a href="#维度顺序路由" class="headerlink" title="维度顺序路由"></a>维度顺序路由</h4><ul>
<li>确定性：补丁完全确定</li>
<li>自适应：取决于 n&#x2F;w 条件</li>
<li>维度顺序：要求选择连续的通道，以根据维度遵循特定顺序<ul>
<li>X-Y 路由、E-cube 路由</li>
</ul>
</li>
</ul>
<h4 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h4><p>互连网络的基本功能，就是要在多处理机或多计算机的各个结点间实现高效率的通信。在静态互连网络中，当源结点和目的结点间没有直接的链路相连接时，信息就要经过中间的结点进行传递。路由选择就是用来实现经中间结点转递功能的通信方法和算法。通俗的说，路由选择就是通路选择或路径选择，有的文献中简称寻径。     </p>
<p>网络结点间建立通信通路有静态和动态两种方法。静态方法是在程序执行之前就把通路配置好了，并且在程序的整个执行过程中一直保持这个连接。这个方法仅适合于事先已经知道程序的通信需求，并且在通信的节点建有足够多的可供配置专用通路的网络资源。但是大部分情况下，程序的通信需求事先并不能预测，需要采用动态方法，按需求动态建立通信通路。 </p>
<p>常用的静态拓扑互连网络中，常用的通路选择方法有两种，一种是确定性方法，一种是自适应方法。</p>
<ol>
<li><p>确定性通路选择法     </p>
<p>确定性(deterministic)方法完全由源地址和目的地址来决定路由，一对源地址和目的地址之间只有一条通路可选，这条固定的通路通常是选择几条最短通路中的一条，而且在这条通路的各个中间节点间转递分组的算法也要求简单。这种算法的优点是简单，但如果遇到有冲突或故障时，就无法改选其他通路。 </p>
</li>
<li><p>自适应通路选择法     </p>
<p>在自适应(adaptive)方法中。通信的通路每次都要根据通信资源或者网络的情况来选择，这样就可以避开拥挤的或者有故障的结点，从而网络资源的利用效率可以得到改进。</p>
</li>
</ol>
<p>两种具体的寻径算法</p>
<p>下面重点讨论两种具体的确定性寻径算法，即X-Y寻径算法和E-立方寻径算法。前者用于二维互连网络，后者用于超立方互连网络。</p>
<ol>
<li><p>X-Y寻径算法</p>
<p>X-Y寻径算法在二维互联网络中选择路由时，首先沿着X维方向确定路径，然后沿着Y维方向选择路径。</p>
<p>假定从任意源结点s&#x3D;(X1，Y1)到任意目的结点d&#x3D;(X2，Y2)。寻径从s开始，首先沿着X方向前进一直到d所在的第X2列为止，然后沿Y方向前进直到d。</p>
<p>X-Y寻径法有四种寻径模式：东-北，东-南，西-北，西-南。</p>
<p><img src="/imgs/ca/206.png" alt="image-20231226155517713"></p>
</li>
<li><p>E-立方路由算法</p>
<p><img src="/imgs/ca/207.png" alt="image-20231226155559607"></p>
<p><img src="/imgs/ca/208.png" alt="image-20231226155619587"></p>
</li>
</ol>
<h4 id="通讯模式"><a href="#通讯模式" class="headerlink" title="通讯模式"></a>通讯模式</h4><ul>
<li>单播：一个源和一个目标</li>
<li>组播：一对多通信</li>
<li>广播：一对多通信</li>
<li>会议：多对多通信<ul>
<li>最通用的模式</li>
</ul>
</li>
</ul>
<h4 id="路由效率"><a href="#路由效率" class="headerlink" title="路由效率"></a>路由效率</h4><ul>
<li>通道流量：用于随时传递消息的通道数</li>
<li>通信时延：涉及的最长数据包传输时间</li>
<li>延迟对于存储和转发更重要</li>
<li>流量需求对虫洞路由更重要</li>
</ul>
<h3 id="网络：路由与设计"><a href="#网络：路由与设计" class="headerlink" title="网络：路由与设计"></a>网络：路由与设计</h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><h5 id="路由-1"><a href="#路由-1" class="headerlink" title="路由"></a>路由</h5><ul>
<li>召回：路由算法确定<ul>
<li>哪些可能的路径用作路由</li>
<li>如何确定路线</li>
<li>R：N x N -&gt; C，在每个交换机上将目标节点 nd 映射到路由上的下一个通道</li>
</ul>
</li>
<li>问题：<ul>
<li>路由机制<ul>
<li>算术</li>
<li>基于源的端口选择</li>
<li>表驱动</li>
<li>一般计算</li>
</ul>
</li>
<li>路由的属性</li>
<li>死锁费</li>
</ul>
</li>
</ul>
<h5 id="路由机制"><a href="#路由机制" class="headerlink" title="路由机制"></a>路由机制</h5><ul>
<li>需要为每个输入数据包选择输出端口在几个周期内</li>
<li>常规拓扑中的简单算术<ul>
<li>例如：网格中的 Dx、Dy 路由<ul>
<li>西 （-x） Dx &lt; 0 </li>
<li>东 （+x） Dx &gt; 0</li>
<li>南 （-y） Dx &#x3D; 0， Dy &lt; 0 </li>
<li>北 （+y） Dx &#x3D; 0， Dy &gt; 0</li>
<li>处理器 Dx &#x3D; 0，Dy &#x3D; 0</li>
</ul>
</li>
</ul>
</li>
<li>按顺序减少每个维度的相对地址<ul>
<li>k 元 d 立方体中的维度顺序路由</li>
<li>N-Cube 中的 E-Cube 路由</li>
</ul>
</li>
<li>基于源<ul>
<li>消息头携带一系列端口选择在途中使用和剥离</li>
<li>CRC? Packet Format?</li>
<li>CS-2, Myrinet, MIT Artic</li>
</ul>
</li>
<li>表驱动<ul>
<li>消息头在下一个交换机上携带下一个端口的索引<ul>
<li>o &#x3D; R[i]</li>
</ul>
</li>
<li>表还给出了后续跃点的索引<ul>
<li>o， I’ &#x3D; R[i ]</li>
</ul>
</li>
<li>ATM、HPPI</li>
</ul>
</li>
</ul>
<h5 id="路由算法属性"><a href="#路由算法属性" class="headerlink" title="路由算法属性"></a>路由算法属性</h5><ul>
<li>确定性<ul>
<li>路由由（源、目标）确定，而不是中间状态（即流量）</li>
</ul>
</li>
<li>适应的<ul>
<li>受沿途交通影响的路线</li>
</ul>
</li>
<li>极小<ul>
<li>仅选择最短路径</li>
</ul>
</li>
<li>无死锁<ul>
<li>没有流量模式会导致没有数据包转发的情况</li>
</ul>
</li>
</ul>
<h5 id="免于死锁"><a href="#免于死锁" class="headerlink" title="免于死锁"></a>免于死锁</h5><ul>
<li>它怎么会出现？<ul>
<li>必要条件：<ul>
<li>共享资源</li>
<li>增量分配</li>
<li>不可抢占</li>
</ul>
</li>
<li>将通道视为以增量方式获取的共享资源<ul>
<li>源缓冲区，然后是目标缓冲区</li>
<li>沿路线的通道</li>
</ul>
</li>
</ul>
</li>
<li>你如何避免它？<ul>
<li>限制渠道资源的分配方式</li>
<li>例如：维度顺序</li>
</ul>
</li>
<li>如何证明路由算法是无死锁的</li>
</ul>
<p><strong>证明技术</strong></p>
<ul>
<li><p>资源在逻辑上与通道相关联</p>
</li>
<li><p>消息在资源向前移动时会引入资源之间的依赖关系</p>
</li>
<li><p>需要阐明渠道之间可能出现的依赖关系</p>
</li>
<li><p>显示通道依赖关系图中没有循环</p>
<ul>
<li>找到通道资源的编号，以便每个合法路由都遵循单调序列<br>&#x3D;&gt; 任何流量模式都可能导致死锁</li>
</ul>
</li>
<li><p>网络在通道依赖图上不必是非循环的</p>
</li>
</ul>
<h4 id="开关设计"><a href="#开关设计" class="headerlink" title="开关设计"></a>开关设计</h4><p><img src="/imgs/ca/209.png" alt="image-20231226161825965"></p>
<p>输入缓冲开关</p>
<p><img src="/imgs/ca/210.png" alt="image-20231226161940523"></p>
<p>输出缓冲开关</p>
<p><img src="/imgs/ca/211.png" alt="image-20231226162005363"></p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>当推来推去时，你会怎么做？</p>
<ul>
<li>以太网：冲突检测和延迟后重试</li>
<li>FDDI，令牌环：仲裁令牌</li>
<li>TCP&#x2F;WAN：缓冲、丢弃、调整速率</li>
<li>任何解决方案都必须根据输出速率进行调整</li>
</ul>
<p>链路层级流量控制</p>
<p><img src="/imgs/ca/212.png" alt="image-20231226162323137"></p>
<p>短链路</p>
<p><img src="/imgs/ca/213.png" alt="image-20231226162350980"></p>
<p>长链路</p>
<p><img src="/imgs/ca/214.png" alt="image-20231226162408548"></p>
<p>平滑流量</p>
<p><img src="/imgs/ca/215.png" alt="image-20231226162438906"></p>
<p>链路和全局流量控制</p>
<ul>
<li>热点</li>
<li>全局通信业务</li>
<li>自然的并行程序依赖性</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>路由算法限制拓扑中的路由集<ul>
<li>简单的机制在每一跳选择转弯</li>
<li>算术、选择、查找</li>
</ul>
</li>
<li>如果通道依赖关系图是非循环的，则无死锁<ul>
<li>限制次数以消除相关性</li>
<li>添加单独的通道资源以打破依赖关系</li>
<li>拓扑、算法和开关设计的组合</li>
</ul>
</li>
<li>确定性路由与自适应路由</li>
<li>开关设计问题</li>
<li>输入&#x2F;输出&#x2F;池缓冲、路由逻辑、选择逻辑流控制</li>
<li>真正的网络是设计选择的“包”</li>
</ul>
<h3 id="互连网络实例"><a href="#互连网络实例" class="headerlink" title="互连网络实例"></a>互连网络实例</h3><h4 id="总线互连"><a href="#总线互连" class="headerlink" title="总线互连"></a>总线互连</h4><ul>
<li><p>目前，大部分处理机内部采用总线结构。</p>
<p>CPU与存储器之间有系统总线</p>
<p>存储器与输入输出设备之间有I&#x2F;O</p>
<p>总线总线与总线之间通过总线桥连接</p>
</li>
<li><p>总线的主要优点是结构简单，能够很方便实现广播通信。</p>
</li>
<li><p>总线的主要缺点是带宽低，发生总线冲突的可能性大。</p>
</li>
<li><p>总线冲突的解决办法有：</p>
<ol>
<li>设置静态优先级</li>
<li>在同步方式中采用时间片</li>
<li>采用动态优先级（如LRU法等）</li>
<li>先来先服务</li>
</ol>
</li>
<li><p>为了提高总线的通信带宽，有如下方法：</p>
<ol>
<li>采用多总线结构</li>
<li>层次总线结构</li>
<li>多维总线结构</li>
</ol>
</li>
</ul>
<p><img src="/imgs/ca/216.png" alt="image-20231226162934233"></p>
<h4 id="多端口存储器"><a href="#多端口存储器" class="headerlink" title="多端口存储器"></a>多端口存储器</h4><ul>
<li>目前的计算机一般以存储器为中心。多个多端口存储器与多个CPU和IOP连接</li>
<li>多端口存储器主要用于处理机个数不多的系统中。这种互连方式把复杂的互连网络移到了存储器中。</li>
</ul>
<p><img src="/imgs/ca/217.png" alt="image-20231226163026968"></p>
<h2 id="余爹押题"><a href="#余爹押题" class="headerlink" title="余爹押题"></a>余爹押题</h2><p>十大题</p>
<p>填空题20分</p>
<p>九大题80分</p>
<h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>开关</p>
<h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><p>向量优化</p>
<p>向量处理方式，向量处理</p>
<h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><p>相关性，处理相关性，针对计算流水性能分析</p>
<p>静态动态</p>
<p>先后算，</p>
<p>RAW去除</p>
<h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><p>IO输入输出：中断优先级</p>
<p>IOP 通道 最大流量 工作周期</p>
<p>通道与设备是否能连接</p>
<h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><p>存储系统</p>
<p>存储系统层次、目标 交叉</p>
<p>地址变换提速</p>
<p>cache性能优化</p>
<p>替换算法</p>
<p>堆栈替换算法</p>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>指令系统</p>
<p>指令构成</p>
<p>寻址方式 间接寻址、变址寻址-》扩充寻址空间；立即寻址</p>
<p>频度分析</p>
<p>指令格式优化 操作码 操作数 优化方法 <strong>下一指令标记</strong></p>
<p>两种指令系统cisc risc 使用的技术</p>
<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>填空概念</p>
<p>CPI计算</p>
<p>阿姆达尔定理</p>
<p>设计原理</p>
<p>局部性原理</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">J&Ocean</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jiang-wu-19.github.io/2023/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">https://jiang-wu-19.github.io/2023/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">J&Ocean</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">
                                    <span class="chip bg-color">计算机体系结构</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">请我喝杯奶茶吧~</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'Nv6Wx6PAYH30bfcx7u0eDWHy-gzGzoHsz',
        appKey: 'IhPcpC3fDP8Ro7eaPakG2vSt',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/09/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="软件工程笔记">
                        
                        <span class="card-title">软件工程笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            2023秋-软件工程
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-09-27
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                    笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">
                        <span class="chip bg-color">软件工程</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/09/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="机器学习笔记">
                        
                        <span class="card-title">机器学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            2023秋-机器学习
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-09-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                    笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">
                        <span class="chip bg-color">机器学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: J&amp;Ocean BLOG<br />'
            + '文章作者: J&amp;Ocean<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2024</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">J&Ocean</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">298.2k</span>&nbsp;字
            
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2023";
                    var startMonth = "7";
                    var startDate = "2";
                    var startHour = "12";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/JIANG-Wu-19" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:wujiang0319@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=870027163" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 870027163" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/bei-wei-xiao-wu-32" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/bei-wei-xiao-wu-32" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
