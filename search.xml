<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法课外思考题一</title>
      <link href="/2023/07/05/%E7%AE%97%E6%B3%95%E8%AF%BE%E5%A4%96%E6%80%9D%E8%80%83%E9%A2%98%E4%B8%80/"/>
      <url>/2023/07/05/%E7%AE%97%E6%B3%95%E8%AF%BE%E5%A4%96%E6%80%9D%E8%80%83%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一栈结构，使得出栈、入栈以及求栈的最小值均能在$O (1)$时间内完成</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>针对出入栈</strong>，由数据结构的顺序栈知识可以得知，出入栈的时间复杂度都是$O (1)$，因此对于出入栈只需要普通栈就可以实现问题要求；</p><p><strong>针对求栈的最小值</strong>，使用遍历法求栈最小值的时间复杂度为$O (n)$，因此需要设计一种特殊栈，通过记录栈中的最小值，在求栈的最小值时只需要将最小值输出即可，其时间复杂度为$O (1)$。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>先构建顺序栈的数据结构</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;&#x2F;&#x2F;顺序栈    SElemType* base;    SElemtyoe* top;    int stacksize;&#125;SqStack;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后构建一个特殊的辅助栈，包括存储所有数据的原栈和存储最小值序列的新栈</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;&#x2F;&#x2F;记录最小值的辅助栈    SqStack Data;    Sqstack MinData;&#125;MinStack;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>入栈操作</p><p>对于第一个元素，一定会进入两个栈；</p><p>对于后面的每一元素一定会进入Data栈，如果该元素&lt;&#x3D;Mindata栈的栈顶元素，则该元素进入Mindata栈，否则不进入</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void MinPush(Minstack* minstack, SElemType e) &#123;Push(&amp;minstack-&gt;Data, e);if (minstack-&gt;MinData.base&#x3D;&#x3D;minstack-&gt;MinData.top) &#123;Push(&amp;minstack-&gt;MinData, e);&#125;else &#123;if (e &lt;&#x3D; GetTop(minstack-&gt;MinData)) &#123;Push(&amp;minstack-&gt;MinData, e);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>出栈操作</p><p>对于某一元素的出栈，Data栈一定会执行出栈操作，如果Data栈的栈顶元素和MinData栈的栈顶元素相同，则MinData栈也执行出栈操作</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void MinPop(Minstack* minstack, SElemType* e) &#123;if (GetTop(minstack-&gt;Data) &#x3D;&#x3D; GetTop(minstack-&gt;MinData)) &#123;Pop(&amp;minstack-&gt;Data, e);Pop(&amp;minstack-&gt;MinData, e);return;&#125;Pop(&amp;minstack-&gt;Data, e);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>求栈最小值</p><p>最小值已经存储在MinData栈中，因此只需要获取MinData栈的栈顶元素就可以得到栈的最小值</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">SElemType GetMin(Minstack* minstack) &#123;return GetTop(minstack-&gt;MinData);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="算法代码与分析"><a href="#算法代码与分析" class="headerlink" title="算法代码与分析"></a>算法代码与分析</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#define STACK_INIT_SIZE 100using namespace std;typedef int SElemType;typedef struct &#123;SElemType* base;SElemType* top;int stacksize;&#125;SqStack;typedef struct &#123;SqStack Data;SqStack MinData;&#125;Minstack;void InitStack(SqStack* s) &#123;s-&gt;base &#x3D; (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType));s-&gt;top &#x3D; s-&gt;base;s-&gt;stacksize &#x3D; STACK_INIT_SIZE;&#125;void Push(SqStack* s, SElemType e) &#123;if (s-&gt;top - s-&gt;base &gt;&#x3D; s-&gt;stacksize) &#123;s-&gt;base &#x3D; (SElemType*)realloc(s-&gt;base, (s-&gt;stacksize + 10) * sizeof(SElemType));s-&gt;top &#x3D; s-&gt;base + s-&gt;stacksize;s-&gt;stacksize +&#x3D; 10;&#125;*s-&gt;top++ &#x3D; e;&#125;void Pop(SqStack* s, SElemType* e) &#123;*e &#x3D; *--s-&gt;top;&#125;SElemType GetTop(SqStack s) &#123;return *(--s.top);&#125;void DestroyStack(SqStack* s) &#123;free(s-&gt;base);s-&gt;base &#x3D; NULL;s-&gt;top &#x3D; NULL;s-&gt;stacksize &#x3D; 0;&#125;void MinInit(Minstack* minstack) &#123;InitStack(&amp;(minstack-&gt;Data));InitStack(&amp;(minstack-&gt;MinData));&#125;void MinDestroy(Minstack* minstack) &#123;DestroyStack(&amp;minstack-&gt;Data);DestroyStack(&amp;minstack-&gt;MinData);&#125;void MinPush(Minstack* minstack, SElemType e) &#123;Push(&amp;minstack-&gt;Data, e);if (minstack-&gt;MinData.base&#x3D;&#x3D;minstack-&gt;MinData.top) &#123;Push(&amp;minstack-&gt;MinData, e);&#125;else &#123;if (e &lt;&#x3D; GetTop(minstack-&gt;MinData)) &#123;Push(&amp;minstack-&gt;MinData, e);&#125;&#125;&#125;void MinPop(Minstack* minstack, SElemType* e) &#123;if (GetTop(minstack-&gt;Data) &#x3D;&#x3D; GetTop(minstack-&gt;MinData)) &#123;Pop(&amp;minstack-&gt;Data, e);Pop(&amp;minstack-&gt;MinData, e);return;&#125;Pop(&amp;minstack-&gt;Data, e);&#125;SElemType GetMin(Minstack* minstack) &#123;return GetTop(minstack-&gt;MinData);&#125;int main() &#123;Minstack minstack;SElemType e;MinInit(&amp;minstack);MinPush(&amp;minstack, 1);MinPush(&amp;minstack, 2);MinPush(&amp;minstack, 3);MinPush(&amp;minstack, 1);MinPop(&amp;minstack, &amp;e);cout &lt;&lt; GetMin(&amp;minstack) &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实验结果</strong>：</p><p><img src="/imgs/sikao1/1.png" alt="image-20230302194755588"></p><p><strong>分析</strong>：</p><p>本算法能够实现出入栈、求栈最小值时间复杂度$O (1)$，但是在数据类型的定义上，关于栈和特殊栈存在重复，经查阅资料，可以采用结构体继承解决。</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>改进冒泡排序使得在最好情况下可以在线性时间内完成</p><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>对于普通的冒泡排序算法，在最坏的情况下其时间复杂度为$O (n^2)$。第一趟排序进行了$(n-1)$次比较，第i趟排序进行了$(n-i)$次比较；但是对于$(n-1)$趟排序，如果序列在某一次排序时恰好有序，则在该次之后的每一次排序都是无用的，为了优化冒泡排序，只需要在该次以后终止冒泡排序。</p><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>设置一个标志变量确定某一序列中的数据是否发生了交换，如果某一次冒泡过程中发现没有交换操作时，则说明序列已经排好序了，终止冒泡排序。</p><h3 id="算法代码及分析"><a href="#算法代码及分析" class="headerlink" title="算法代码及分析"></a>算法代码及分析</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;void BubbleSort(int array[], int n,int* num) &#123;for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;bool flag &#x3D; true;for (int j &#x3D; 0; j &lt; n - i - 1; j++) &#123;if (array[j] &gt; array[j + 1]) &#123;int temp &#x3D; array[j];array[j] &#x3D; array[j + 1];array[j + 1] &#x3D; temp;flag &#x3D; false;&#125;&#125;if (flag) &#123;break;&#125;(*num)++;&#125;&#125;int main() &#123;int num &#x3D; 0;int array[] &#x3D; &#123; 5,4,3,6,7,8 &#125;;int n1 &#x3D; sizeof(array) &#x2F; sizeof(int);cout &lt;&lt; &quot;排序前：&quot;;for (int i &#x3D; 0; i &lt; n1; i++) &#123;cout &lt;&lt; array[i] &lt;&lt; &quot;,&quot;;&#125;cout &lt;&lt; endl;BubbleSort(array, n1, &amp;num);cout &lt;&lt; &quot;排序后：&quot;;for (int i &#x3D; 0; i &lt; n1; i++) &#123;cout &lt;&lt; array[i] &lt;&lt; &quot;,&quot;;&#125;cout &lt;&lt; endl;int array1[] &#x3D; &#123; 1,2,3,4,5,6 &#125;;int n2 &#x3D; sizeof(array1) &#x2F; sizeof(int);cout &lt;&lt; &quot;排序前：&quot;;for (int i &#x3D; 0; i &lt; n2; i++) &#123;cout &lt;&lt; array1[i] &lt;&lt; &quot;,&quot;;&#125;cout &lt;&lt; endl;cout &lt;&lt; num &lt;&lt; endl;num &#x3D; 0;BubbleSort(array1, n2, &amp;num);cout &lt;&lt; &quot;排序后：&quot;;for (int i &#x3D; 0; i &lt; n2; i++) &#123;cout &lt;&lt; array1[i] &lt;&lt; &quot;,&quot;;&#125;cout &lt;&lt; endl;cout &lt;&lt; num &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实验结果</strong>：</p><p><img src="/imgs/sikao1/2.png" alt="image-20230302210218006"></p><p><strong>分析</strong>：</p><p>通过实验分析，在数据极端良好的情况下，能够实现时间复杂度为$O (1)$；在数据较为不良的情况下，仍能减少数据排序次数，使其在线性时间内完成。</p>]]></content>
      
      
      <categories>
          
          <category> 算法思考题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 冒泡 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
